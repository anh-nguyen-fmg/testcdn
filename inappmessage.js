var qM = Object.defineProperty;
var ZC = (e) => {
  throw TypeError(e);
};
var XM = (e, t, n) => t in e ? qM(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;
var Ni = (e, t, n) => XM(e, typeof t != "symbol" ? t + "" : t, n), Op = (e, t, n) => t.has(e) || ZC("Cannot " + n);
var ne = (e, t, n) => (Op(e, t, "read from private field"), n ? n.call(e) : t.get(e)), At = (e, t, n) => t.has(e) ? ZC("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, n), vt = (e, t, n, r) => (Op(e, t, "write to private field"), r ? r.call(e, n) : t.set(e, n), n), pe = (e, t, n) => (Op(e, t, "access private method"), n);
function ZM(e, t) {
  for (var n = 0; n < t.length; n++) {
    const r = t[n];
    if (typeof r != "string" && !Array.isArray(r)) {
      for (const i in r)
        if (i !== "default" && !(i in e)) {
          const s = Object.getOwnPropertyDescriptor(r, i);
          s && Object.defineProperty(e, i, s.get ? s : {
            enumerable: !0,
            get: () => r[i]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }));
}
var Oc = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function ru(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Bp = { exports: {} }, cl = {}, Np = { exports: {} }, Fe = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var QC;
function QM() {
  if (QC) return Fe;
  QC = 1;
  var e = Symbol.for("react.element"), t = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), s = Symbol.for("react.provider"), l = Symbol.for("react.context"), u = Symbol.for("react.forward_ref"), d = Symbol.for("react.suspense"), h = Symbol.for("react.memo"), f = Symbol.for("react.lazy"), m = Symbol.iterator;
  function g($) {
    return $ === null || typeof $ != "object" ? null : ($ = m && $[m] || $["@@iterator"], typeof $ == "function" ? $ : null);
  }
  var w = { isMounted: function() {
    return !1;
  }, enqueueForceUpdate: function() {
  }, enqueueReplaceState: function() {
  }, enqueueSetState: function() {
  } }, E = Object.assign, b = {};
  function A($, M, W) {
    this.props = $, this.context = M, this.refs = b, this.updater = W || w;
  }
  A.prototype.isReactComponent = {}, A.prototype.setState = function($, M) {
    if (typeof $ != "object" && typeof $ != "function" && $ != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, $, M, "setState");
  }, A.prototype.forceUpdate = function($) {
    this.updater.enqueueForceUpdate(this, $, "forceUpdate");
  };
  function x() {
  }
  x.prototype = A.prototype;
  function R($, M, W) {
    this.props = $, this.context = M, this.refs = b, this.updater = W || w;
  }
  var _ = R.prototype = new x();
  _.constructor = R, E(_, A.prototype), _.isPureReactComponent = !0;
  var L = Array.isArray, V = Object.prototype.hasOwnProperty, O = { current: null }, D = { key: !0, ref: !0, __self: !0, __source: !0 };
  function B($, M, W) {
    var G, ee = {}, Q = null, q = null;
    if (M != null) for (G in M.ref !== void 0 && (q = M.ref), M.key !== void 0 && (Q = "" + M.key), M) V.call(M, G) && !D.hasOwnProperty(G) && (ee[G] = M[G]);
    var re = arguments.length - 2;
    if (re === 1) ee.children = W;
    else if (1 < re) {
      for (var ve = Array(re), Ce = 0; Ce < re; Ce++) ve[Ce] = arguments[Ce + 2];
      ee.children = ve;
    }
    if ($ && $.defaultProps) for (G in re = $.defaultProps, re) ee[G] === void 0 && (ee[G] = re[G]);
    return { $$typeof: e, type: $, key: Q, ref: q, props: ee, _owner: O.current };
  }
  function H($, M) {
    return { $$typeof: e, type: $.type, key: M, ref: $.ref, props: $.props, _owner: $._owner };
  }
  function J($) {
    return typeof $ == "object" && $ !== null && $.$$typeof === e;
  }
  function ce($) {
    var M = { "=": "=0", ":": "=2" };
    return "$" + $.replace(/[=:]/g, function(W) {
      return M[W];
    });
  }
  var fe = /\/+/g;
  function de($, M) {
    return typeof $ == "object" && $ !== null && $.key != null ? ce("" + $.key) : M.toString(36);
  }
  function he($, M, W, G, ee) {
    var Q = typeof $;
    (Q === "undefined" || Q === "boolean") && ($ = null);
    var q = !1;
    if ($ === null) q = !0;
    else switch (Q) {
      case "string":
      case "number":
        q = !0;
        break;
      case "object":
        switch ($.$$typeof) {
          case e:
          case t:
            q = !0;
        }
    }
    if (q) return q = $, ee = ee(q), $ = G === "" ? "." + de(q, 0) : G, L(ee) ? (W = "", $ != null && (W = $.replace(fe, "$&/") + "/"), he(ee, M, W, "", function(Ce) {
      return Ce;
    })) : ee != null && (J(ee) && (ee = H(ee, W + (!ee.key || q && q.key === ee.key ? "" : ("" + ee.key).replace(fe, "$&/") + "/") + $)), M.push(ee)), 1;
    if (q = 0, G = G === "" ? "." : G + ":", L($)) for (var re = 0; re < $.length; re++) {
      Q = $[re];
      var ve = G + de(Q, re);
      q += he(Q, M, W, ve, ee);
    }
    else if (ve = g($), typeof ve == "function") for ($ = ve.call($), re = 0; !(Q = $.next()).done; ) Q = Q.value, ve = G + de(Q, re++), q += he(Q, M, W, ve, ee);
    else if (Q === "object") throw M = String($), Error("Objects are not valid as a React child (found: " + (M === "[object Object]" ? "object with keys {" + Object.keys($).join(", ") + "}" : M) + "). If you meant to render a collection of children, use an array instead.");
    return q;
  }
  function le($, M, W) {
    if ($ == null) return $;
    var G = [], ee = 0;
    return he($, G, "", "", function(Q) {
      return M.call(W, Q, ee++);
    }), G;
  }
  function Y($) {
    if ($._status === -1) {
      var M = $._result;
      M = M(), M.then(function(W) {
        ($._status === 0 || $._status === -1) && ($._status = 1, $._result = W);
      }, function(W) {
        ($._status === 0 || $._status === -1) && ($._status = 2, $._result = W);
      }), $._status === -1 && ($._status = 0, $._result = M);
    }
    if ($._status === 1) return $._result.default;
    throw $._result;
  }
  var te = { current: null }, S = { transition: null }, T = { ReactCurrentDispatcher: te, ReactCurrentBatchConfig: S, ReactCurrentOwner: O };
  function P() {
    throw Error("act(...) is not supported in production builds of React.");
  }
  return Fe.Children = { map: le, forEach: function($, M, W) {
    le($, function() {
      M.apply(this, arguments);
    }, W);
  }, count: function($) {
    var M = 0;
    return le($, function() {
      M++;
    }), M;
  }, toArray: function($) {
    return le($, function(M) {
      return M;
    }) || [];
  }, only: function($) {
    if (!J($)) throw Error("React.Children.only expected to receive a single React element child.");
    return $;
  } }, Fe.Component = A, Fe.Fragment = n, Fe.Profiler = i, Fe.PureComponent = R, Fe.StrictMode = r, Fe.Suspense = d, Fe.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = T, Fe.act = P, Fe.cloneElement = function($, M, W) {
    if ($ == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + $ + ".");
    var G = E({}, $.props), ee = $.key, Q = $.ref, q = $._owner;
    if (M != null) {
      if (M.ref !== void 0 && (Q = M.ref, q = O.current), M.key !== void 0 && (ee = "" + M.key), $.type && $.type.defaultProps) var re = $.type.defaultProps;
      for (ve in M) V.call(M, ve) && !D.hasOwnProperty(ve) && (G[ve] = M[ve] === void 0 && re !== void 0 ? re[ve] : M[ve]);
    }
    var ve = arguments.length - 2;
    if (ve === 1) G.children = W;
    else if (1 < ve) {
      re = Array(ve);
      for (var Ce = 0; Ce < ve; Ce++) re[Ce] = arguments[Ce + 2];
      G.children = re;
    }
    return { $$typeof: e, type: $.type, key: ee, ref: Q, props: G, _owner: q };
  }, Fe.createContext = function($) {
    return $ = { $$typeof: l, _currentValue: $, _currentValue2: $, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, $.Provider = { $$typeof: s, _context: $ }, $.Consumer = $;
  }, Fe.createElement = B, Fe.createFactory = function($) {
    var M = B.bind(null, $);
    return M.type = $, M;
  }, Fe.createRef = function() {
    return { current: null };
  }, Fe.forwardRef = function($) {
    return { $$typeof: u, render: $ };
  }, Fe.isValidElement = J, Fe.lazy = function($) {
    return { $$typeof: f, _payload: { _status: -1, _result: $ }, _init: Y };
  }, Fe.memo = function($, M) {
    return { $$typeof: h, type: $, compare: M === void 0 ? null : M };
  }, Fe.startTransition = function($) {
    var M = S.transition;
    S.transition = {};
    try {
      $();
    } finally {
      S.transition = M;
    }
  }, Fe.unstable_act = P, Fe.useCallback = function($, M) {
    return te.current.useCallback($, M);
  }, Fe.useContext = function($) {
    return te.current.useContext($);
  }, Fe.useDebugValue = function() {
  }, Fe.useDeferredValue = function($) {
    return te.current.useDeferredValue($);
  }, Fe.useEffect = function($, M) {
    return te.current.useEffect($, M);
  }, Fe.useId = function() {
    return te.current.useId();
  }, Fe.useImperativeHandle = function($, M, W) {
    return te.current.useImperativeHandle($, M, W);
  }, Fe.useInsertionEffect = function($, M) {
    return te.current.useInsertionEffect($, M);
  }, Fe.useLayoutEffect = function($, M) {
    return te.current.useLayoutEffect($, M);
  }, Fe.useMemo = function($, M) {
    return te.current.useMemo($, M);
  }, Fe.useReducer = function($, M, W) {
    return te.current.useReducer($, M, W);
  }, Fe.useRef = function($) {
    return te.current.useRef($);
  }, Fe.useState = function($) {
    return te.current.useState($);
  }, Fe.useSyncExternalStore = function($, M, W) {
    return te.current.useSyncExternalStore($, M, W);
  }, Fe.useTransition = function() {
    return te.current.useTransition();
  }, Fe.version = "18.3.1", Fe;
}
var JC;
function iu() {
  return JC || (JC = 1, Np.exports = QM()), Np.exports;
}
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var eE;
function JM() {
  if (eE) return cl;
  eE = 1;
  var e = iu(), t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, i = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, s = { key: !0, ref: !0, __self: !0, __source: !0 };
  function l(u, d, h) {
    var f, m = {}, g = null, w = null;
    h !== void 0 && (g = "" + h), d.key !== void 0 && (g = "" + d.key), d.ref !== void 0 && (w = d.ref);
    for (f in d) r.call(d, f) && !s.hasOwnProperty(f) && (m[f] = d[f]);
    if (u && u.defaultProps) for (f in d = u.defaultProps, d) m[f] === void 0 && (m[f] = d[f]);
    return { $$typeof: t, type: u, key: g, ref: w, props: m, _owner: i.current };
  }
  return cl.Fragment = n, cl.jsx = l, cl.jsxs = l, cl;
}
var tE;
function eO() {
  return tE || (tE = 1, Bp.exports = JM()), Bp.exports;
}
var I = eO(), C = iu();
const j = /* @__PURE__ */ ru(C), Dv = /* @__PURE__ */ ZM({
  __proto__: null,
  default: j
}, [C]), tO = {
  translations: {
    archiveNotification: "Archive this notification",
    archiveRead: "Archive Read",
    markAllAsRead: "Mark all as read",
    notifications: "Notifications",
    emptyFeedTitle: "No notifications yet",
    emptyFeedBody: "We'll let you know when we've got something new for you.",
    all: "All",
    unread: "Unread",
    read: "Read",
    unseen: "Unseen",
    msTeamsChannelSetError: "Error setting channel.",
    msTeamsConnect: "Connect to Microsoft Teams",
    msTeamsConnected: "Connected",
    msTeamsConnecting: "Connecting to Microsoft Teams…",
    msTeamsConnectionErrorExists: "Try reconnecting to Microsoft Teams to find and select channels from your teams.",
    msTeamsConnectionErrorOccurred: "There was an error connecting to Microsoft Teams. Try reconnecting to find and select channels from your teams.",
    msTeamsConnectContainerDescription: "Connect to get notifications in Microsoft Teams",
    msTeamsDisconnect: "Disconnect",
    msTeamsDisconnecting: "Disconnecting from Microsoft Teams…",
    msTeamsError: "Error",
    msTeamsReconnect: "Reconnect",
    msTeamsTenantIdNotSet: "Microsoft Teams tenant ID not set.",
    slackConnectChannel: "Connect channel",
    slackChannelId: "Slack channel ID",
    slackConnecting: "Connecting to Slack...",
    slackDisconnecting: "Disconnecting...",
    slackConnect: "Connect to Slack",
    slackConnected: "Connected",
    slackConnectContainerDescription: "Connect to get notifications in your Slack workspace.",
    slackSearchbarDisconnected: "Slack is not connected.",
    slackSearchbarNoChannelsConnected: "Search channels",
    slackSearchbarNoChannelsFound: "No slack channels.",
    slackSearchbarChannelsError: "Error fetching channels.",
    slackSearchChannels: "Search channels",
    slackConnectionErrorExists: "Try reconnecting to Slack to find and select channels from your workspace.",
    slackConnectionErrorOccurred: "There was an error connecting to Slack. Try reconnecting to find and select channels from your workspace.",
    slackChannelAlreadyConnected: "Error: already connected",
    slackError: "Error",
    slackDisconnect: "Disconnect",
    slackChannelSetError: "Error setting channel.",
    slackAccessTokenNotSet: "Access token not set.",
    slackReconnect: "Reconnect"
  },
  locale: "en"
}, jv = {
  en: tO
}, nk = j.createContext(jv.en), nO = ({
  i18n: e = jv.en,
  ...t
}) => /* @__PURE__ */ j.createElement(nk.Provider, { ...t, value: e });
var Dp = { exports: {} };
/*!
 * EventEmitter2
 * https://github.com/hij1nx/EventEmitter2
 *
 * Copyright (c) 2013 hij1nx
 * Licensed under the MIT license.
 */
var nE;
function rO() {
  return nE || (nE = 1, (function(e, t) {
    (function(n) {
      var r = Object.hasOwnProperty, i = Array.isArray ? Array.isArray : function(T) {
        return Object.prototype.toString.call(T) === "[object Array]";
      }, s = 10, l = typeof process == "object" && typeof process.nextTick == "function", u = typeof Symbol == "function", d = typeof Reflect == "object", h = typeof setImmediate == "function", f = h ? setImmediate : setTimeout, m = u ? d && typeof Reflect.ownKeys == "function" ? Reflect.ownKeys : function(S) {
        var T = Object.getOwnPropertyNames(S);
        return T.push.apply(T, Object.getOwnPropertySymbols(S)), T;
      } : Object.keys;
      function g() {
        this._events = {}, this._conf && w.call(this, this._conf);
      }
      function w(S) {
        S && (this._conf = S, S.delimiter && (this.delimiter = S.delimiter), S.maxListeners !== n && (this._maxListeners = S.maxListeners), S.wildcard && (this.wildcard = S.wildcard), S.newListener && (this._newListener = S.newListener), S.removeListener && (this._removeListener = S.removeListener), S.verboseMemoryLeak && (this.verboseMemoryLeak = S.verboseMemoryLeak), S.ignoreErrors && (this.ignoreErrors = S.ignoreErrors), this.wildcard && (this.listenerTree = {}));
      }
      function E(S, T) {
        var P = "(node) warning: possible EventEmitter memory leak detected. " + S + " listeners added. Use emitter.setMaxListeners() to increase limit.";
        if (this.verboseMemoryLeak && (P += " Event name: " + T + "."), typeof process < "u" && process.emitWarning) {
          var $ = new Error(P);
          $.name = "MaxListenersExceededWarning", $.emitter = this, $.count = S, process.emitWarning($);
        } else
          console.error(P), console.trace && console.trace();
      }
      var b = function(S, T, P) {
        var $ = arguments.length;
        switch ($) {
          case 0:
            return [];
          case 1:
            return [S];
          case 2:
            return [S, T];
          case 3:
            return [S, T, P];
          default:
            for (var M = new Array($); $--; )
              M[$] = arguments[$];
            return M;
        }
      };
      function A(S, T) {
        for (var P = {}, $, M = S.length, W = 0, G = 0; G < M; G++)
          $ = S[G], P[$] = G < W ? T[G] : n;
        return P;
      }
      function x(S, T, P) {
        this._emitter = S, this._target = T, this._listeners = {}, this._listenersCount = 0;
        var $, M;
        if ((P.on || P.off) && ($ = P.on, M = P.off), T.addEventListener ? ($ = T.addEventListener, M = T.removeEventListener) : T.addListener ? ($ = T.addListener, M = T.removeListener) : T.on && ($ = T.on, M = T.off), !$ && !M)
          throw Error("target does not implement any known event API");
        if (typeof $ != "function")
          throw TypeError("on method must be a function");
        if (typeof M != "function")
          throw TypeError("off method must be a function");
        this._on = $, this._off = M;
        var W = S._observers;
        W ? W.push(this) : S._observers = [this];
      }
      Object.assign(x.prototype, {
        subscribe: function(S, T, P) {
          var $ = this, M = this._target, W = this._emitter, G = this._listeners, ee = function() {
            var Q = b.apply(null, arguments), q = {
              data: Q,
              name: T,
              original: S
            };
            if (P) {
              var re = P.call(M, q);
              re !== !1 && W.emit.apply(W, [q.name].concat(Q));
              return;
            }
            W.emit.apply(W, [T].concat(Q));
          };
          if (G[S])
            throw Error("Event '" + S + "' is already listening");
          this._listenersCount++, W._newListener && W._removeListener && !$._onNewListener ? (this._onNewListener = function(Q) {
            Q === T && G[S] === null && (G[S] = ee, $._on.call(M, S, ee));
          }, W.on("newListener", this._onNewListener), this._onRemoveListener = function(Q) {
            Q === T && !W.hasListeners(Q) && G[S] && (G[S] = null, $._off.call(M, S, ee));
          }, G[S] = null, W.on("removeListener", this._onRemoveListener)) : (G[S] = ee, $._on.call(M, S, ee));
        },
        unsubscribe: function(S) {
          var T = this, P = this._listeners, $ = this._emitter, M, W, G = this._off, ee = this._target, Q;
          if (S && typeof S != "string")
            throw TypeError("event must be a string");
          function q() {
            T._onNewListener && ($.off("newListener", T._onNewListener), $.off("removeListener", T._onRemoveListener), T._onNewListener = null, T._onRemoveListener = null);
            var re = B.call($, T);
            $._observers.splice(re, 1);
          }
          if (S) {
            if (M = P[S], !M) return;
            G.call(ee, S, M), delete P[S], --this._listenersCount || q();
          } else {
            for (W = m(P), Q = W.length; Q-- > 0; )
              S = W[Q], G.call(ee, S, P[S]);
            this._listeners = {}, this._listenersCount = 0, q();
          }
        }
      });
      function R(S, T, P, $) {
        var M = Object.assign({}, T);
        if (!S) return M;
        if (typeof S != "object")
          throw TypeError("options must be an object");
        var W = Object.keys(S), G = W.length, ee, Q, q;
        function re(Ce) {
          throw Error('Invalid "' + ee + '" option value' + (Ce ? ". Reason: " + Ce : ""));
        }
        for (var ve = 0; ve < G; ve++) {
          if (ee = W[ve], !r.call(T, ee))
            throw Error('Unknown "' + ee + '" option');
          Q = S[ee], Q !== n && (q = P[ee], M[ee] = q ? q(Q, re) : Q);
        }
        return M;
      }
      function _(S, T) {
        return (typeof S != "function" || !S.hasOwnProperty("prototype")) && T("value must be a constructor"), S;
      }
      function L(S) {
        var T = "value must be type of " + S.join("|"), P = S.length, $ = S[0], M = S[1];
        return P === 1 ? function(W, G) {
          if (typeof W === $)
            return W;
          G(T);
        } : P === 2 ? function(W, G) {
          var ee = typeof W;
          if (ee === $ || ee === M) return W;
          G(T);
        } : function(W, G) {
          for (var ee = typeof W, Q = P; Q-- > 0; )
            if (ee === S[Q]) return W;
          G(T);
        };
      }
      var V = L(["function"]), O = L(["object", "function"]);
      function D(S, T, P) {
        var $, M, W = 0, G, ee = new S(function(Q, q, re) {
          P = R(P, {
            timeout: 0,
            overload: !1
          }, {
            timeout: function(ze, He) {
              return ze *= 1, (typeof ze != "number" || ze < 0 || !Number.isFinite(ze)) && He("timeout must be a positive number"), ze;
            }
          }), $ = !P.overload && typeof S.prototype.cancel == "function" && typeof re == "function";
          function ve() {
            M && (M = null), W && (clearTimeout(W), W = 0);
          }
          var Ce = function(ze) {
            ve(), Q(ze);
          }, Ie = function(ze) {
            ve(), q(ze);
          };
          $ ? T(Ce, Ie, re) : (M = [function(ze) {
            Ie(ze || Error("canceled"));
          }], T(Ce, Ie, function(ze) {
            if (G)
              throw Error("Unable to subscribe on cancel event asynchronously");
            if (typeof ze != "function")
              throw TypeError("onCancel callback must be a function");
            M.push(ze);
          }), G = !0), P.timeout > 0 && (W = setTimeout(function() {
            var ze = Error("timeout");
            ze.code = "ETIMEDOUT", W = 0, ee.cancel(ze), q(ze);
          }, P.timeout));
        });
        return $ || (ee.cancel = function(Q) {
          if (M) {
            for (var q = M.length, re = 1; re < q; re++)
              M[re](Q);
            M[0](Q), M = null;
          }
        }), ee;
      }
      function B(S) {
        var T = this._observers;
        if (!T)
          return -1;
        for (var P = T.length, $ = 0; $ < P; $++)
          if (T[$]._target === S) return $;
        return -1;
      }
      function H(S, T, P, $, M) {
        if (!P)
          return null;
        if ($ === 0) {
          var W = typeof T;
          if (W === "string") {
            var G, ee, Q = 0, q = 0, re = this.delimiter, ve = re.length;
            if ((ee = T.indexOf(re)) !== -1) {
              G = new Array(5);
              do
                G[Q++] = T.slice(q, ee), q = ee + ve;
              while ((ee = T.indexOf(re, q)) !== -1);
              G[Q++] = T.slice(q), T = G, M = Q;
            } else
              T = [T], M = 1;
          } else W === "object" ? M = T.length : (T = [T], M = 1);
        }
        var Ce = null, Ie, ze, He, pn, Zn, tn = T[$], mn = T[$ + 1], Tt, Ye;
        if ($ === M)
          P._listeners && (typeof P._listeners == "function" ? (S && S.push(P._listeners), Ce = [P]) : (S && S.push.apply(S, P._listeners), Ce = [P]));
        else if (tn === "*") {
          for (Tt = m(P), ee = Tt.length; ee-- > 0; )
            Ie = Tt[ee], Ie !== "_listeners" && (Ye = H(S, T, P[Ie], $ + 1, M), Ye && (Ce ? Ce.push.apply(Ce, Ye) : Ce = Ye));
          return Ce;
        } else if (tn === "**") {
          for (Zn = $ + 1 === M || $ + 2 === M && mn === "*", Zn && P._listeners && (Ce = H(S, T, P, M, M)), Tt = m(P), ee = Tt.length; ee-- > 0; )
            Ie = Tt[ee], Ie !== "_listeners" && (Ie === "*" || Ie === "**" ? (P[Ie]._listeners && !Zn && (Ye = H(S, T, P[Ie], M, M), Ye && (Ce ? Ce.push.apply(Ce, Ye) : Ce = Ye)), Ye = H(S, T, P[Ie], $, M)) : Ie === mn ? Ye = H(S, T, P[Ie], $ + 2, M) : Ye = H(S, T, P[Ie], $, M), Ye && (Ce ? Ce.push.apply(Ce, Ye) : Ce = Ye));
          return Ce;
        } else P[tn] && (Ce = H(S, T, P[tn], $ + 1, M));
        if (ze = P["*"], ze && H(S, T, ze, $ + 1, M), He = P["**"], He)
          if ($ < M)
            for (He._listeners && H(S, T, He, M, M), Tt = m(He), ee = Tt.length; ee-- > 0; )
              Ie = Tt[ee], Ie !== "_listeners" && (Ie === mn ? H(S, T, He[Ie], $ + 2, M) : Ie === tn ? H(S, T, He[Ie], $ + 1, M) : (pn = {}, pn[Ie] = He[Ie], H(S, T, { "**": pn }, $ + 1, M)));
          else He._listeners ? H(S, T, He, M, M) : He["*"] && He["*"]._listeners && H(S, T, He["*"], M, M);
        return Ce;
      }
      function J(S, T, P) {
        var $ = 0, M = 0, W, G = this.delimiter, ee = G.length, Q;
        if (typeof S == "string")
          if ((W = S.indexOf(G)) !== -1) {
            Q = new Array(5);
            do
              Q[$++] = S.slice(M, W), M = W + ee;
            while ((W = S.indexOf(G, M)) !== -1);
            Q[$++] = S.slice(M);
          } else
            Q = [S], $ = 1;
        else
          Q = S, $ = S.length;
        if ($ > 1) {
          for (W = 0; W + 1 < $; W++)
            if (Q[W] === "**" && Q[W + 1] === "**")
              return;
        }
        var q = this.listenerTree, re;
        for (W = 0; W < $; W++)
          if (re = Q[W], q = q[re] || (q[re] = {}), W === $ - 1)
            return q._listeners ? (typeof q._listeners == "function" && (q._listeners = [q._listeners]), P ? q._listeners.unshift(T) : q._listeners.push(T), !q._listeners.warned && this._maxListeners > 0 && q._listeners.length > this._maxListeners && (q._listeners.warned = !0, E.call(this, q._listeners.length, re))) : q._listeners = T, !0;
        return !0;
      }
      function ce(S, T, P, $) {
        for (var M = m(S), W = M.length, G, ee, Q, q = S._listeners, re; W-- > 0; )
          ee = M[W], G = S[ee], ee === "_listeners" ? Q = P : Q = P ? P.concat(ee) : [ee], re = $ || typeof ee == "symbol", q && T.push(re ? Q : Q.join(this.delimiter)), typeof G == "object" && ce.call(this, G, T, Q, re);
        return T;
      }
      function fe(S) {
        for (var T = m(S), P = T.length, $, M, W; P-- > 0; )
          M = T[P], $ = S[M], $ && (W = !0, M !== "_listeners" && !fe($) && delete S[M]);
        return W;
      }
      function de(S, T, P) {
        this.emitter = S, this.event = T, this.listener = P;
      }
      de.prototype.off = function() {
        return this.emitter.off(this.event, this.listener), this;
      };
      function he(S, T, P) {
        if (P === !0)
          M = !0;
        else if (P === !1)
          $ = !0;
        else {
          if (!P || typeof P != "object")
            throw TypeError("options should be an object or true");
          var $ = P.async, M = P.promisify, W = P.nextTick, G = P.objectify;
        }
        if ($ || W || M) {
          var ee = T, Q = T._origin || T;
          if (W && !l)
            throw Error("process.nextTick is not supported");
          M === n && (M = T.constructor.name === "AsyncFunction"), T = function() {
            var q = arguments, re = this, ve = this.event;
            return M ? W ? Promise.resolve() : new Promise(function(Ce) {
              f(Ce);
            }).then(function() {
              return re.event = ve, ee.apply(re, q);
            }) : (W ? process.nextTick : f)(function() {
              re.event = ve, ee.apply(re, q);
            });
          }, T._async = !0, T._origin = Q;
        }
        return [T, G ? new de(this, S, T) : this];
      }
      function le(S) {
        this._events = {}, this._newListener = !1, this._removeListener = !1, this.verboseMemoryLeak = !1, w.call(this, S);
      }
      le.EventEmitter2 = le, le.prototype.listenTo = function(S, T, P) {
        if (typeof S != "object")
          throw TypeError("target musts be an object");
        var $ = this;
        P = R(P, {
          on: n,
          off: n,
          reducers: n
        }, {
          on: V,
          off: V,
          reducers: O
        });
        function M(W) {
          if (typeof W != "object")
            throw TypeError("events must be an object");
          var G = P.reducers, ee = B.call($, S), Q;
          ee === -1 ? Q = new x($, S, P) : Q = $._observers[ee];
          for (var q = m(W), re = q.length, ve, Ce = typeof G == "function", Ie = 0; Ie < re; Ie++)
            ve = q[Ie], Q.subscribe(
              ve,
              W[ve] || ve,
              Ce ? G : G && G[ve]
            );
        }
        return i(T) ? M(A(T)) : M(typeof T == "string" ? A(T.split(/\s+/)) : T), this;
      }, le.prototype.stopListeningTo = function(S, T) {
        var P = this._observers;
        if (!P)
          return !1;
        var $ = P.length, M, W = !1;
        if (S && typeof S != "object")
          throw TypeError("target should be an object");
        for (; $-- > 0; )
          M = P[$], (!S || M._target === S) && (M.unsubscribe(T), W = !0);
        return W;
      }, le.prototype.delimiter = ".", le.prototype.setMaxListeners = function(S) {
        S !== n && (this._maxListeners = S, this._conf || (this._conf = {}), this._conf.maxListeners = S);
      }, le.prototype.getMaxListeners = function() {
        return this._maxListeners;
      }, le.prototype.event = "", le.prototype.once = function(S, T, P) {
        return this._once(S, T, !1, P);
      }, le.prototype.prependOnceListener = function(S, T, P) {
        return this._once(S, T, !0, P);
      }, le.prototype._once = function(S, T, P, $) {
        return this._many(S, 1, T, P, $);
      }, le.prototype.many = function(S, T, P, $) {
        return this._many(S, T, P, !1, $);
      }, le.prototype.prependMany = function(S, T, P, $) {
        return this._many(S, T, P, !0, $);
      }, le.prototype._many = function(S, T, P, $, M) {
        var W = this;
        if (typeof P != "function")
          throw new Error("many only accepts instances of Function");
        function G() {
          return --T === 0 && W.off(S, G), P.apply(this, arguments);
        }
        return G._origin = P, this._on(S, G, $, M);
      }, le.prototype.emit = function() {
        if (!this._events && !this._all)
          return !1;
        this._events || g.call(this);
        var S = arguments[0], T, P = this.wildcard, $, M, W, G, ee;
        if (S === "newListener" && !this._newListener && !this._events.newListener)
          return !1;
        if (P && (T = S, S !== "newListener" && S !== "removeListener" && typeof S == "object")) {
          if (M = S.length, u) {
            for (W = 0; W < M; W++)
              if (typeof S[W] == "symbol") {
                ee = !0;
                break;
              }
          }
          ee || (S = S.join(this.delimiter));
        }
        var Q = arguments.length, q;
        if (this._all && this._all.length)
          for (q = this._all.slice(), W = 0, M = q.length; W < M; W++)
            switch (this.event = S, Q) {
              case 1:
                q[W].call(this, S);
                break;
              case 2:
                q[W].call(this, S, arguments[1]);
                break;
              case 3:
                q[W].call(this, S, arguments[1], arguments[2]);
                break;
              default:
                q[W].apply(this, arguments);
            }
        if (P)
          q = [], H.call(this, q, T, this.listenerTree, 0, M);
        else if (q = this._events[S], typeof q == "function") {
          switch (this.event = S, Q) {
            case 1:
              q.call(this);
              break;
            case 2:
              q.call(this, arguments[1]);
              break;
            case 3:
              q.call(this, arguments[1], arguments[2]);
              break;
            default:
              for ($ = new Array(Q - 1), G = 1; G < Q; G++) $[G - 1] = arguments[G];
              q.apply(this, $);
          }
          return !0;
        } else q && (q = q.slice());
        if (q && q.length) {
          if (Q > 3)
            for ($ = new Array(Q - 1), G = 1; G < Q; G++) $[G - 1] = arguments[G];
          for (W = 0, M = q.length; W < M; W++)
            switch (this.event = S, Q) {
              case 1:
                q[W].call(this);
                break;
              case 2:
                q[W].call(this, arguments[1]);
                break;
              case 3:
                q[W].call(this, arguments[1], arguments[2]);
                break;
              default:
                q[W].apply(this, $);
            }
          return !0;
        } else if (!this.ignoreErrors && !this._all && S === "error")
          throw arguments[1] instanceof Error ? arguments[1] : new Error("Uncaught, unspecified 'error' event.");
        return !!this._all;
      }, le.prototype.emitAsync = function() {
        if (!this._events && !this._all)
          return !1;
        this._events || g.call(this);
        var S = arguments[0], T = this.wildcard, P, $, M, W, G, ee;
        if (S === "newListener" && !this._newListener && !this._events.newListener)
          return Promise.resolve([!1]);
        if (T && (P = S, S !== "newListener" && S !== "removeListener" && typeof S == "object")) {
          if (W = S.length, u) {
            for (G = 0; G < W; G++)
              if (typeof S[G] == "symbol") {
                $ = !0;
                break;
              }
          }
          $ || (S = S.join(this.delimiter));
        }
        var Q = [], q = arguments.length, re;
        if (this._all)
          for (G = 0, W = this._all.length; G < W; G++)
            switch (this.event = S, q) {
              case 1:
                Q.push(this._all[G].call(this, S));
                break;
              case 2:
                Q.push(this._all[G].call(this, S, arguments[1]));
                break;
              case 3:
                Q.push(this._all[G].call(this, S, arguments[1], arguments[2]));
                break;
              default:
                Q.push(this._all[G].apply(this, arguments));
            }
        if (T ? (re = [], H.call(this, re, P, this.listenerTree, 0)) : re = this._events[S], typeof re == "function")
          switch (this.event = S, q) {
            case 1:
              Q.push(re.call(this));
              break;
            case 2:
              Q.push(re.call(this, arguments[1]));
              break;
            case 3:
              Q.push(re.call(this, arguments[1], arguments[2]));
              break;
            default:
              for (M = new Array(q - 1), ee = 1; ee < q; ee++) M[ee - 1] = arguments[ee];
              Q.push(re.apply(this, M));
          }
        else if (re && re.length) {
          if (re = re.slice(), q > 3)
            for (M = new Array(q - 1), ee = 1; ee < q; ee++) M[ee - 1] = arguments[ee];
          for (G = 0, W = re.length; G < W; G++)
            switch (this.event = S, q) {
              case 1:
                Q.push(re[G].call(this));
                break;
              case 2:
                Q.push(re[G].call(this, arguments[1]));
                break;
              case 3:
                Q.push(re[G].call(this, arguments[1], arguments[2]));
                break;
              default:
                Q.push(re[G].apply(this, M));
            }
        } else if (!this.ignoreErrors && !this._all && S === "error")
          return arguments[1] instanceof Error ? Promise.reject(arguments[1]) : Promise.reject("Uncaught, unspecified 'error' event.");
        return Promise.all(Q);
      }, le.prototype.on = function(S, T, P) {
        return this._on(S, T, !1, P);
      }, le.prototype.prependListener = function(S, T, P) {
        return this._on(S, T, !0, P);
      }, le.prototype.onAny = function(S) {
        return this._onAny(S, !1);
      }, le.prototype.prependAny = function(S) {
        return this._onAny(S, !0);
      }, le.prototype.addListener = le.prototype.on, le.prototype._onAny = function(S, T) {
        if (typeof S != "function")
          throw new Error("onAny only accepts instances of Function");
        return this._all || (this._all = []), T ? this._all.unshift(S) : this._all.push(S), this;
      }, le.prototype._on = function(S, T, P, $) {
        if (typeof S == "function")
          return this._onAny(S, T), this;
        if (typeof T != "function")
          throw new Error("on only accepts instances of Function");
        this._events || g.call(this);
        var M = this, W;
        return $ !== n && (W = he.call(this, S, T, $), T = W[0], M = W[1]), this._newListener && this.emit("newListener", S, T), this.wildcard ? (J.call(this, S, T, P), M) : (this._events[S] ? (typeof this._events[S] == "function" && (this._events[S] = [this._events[S]]), P ? this._events[S].unshift(T) : this._events[S].push(T), !this._events[S].warned && this._maxListeners > 0 && this._events[S].length > this._maxListeners && (this._events[S].warned = !0, E.call(this, this._events[S].length, S))) : this._events[S] = T, M);
      }, le.prototype.off = function(S, T) {
        if (typeof T != "function")
          throw new Error("removeListener only takes instances of Function");
        var P, $ = [];
        if (this.wildcard) {
          var M = typeof S == "string" ? S.split(this.delimiter) : S.slice();
          if ($ = H.call(this, null, M, this.listenerTree, 0), !$) return this;
        } else {
          if (!this._events[S]) return this;
          P = this._events[S], $.push({ _listeners: P });
        }
        for (var W = 0; W < $.length; W++) {
          var G = $[W];
          if (P = G._listeners, i(P)) {
            for (var ee = -1, Q = 0, q = P.length; Q < q; Q++)
              if (P[Q] === T || P[Q].listener && P[Q].listener === T || P[Q]._origin && P[Q]._origin === T) {
                ee = Q;
                break;
              }
            if (ee < 0)
              continue;
            return this.wildcard ? G._listeners.splice(ee, 1) : this._events[S].splice(ee, 1), P.length === 0 && (this.wildcard ? delete G._listeners : delete this._events[S]), this._removeListener && this.emit("removeListener", S, T), this;
          } else (P === T || P.listener && P.listener === T || P._origin && P._origin === T) && (this.wildcard ? delete G._listeners : delete this._events[S], this._removeListener && this.emit("removeListener", S, T));
        }
        return this.listenerTree && fe(this.listenerTree), this;
      }, le.prototype.offAny = function(S) {
        var T = 0, P = 0, $;
        if (S && this._all && this._all.length > 0) {
          for ($ = this._all, T = 0, P = $.length; T < P; T++)
            if (S === $[T])
              return $.splice(T, 1), this._removeListener && this.emit("removeListenerAny", S), this;
        } else {
          if ($ = this._all, this._removeListener)
            for (T = 0, P = $.length; T < P; T++)
              this.emit("removeListenerAny", $[T]);
          this._all = [];
        }
        return this;
      }, le.prototype.removeListener = le.prototype.off, le.prototype.removeAllListeners = function(S) {
        if (S === n)
          return !this._events || g.call(this), this;
        if (this.wildcard) {
          var T = H.call(this, null, S, this.listenerTree, 0), P, $;
          if (!T) return this;
          for ($ = 0; $ < T.length; $++)
            P = T[$], P._listeners = null;
          this.listenerTree && fe(this.listenerTree);
        } else this._events && (this._events[S] = null);
        return this;
      }, le.prototype.listeners = function(S) {
        var T = this._events, P, $, M, W, G;
        if (S === n) {
          if (this.wildcard)
            throw Error("event name required for wildcard emitter");
          if (!T)
            return [];
          for (P = m(T), W = P.length, M = []; W-- > 0; )
            $ = T[P[W]], typeof $ == "function" ? M.push($) : M.push.apply(M, $);
          return M;
        } else {
          if (this.wildcard) {
            if (G = this.listenerTree, !G) return [];
            var ee = [], Q = typeof S == "string" ? S.split(this.delimiter) : S.slice();
            return H.call(this, ee, Q, G, 0), ee;
          }
          return T ? ($ = T[S], $ ? typeof $ == "function" ? [$] : $ : []) : [];
        }
      }, le.prototype.eventNames = function(S) {
        var T = this._events;
        return this.wildcard ? ce.call(this, this.listenerTree, [], null, S) : T ? m(T) : [];
      }, le.prototype.listenerCount = function(S) {
        return this.listeners(S).length;
      }, le.prototype.hasListeners = function(S) {
        if (this.wildcard) {
          var T = [], P = typeof S == "string" ? S.split(this.delimiter) : S.slice();
          return H.call(this, T, P, this.listenerTree, 0), T.length > 0;
        }
        var $ = this._events, M = this._all;
        return !!(M && M.length || $ && (S === n ? m($).length : $[S]));
      }, le.prototype.listenersAny = function() {
        return this._all ? this._all : [];
      }, le.prototype.waitFor = function(S, T) {
        var P = this, $ = typeof T;
        return $ === "number" ? T = { timeout: T } : $ === "function" && (T = { filter: T }), T = R(T, {
          timeout: 0,
          filter: n,
          handleError: !1,
          Promise,
          overload: !1
        }, {
          filter: V,
          Promise: _
        }), D(T.Promise, function(M, W, G) {
          function ee() {
            var Q = T.filter;
            if (!(Q && !Q.apply(P, arguments)))
              if (P.off(S, ee), T.handleError) {
                var q = arguments[0];
                q ? W(q) : M(b.apply(null, arguments).slice(1));
              } else
                M(b.apply(null, arguments));
          }
          G(function() {
            P.off(S, ee);
          }), P._on(S, ee, !1);
        }, {
          timeout: T.timeout,
          overload: T.overload
        });
      };
      function Y(S, T, P) {
        P = R(P, {
          Promise,
          timeout: 0,
          overload: !1
        }, {
          Promise: _
        });
        var $ = P.Promise;
        return D($, function(M, W, G) {
          var ee;
          if (typeof S.addEventListener == "function") {
            ee = function() {
              M(b.apply(null, arguments));
            }, G(function() {
              S.removeEventListener(T, ee);
            }), S.addEventListener(
              T,
              ee,
              { once: !0 }
            );
            return;
          }
          var Q = function() {
            q && S.removeListener("error", q), M(b.apply(null, arguments));
          }, q;
          T !== "error" && (q = function(re) {
            S.removeListener(T, Q), W(re);
          }, S.once("error", q)), G(function() {
            q && S.removeListener("error", q), S.removeListener(T, Q);
          }), S.once(T, Q);
        }, {
          timeout: P.timeout,
          overload: P.overload
        });
      }
      var te = le.prototype;
      Object.defineProperties(le, {
        defaultMaxListeners: {
          get: function() {
            return te._maxListeners;
          },
          set: function(S) {
            if (typeof S != "number" || S < 0 || Number.isNaN(S))
              throw TypeError("n must be a non-negative number");
            te._maxListeners = S;
          },
          enumerable: !0
        },
        once: {
          value: Y,
          writable: !0,
          configurable: !0
        }
      }), Object.defineProperties(te, {
        _maxListeners: {
          value: s,
          writable: !0,
          configurable: !0
        },
        _observers: { value: null, writable: !0, configurable: !0 }
      }), e.exports = le;
    })();
  })(Dp)), Dp.exports;
}
var iO = rO();
const oO = /* @__PURE__ */ ru(iO);
let sO = (e = 21) => crypto.getRandomValues(new Uint8Array(e)).reduce((t, n) => (n &= 63, n < 36 ? t += n.toString(36) : n < 62 ? t += (n - 26).toString(36).toUpperCase() : n > 62 ? t += "-" : t += "_", t), "");
const aO = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/;
function lO(e) {
  return aO.test(e);
}
var vi = /* @__PURE__ */ ((e) => (e.loading = "loading", e.fetchMore = "fetchMore", e.ready = "ready", e.error = "error", e))(vi || {});
function uO(e) {
  return [
    "loading",
    "fetchMore"
    /* fetchMore */
  ].includes(
    e
  );
}
const fs = /* @__PURE__ */ new WeakMap(), id = /* @__PURE__ */ new WeakMap(), Sd = {
  current: []
};
let jp = !1;
const Bc = /* @__PURE__ */ new Set(), rE = /* @__PURE__ */ new Map();
function rk(e) {
  const t = Array.from(e).sort((n, r) => n instanceof hs && n.options.deps.includes(r) ? 1 : r instanceof hs && r.options.deps.includes(n) ? -1 : 0);
  for (const n of t) {
    if (Sd.current.includes(n))
      continue;
    Sd.current.push(n), n.recompute();
    const r = id.get(n);
    if (r)
      for (const i of r) {
        const s = fs.get(i);
        s && rk(s);
      }
  }
}
function cO(e) {
  const t = {
    prevVal: e.prevState,
    currentVal: e.state
  };
  for (const n of e.listeners)
    n(t);
}
function dO(e) {
  const t = {
    prevVal: e.prevState,
    currentVal: e.state
  };
  for (const n of e.listeners)
    n(t);
}
function fO(e) {
  if (Bc.add(e), !jp)
    try {
      for (jp = !0; Bc.size > 0; ) {
        const t = Array.from(Bc);
        Bc.clear();
        for (const n of t) {
          const r = rE.get(n) ?? n.prevState;
          n.prevState = r, cO(n);
        }
        for (const n of t) {
          const r = fs.get(n);
          r && (Sd.current.push(n), rk(r));
        }
        for (const n of t) {
          const r = fs.get(n);
          if (r)
            for (const i of r)
              dO(i);
        }
      }
    } finally {
      jp = !1, Sd.current = [], rE.clear();
    }
}
function hO(e) {
  return typeof e == "function";
}
class Bl {
  constructor(t, n) {
    this.listeners = /* @__PURE__ */ new Set(), this.subscribe = (r) => {
      var i, s;
      this.listeners.add(r);
      const l = (s = (i = this.options) == null ? void 0 : i.onSubscribe) == null ? void 0 : s.call(i, r, this);
      return () => {
        this.listeners.delete(r), l == null || l();
      };
    }, this.prevState = t, this.state = t, this.options = n;
  }
  setState(t) {
    var n, r, i;
    this.prevState = this.state, (n = this.options) != null && n.updateFn ? this.state = this.options.updateFn(this.prevState)(t) : hO(t) ? this.state = t(this.prevState) : this.state = t, (i = (r = this.options) == null ? void 0 : r.onUpdate) == null || i.call(r), fO(this);
  }
}
class hs {
  constructor(t) {
    this.listeners = /* @__PURE__ */ new Set(), this._subscriptions = [], this.lastSeenDepValues = [], this.getDepVals = () => {
      const n = this.options.deps.length, r = new Array(n), i = new Array(n);
      for (let s = 0; s < n; s++) {
        const l = this.options.deps[s];
        r[s] = l.prevState, i[s] = l.state;
      }
      return this.lastSeenDepValues = i, {
        prevDepVals: r,
        currDepVals: i,
        prevVal: this.prevState ?? void 0
      };
    }, this.recompute = () => {
      var n, r;
      this.prevState = this.state;
      const i = this.getDepVals();
      this.state = this.options.fn(i), (r = (n = this.options).onUpdate) == null || r.call(n);
    }, this.checkIfRecalculationNeededDeeply = () => {
      for (const s of this.options.deps)
        s instanceof hs && s.checkIfRecalculationNeededDeeply();
      let n = !1;
      const r = this.lastSeenDepValues, { currDepVals: i } = this.getDepVals();
      for (let s = 0; s < i.length; s++)
        if (i[s] !== r[s]) {
          n = !0;
          break;
        }
      n && this.recompute();
    }, this.mount = () => (this.registerOnGraph(), this.checkIfRecalculationNeededDeeply(), () => {
      this.unregisterFromGraph();
      for (const n of this._subscriptions)
        n();
    }), this.subscribe = (n) => {
      var r, i;
      this.listeners.add(n);
      const s = (i = (r = this.options).onSubscribe) == null ? void 0 : i.call(r, n, this);
      return () => {
        this.listeners.delete(n), s == null || s();
      };
    }, this.options = t, this.state = t.fn({
      prevDepVals: void 0,
      prevVal: void 0,
      currDepVals: this.getDepVals().currDepVals
    });
  }
  registerOnGraph(t = this.options.deps) {
    for (const n of t)
      if (n instanceof hs)
        n.registerOnGraph(), this.registerOnGraph(n.options.deps);
      else if (n instanceof Bl) {
        let r = fs.get(n);
        r || (r = /* @__PURE__ */ new Set(), fs.set(n, r)), r.add(this);
        let i = id.get(this);
        i || (i = /* @__PURE__ */ new Set(), id.set(this, i)), i.add(n);
      }
  }
  unregisterFromGraph(t = this.options.deps) {
    for (const n of t)
      if (n instanceof hs)
        this.unregisterFromGraph(n.options.deps);
      else if (n instanceof Bl) {
        const r = fs.get(n);
        r && r.delete(this);
        const i = id.get(this);
        i && i.delete(n);
      }
  }
}
var pO = Object.defineProperty, mO = (e, t, n) => t in e ? pO(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Fp = (e, t, n) => mO(e, typeof t != "symbol" ? t + "" : t, n);
const ik = {
  NewMessage: "new-message"
}, iE = [ik.NewMessage];
let gO = class {
  constructor(t) {
    Fp(this, "channels"), Fp(this, "params"), Fp(this, "inbox"), this.socket = t, this.channels = {}, this.params = {}, this.inbox = new Bl({});
  }
  join(t) {
    const n = t.socketChannelTopic, r = t.referenceId, i = t.defaultOptions;
    this.socket.isConnected() || this.socket.connect(), this.params[n] || (this.params[n] = {});
    const s = this.params[n][r], l = !s || JSON.stringify(s) !== JSON.stringify(i);
    if (l && (this.params[n] = { ...this.params[n], [r]: i }), !this.channels[n] || l) {
      const d = this.socket.channel(n, this.params[n]);
      for (const h of iE)
        d.on(h, (f) => this.setInbox(f));
      this.channels[n] = d;
    }
    const u = this.channels[n];
    return ["closed", "errored"].includes(u.state) && u.join(), this.inbox.subscribe(() => {
      const d = this.inbox.state[r];
      d && t.handleSocketEvent(d);
    });
  }
  leave(t) {
    var n;
    (n = t.unsubscribeFromSocketEvents) == null || n.call(t);
    const r = t.socketChannelTopic, i = t.referenceId, s = { ...this.params }, l = s[r] || {};
    l[i] && delete l[i];
    const u = { ...this.channels }, d = u[r];
    if (d && Object.keys(l).length === 0) {
      for (const h of iE)
        d.off(h);
      d.leave(), delete u[r];
    }
    this.params = s, this.channels = u;
  }
  setInbox(t) {
    const { attn: n, ...r } = t;
    this.inbox.setState(
      () => n.reduce((i, s) => ({ ...i, [s]: r }), {})
    );
  }
};
function vO(e) {
  const t = {}, n = [];
  return e.reduce((r, i) => t[i.id] ? r : (t[i.id] = !0, [...r, i]), n);
}
function yO(e) {
  return e.sort((t, n) => new Date(n.inserted_at).getTime() - new Date(t.inserted_at).getTime());
}
function oE(e) {
  const { inserted_at_date_range: t, ...n } = e;
  if (!t)
    return n;
  const r = {}, i = t.inclusive ?? !1;
  if (t.start) {
    const s = i ? "inserted_at.gte" : "inserted_at.gt";
    r[s] = t.start;
  }
  if (t.end) {
    const s = i ? "inserted_at.lte" : "inserted_at.lt";
    r[s] = t.end;
  }
  return { ...n, ...r };
}
function wO(e) {
  if (typeof (e == null ? void 0 : e.trigger_data) == "object")
    return JSON.stringify(e.trigger_data);
  if (typeof (e == null ? void 0 : e.trigger_data) == "string")
    return e.trigger_data;
}
var bO = Object.defineProperty, CO = (e, t, n) => t in e ? bO(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, EO = (e, t, n) => CO(e, t + "", n);
function AO(e) {
  const t = vO(e);
  return yO(t);
}
const xO = {
  shouldSetPage: !0,
  shouldAppend: !1
}, od = {
  items: [],
  metadata: {
    total_count: 0,
    unread_count: 0,
    unseen_count: 0
  },
  pageInfo: {
    before: null,
    after: null,
    page_size: 50
  },
  loading: !1,
  networkStatus: vi.ready,
  setResult: () => {
  },
  setMetadata: () => {
  },
  setNetworkStatus: () => {
  },
  resetStore: () => {
  },
  setItemAttrs: () => {
  }
}, SO = () => {
  const e = new Bl(od);
  return e.setState((t) => ({
    ...t,
    // The network status indicates what's happening with the request
    networkStatus: vi.ready,
    loading: !1,
    setNetworkStatus: (n) => e.setState((r) => ({
      ...r,
      networkStatus: n,
      loading: n === vi.loading
    })),
    setResult: ({ entries: n, meta: r, page_info: i }, s = xO) => e.setState((l) => {
      const u = s.shouldAppend ? AO(l.items.concat(n)) : n;
      return {
        ...l,
        items: u,
        metadata: r,
        pageInfo: s.shouldSetPage ? i : l.pageInfo,
        loading: !1,
        networkStatus: vi.ready
      };
    }),
    setMetadata: (n) => e.setState((r) => ({ ...r, metadata: n })),
    resetStore: (n = od.metadata) => e.setState(() => ({
      ...od,
      setResult: e.state.setResult,
      setMetadata: e.state.setMetadata,
      setNetworkStatus: e.state.setNetworkStatus,
      resetStore: e.state.resetStore,
      setItemAttrs: e.state.setItemAttrs,
      metadata: n
    })),
    setItemAttrs: (n, r) => {
      const i = n.reduce(
        (s, l) => ({ ...s, [l]: r }),
        {}
      );
      return e.setState((s) => {
        const l = s.items.map((u) => i[u.id] ? { ...u, ...i[u.id] } : u);
        return { ...s, items: l };
      });
    }
  })), e;
};
let kO = class {
  constructor(t) {
    EO(this, "store"), this.store = t;
  }
  getState() {
    return this.store.state;
  }
  setState(t) {
    this.store.setState(
      typeof t == "function" ? t : () => t
    );
  }
  getInitialState() {
    return od;
  }
  subscribe(t) {
    return this.store.subscribe((n) => t(n.currentVal));
  }
};
function RO() {
  const e = SO();
  return new kO(e);
}
var TO = Object.defineProperty, $O = (e, t, n) => t in e ? TO(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, En = (e, t, n) => $O(e, typeof t != "symbol" ? t + "" : t, n);
const VO = {
  archived: "exclude"
}, _O = 2e3, IO = "client_";
let LO = class {
  constructor(t, n, r, i) {
    En(this, "defaultOptions"), En(this, "referenceId"), En(this, "unsubscribeFromSocketEvents"), En(this, "socketManager"), En(this, "userFeedId"), En(this, "broadcaster"), En(this, "broadcastChannel"), En(this, "disconnectTimer", null), En(this, "hasSubscribedToRealTimeUpdates", !1), En(this, "visibilityChangeHandler", () => {
    }), En(this, "visibilityChangeListenerConnected", !1), En(this, "store"), this.knock = t, this.feedId = n, (!n || !lO(n)) && this.knock.log(
      "[Feed] Invalid or missing feedId provided to the Feed constructor. The feed should be a UUID of an in-app feed channel (`in_app_feed`) found in the Knock dashboard. Please provide a valid feedId to the Feed constructor.",
      !0
    ), this.feedId = n, this.userFeedId = this.buildUserFeedId(), this.referenceId = IO + sO(), this.socketManager = i, this.store = RO(), this.broadcaster = new oO({ wildcard: !0, delimiter: "." }), this.defaultOptions = {
      ...VO,
      ...oE(r)
    }, this.knock.log(`[Feed] Initialized a feed on channel ${n}`), this.initializeRealtimeConnection(), this.setupBroadcastChannel();
  }
  /**
   * Used to reinitialize a current feed instance, which is useful when reauthenticating users
   */
  reinitialize(t) {
    this.socketManager = t, this.userFeedId = this.buildUserFeedId(), this.initializeRealtimeConnection(), this.setupBroadcastChannel();
  }
  /**
   * Cleans up a feed instance by destroying the store and disconnecting
   * an open socket connection.
   */
  teardown() {
    var t;
    this.knock.log("[Feed] Tearing down feed instance"), (t = this.socketManager) == null || t.leave(this), this.tearDownVisibilityListeners(), this.disconnectTimer && (clearTimeout(this.disconnectTimer), this.disconnectTimer = null), this.broadcastChannel && this.broadcastChannel.close();
  }
  /** Tears down an instance and removes it entirely from the feed manager */
  dispose() {
    this.knock.log("[Feed] Disposing of feed instance"), this.teardown(), this.broadcaster.removeAllListeners(), this.knock.feeds.removeInstance(this);
  }
  /*
    Initializes a real-time connection to Knock, connecting the websocket for the
    current ApiClient instance if the socket is not already connected.
  */
  listenForUpdates() {
    var t;
    if (this.knock.log("[Feed] Connecting to real-time service"), this.hasSubscribedToRealTimeUpdates = !0, !this.knock.isAuthenticated()) {
      this.knock.log(
        "[Feed] User is not authenticated, skipping listening for updates"
      );
      return;
    }
    this.unsubscribeFromSocketEvents = (t = this.socketManager) == null ? void 0 : t.join(this);
  }
  /* Binds a handler to be invoked when event occurs */
  on(t, n) {
    this.broadcaster.on(t, n);
  }
  off(t, n) {
    this.broadcaster.off(t, n);
  }
  getState() {
    return this.store.getState();
  }
  async markAsSeen(t) {
    const n = (/* @__PURE__ */ new Date()).toISOString();
    return this.optimisticallyPerformStatusUpdate(
      t,
      "seen",
      { seen_at: n },
      "unseen_count"
    ), this.makeStatusUpdate(t, "seen");
  }
  async markAllAsSeen() {
    const { metadata: t, items: n, ...r } = this.store.getState();
    if (this.defaultOptions.status === "unseen")
      r.resetStore({
        ...t,
        total_count: 0,
        unseen_count: 0
      });
    else {
      r.setMetadata({ ...t, unseen_count: 0 });
      const s = { seen_at: (/* @__PURE__ */ new Date()).toISOString() }, l = n.map((u) => u.id);
      r.setItemAttrs(l, s);
    }
    const i = await this.makeBulkStatusUpdate("seen");
    return this.emitEvent("all_seen", n), i;
  }
  async markAsUnseen(t) {
    return this.optimisticallyPerformStatusUpdate(
      t,
      "unseen",
      { seen_at: null },
      "unseen_count"
    ), this.makeStatusUpdate(t, "unseen");
  }
  async markAsRead(t) {
    const n = (/* @__PURE__ */ new Date()).toISOString();
    return this.optimisticallyPerformStatusUpdate(
      t,
      "read",
      { read_at: n },
      "unread_count"
    ), this.makeStatusUpdate(t, "read");
  }
  async markAllAsRead() {
    const { metadata: t, items: n, ...r } = this.store.getState();
    if (this.defaultOptions.status === "unread")
      r.resetStore({
        ...t,
        total_count: 0,
        unread_count: 0
      });
    else {
      r.setMetadata({ ...t, unread_count: 0 });
      const s = { read_at: (/* @__PURE__ */ new Date()).toISOString() }, l = n.map((u) => u.id);
      r.setItemAttrs(l, s);
    }
    const i = await this.makeBulkStatusUpdate("read");
    return this.emitEvent("all_read", n), i;
  }
  async markAsUnread(t) {
    return this.optimisticallyPerformStatusUpdate(
      t,
      "unread",
      { read_at: null },
      "unread_count"
    ), this.makeStatusUpdate(t, "unread");
  }
  async markAsInteracted(t, n) {
    const r = (/* @__PURE__ */ new Date()).toISOString();
    return this.optimisticallyPerformStatusUpdate(
      t,
      "interacted",
      {
        read_at: r,
        interacted_at: r
      },
      "unread_count"
    ), this.makeStatusUpdate(t, "interacted", n);
  }
  /*
    Marking one or more items as archived should:
  
    - Decrement the badge count for any unread / unseen items
    - Remove the item from the feed list when the `archived` flag is "exclude" (default)
  
    TODO: how do we handle rollbacks?
    */
  async markAsArchived(t) {
    const n = this.store.getState(), r = this.defaultOptions.archived === "exclude", i = Array.isArray(t) ? t : [t], s = i.map((l) => l.id);
    if (r) {
      const l = i.filter((f) => !f.seen_at).length, u = i.filter((f) => !f.read_at).length, d = {
        ...n.metadata,
        // Ensure that the counts don't ever go below 0 on archiving where the client state
        // gets out of sync with the server state
        total_count: Math.max(0, n.metadata.total_count - i.length),
        unseen_count: Math.max(0, n.metadata.unseen_count - l),
        unread_count: Math.max(0, n.metadata.unread_count - u)
      }, h = n.items.filter(
        (f) => !s.includes(f.id)
      );
      n.setResult({
        entries: h,
        meta: d,
        page_info: n.pageInfo
      });
    } else
      n.setItemAttrs(s, { archived_at: (/* @__PURE__ */ new Date()).toISOString() });
    return this.makeStatusUpdate(t, "archived");
  }
  async markAllAsArchived() {
    const { items: t, ...n } = this.store.getState();
    if (this.defaultOptions.archived === "exclude")
      n.resetStore();
    else {
      const i = t.map((s) => s.id);
      n.setItemAttrs(i, { archived_at: (/* @__PURE__ */ new Date()).toISOString() });
    }
    const r = await this.makeBulkStatusUpdate("archive");
    return this.emitEvent("all_archived", t), r;
  }
  async markAllReadAsArchived() {
    const { items: t, ...n } = this.store.getState(), r = t.filter((i) => i.read_at === null).map((i) => i.id);
    if (n.setItemAttrs(r, {
      archived_at: (/* @__PURE__ */ new Date()).toISOString()
    }), this.defaultOptions.archived === "exclude") {
      const i = t.filter((l) => !r.includes(l.id)), s = {
        ...n.metadata,
        total_count: i.length,
        unread_count: 0
      };
      n.setResult({
        entries: i,
        meta: s,
        page_info: n.pageInfo
      });
    }
    return await this.makeBulkStatusUpdate("archive");
  }
  async markAsUnarchived(t) {
    const n = this.store.getState(), r = Array.isArray(t) ? t : [t], i = r.map((s) => s.id);
    if (this.defaultOptions.archived === "only") {
      const s = r.filter((h) => !h.seen_at).length, l = r.filter((h) => !h.read_at).length, u = {
        ...n.metadata,
        // Ensure that the counts don't ever go below 0 on unarchiving where the client state
        // gets out of sync with the server state
        total_count: Math.max(0, n.metadata.total_count - r.length),
        unseen_count: Math.max(0, n.metadata.unseen_count - s),
        unread_count: Math.max(0, n.metadata.unread_count - l)
      }, d = n.items.filter(
        (h) => !i.includes(h.id)
      );
      n.setResult({
        entries: d,
        meta: u,
        page_info: n.pageInfo
      });
    } else
      this.optimisticallyPerformStatusUpdate(t, "unarchived", {
        archived_at: null
      });
    return this.makeStatusUpdate(t, "unarchived");
  }
  /* Fetches the feed content, appending it to the store */
  async fetch(t = {}) {
    const { networkStatus: n, ...r } = this.store.getState();
    if (!this.knock.isAuthenticated()) {
      this.knock.log("[Feed] User is not authenticated, skipping fetch");
      return;
    }
    if (uO(n)) {
      this.knock.log("[Feed] Request is in flight, skipping fetch");
      return;
    }
    r.setNetworkStatus(t.__loadingType ?? vi.loading);
    const i = wO({
      ...this.defaultOptions,
      ...t
    }), s = {
      ...this.defaultOptions,
      ...oE(t),
      trigger_data: i,
      // Unset options that should not be sent to the API
      __loadingType: void 0,
      __fetchSource: void 0,
      __experimentalCrossBrowserUpdates: void 0,
      auto_manage_socket_connection: void 0,
      auto_manage_socket_connection_delay: void 0
    }, l = await this.knock.client().makeRequest({
      method: "GET",
      url: `/v1/users/${this.knock.userId}/feeds/${this.feedId}`,
      params: s
    });
    if (l.statusCode === "error" || !l.body)
      return r.setNetworkStatus(vi.error), {
        status: l.statusCode,
        data: l.error || l.body
      };
    const u = {
      entries: l.body.entries,
      meta: l.body.meta,
      page_info: l.body.page_info
    };
    if (t.before) {
      const f = { shouldSetPage: !1, shouldAppend: !0 };
      r.setResult(u, f);
    } else if (t.after) {
      const f = { shouldSetPage: !0, shouldAppend: !0 };
      r.setResult(u, f);
    } else
      r.setResult(u);
    this.broadcast("messages.new", u);
    const d = t.__fetchSource === "socket" ? "items.received.realtime" : "items.received.page", h = {
      items: u.entries,
      metadata: u.meta,
      event: d
    };
    return this.broadcast(h.event, h), { data: u, status: l.statusCode };
  }
  async fetchNextPage(t = {}) {
    const { pageInfo: n } = this.store.getState();
    n.after && this.fetch({
      ...t,
      after: n.after,
      __loadingType: vi.fetchMore
    });
  }
  get socketChannelTopic() {
    return `feeds:${this.userFeedId}`;
  }
  broadcast(t, n) {
    this.broadcaster.emit(t, n);
  }
  // Invoked when a new real-time message comes in from the socket
  async onNewMessageReceived({ data: t }) {
    var n;
    this.knock.log("[Feed] Received new real-time message");
    const { items: r, ...i } = this.store.getState(), s = r[0], l = (n = t[this.referenceId]) == null ? void 0 : n.metadata;
    l && i.setMetadata(l), this.fetch({ before: s == null ? void 0 : s.__cursor, __fetchSource: "socket" });
  }
  buildUserFeedId() {
    return `${this.feedId}:${this.knock.userId}`;
  }
  optimisticallyPerformStatusUpdate(t, n, r, i) {
    const s = this.store.getState(), l = Array.isArray(t) ? t : [t], u = l.map((d) => d.id);
    if (i) {
      const { metadata: d } = s, h = l.filter((m) => {
        switch (n) {
          case "seen":
            return m.seen_at === null;
          case "unseen":
            return m.seen_at !== null;
          case "read":
          case "interacted":
            return m.read_at === null;
          case "unread":
            return m.read_at !== null;
          default:
            return !0;
        }
      }), f = n.startsWith("un") ? h.length : -h.length;
      s.setMetadata({
        ...d,
        [i]: Math.max(0, d[i] + f)
      });
    }
    s.setItemAttrs(u, r);
  }
  async makeStatusUpdate(t, n, r) {
    const i = Array.isArray(t) ? t : [t], s = i.map((u) => u.id), l = await this.knock.messages.batchUpdateStatuses(
      s,
      n,
      { metadata: r }
    );
    return this.emitEvent(n, i), l;
  }
  async makeBulkStatusUpdate(t) {
    const n = {
      user_ids: [this.knock.userId],
      engagement_status: this.defaultOptions.status !== "all" ? this.defaultOptions.status : void 0,
      archived: this.defaultOptions.archived,
      has_tenant: this.defaultOptions.has_tenant,
      tenants: this.defaultOptions.tenant ? [this.defaultOptions.tenant] : void 0
    };
    return await this.knock.messages.bulkUpdateAllStatusesInChannel({
      channelId: this.feedId,
      status: t,
      options: n
    });
  }
  setupBroadcastChannel() {
    this.broadcastChannel = typeof self < "u" && "BroadcastChannel" in self ? new BroadcastChannel(`knock:feed:${this.userFeedId}`) : null, this.broadcastChannel && this.defaultOptions.__experimentalCrossBrowserUpdates === !0 && (this.broadcastChannel.onmessage = (t) => {
      switch (t.data.type) {
        case "items:archived":
        case "items:unarchived":
        case "items:seen":
        case "items:unseen":
        case "items:read":
        case "items:unread":
        case "items:all_read":
        case "items:all_seen":
        case "items:all_archived":
          return this.fetch();
        default:
          return null;
      }
    });
  }
  broadcastOverChannel(t, n) {
    if (this.broadcastChannel)
      try {
        const r = JSON.parse(JSON.stringify(n));
        this.broadcastChannel.postMessage({
          type: t,
          payload: r
        });
      } catch (r) {
        console.warn(`Could not broadcast ${t}, got error: ${r}`);
      }
  }
  initializeRealtimeConnection() {
    var t;
    this.socketManager && (this.defaultOptions.auto_manage_socket_connection && this.setUpVisibilityListeners(), this.hasSubscribedToRealTimeUpdates && this.knock.isAuthenticated() && (this.unsubscribeFromSocketEvents = (t = this.socketManager) == null ? void 0 : t.join(this)));
  }
  async handleSocketEvent(t) {
    switch (t.event) {
      case ik.NewMessage:
        this.onNewMessageReceived(t);
        return;
      default: {
        t.event;
        return;
      }
    }
  }
  /**
   * Listen for changes to document visibility and automatically disconnect
   * or reconnect the socket after a delay
   */
  setUpVisibilityListeners() {
    typeof document > "u" || this.visibilityChangeListenerConnected || (this.visibilityChangeHandler = this.handleVisibilityChange.bind(this), this.visibilityChangeListenerConnected = !0, document.addEventListener("visibilitychange", this.visibilityChangeHandler));
  }
  tearDownVisibilityListeners() {
    typeof document > "u" || (document.removeEventListener(
      "visibilitychange",
      this.visibilityChangeHandler
    ), this.visibilityChangeListenerConnected = !1);
  }
  emitEvent(t, n) {
    this.broadcaster.emit(`items.${t}`, { items: n }), this.broadcaster.emit(`items:${t}`, { items: n }), this.broadcastOverChannel(`items:${t}`, { items: n });
  }
  handleVisibilityChange() {
    var t, n;
    const r = this.defaultOptions.auto_manage_socket_connection_delay ?? _O, i = this.knock.client();
    document.visibilityState === "hidden" ? this.disconnectTimer = setTimeout(() => {
      var s;
      (s = i.socket) == null || s.disconnect(), this.disconnectTimer = null;
    }, r) : document.visibilityState === "visible" && (this.disconnectTimer && (clearTimeout(this.disconnectTimer), this.disconnectTimer = null), (t = i.socket) != null && t.isConnected() || (n = i.socket) == null || n.connect());
  }
};
var PO = Object.defineProperty, MO = (e, t, n) => t in e ? PO(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Up = (e, t, n) => MO(e, typeof t != "symbol" ? t + "" : t, n);
let OO = class {
  constructor(t) {
    Up(this, "instance"), Up(this, "feedInstances", []), Up(this, "socketManager"), this.instance = t;
  }
  initialize(t, n = {}) {
    this.initSocketManager();
    const r = new LO(
      this.instance,
      t,
      n,
      this.socketManager
    );
    return this.feedInstances.push(r), r;
  }
  removeInstance(t) {
    this.feedInstances = this.feedInstances.filter((n) => n !== t);
  }
  teardownInstances() {
    for (const t of this.feedInstances)
      t.teardown();
  }
  reinitializeInstances() {
    var t;
    for (const n of this.feedInstances)
      (t = this.socketManager) == null || t.leave(n);
    this.socketManager = void 0, this.initSocketManager();
    for (const n of this.feedInstances)
      n.reinitialize(this.socketManager);
  }
  initSocketManager() {
    const t = this.instance.client().socket;
    t && !this.socketManager && (this.socketManager = new gO(t));
  }
};
class ml extends Error {
}
ml.prototype.name = "InvalidTokenError";
function BO(e) {
  return decodeURIComponent(atob(e).replace(/(.)/g, (t, n) => {
    let r = n.charCodeAt(0).toString(16).toUpperCase();
    return r.length < 2 && (r = "0" + r), "%" + r;
  }));
}
function NO(e) {
  let t = e.replace(/-/g, "+").replace(/_/g, "/");
  switch (t.length % 4) {
    case 0:
      break;
    case 2:
      t += "==";
      break;
    case 3:
      t += "=";
      break;
    default:
      throw new Error("base64 string is not of the correct length");
  }
  try {
    return BO(t);
  } catch {
    return atob(t);
  }
}
function DO(e, t) {
  if (typeof e != "string")
    throw new ml("Invalid token specified: must be a string");
  t || (t = {});
  const n = t.header === !0 ? 0 : 1, r = e.split(".")[n];
  if (typeof r != "string")
    throw new ml(`Invalid token specified: missing part #${n + 1}`);
  let i;
  try {
    i = NO(r);
  } catch (s) {
    throw new ml(`Invalid token specified: invalid base64 for part #${n + 1} (${s.message})`);
  }
  try {
    return JSON.parse(i);
  } catch (s) {
    throw new ml(`Invalid token specified: invalid json for part #${n + 1} (${s.message})`);
  }
}
function ok(e, t) {
  return function() {
    return e.apply(t, arguments);
  };
}
const { toString: jO } = Object.prototype, { getPrototypeOf: Fv } = Object, { iterator: af, toStringTag: sk } = Symbol, lf = /* @__PURE__ */ ((e) => (t) => {
  const n = jO.call(t);
  return e[n] || (e[n] = n.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), Yn = (e) => (e = e.toLowerCase(), (t) => lf(t) === e), uf = (e) => (t) => typeof t === e, { isArray: Hs } = Array, Is = uf("undefined");
function ou(e) {
  return e !== null && !Is(e) && e.constructor !== null && !Is(e.constructor) && Zt(e.constructor.isBuffer) && e.constructor.isBuffer(e);
}
const ak = Yn("ArrayBuffer");
function FO(e) {
  let t;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? t = ArrayBuffer.isView(e) : t = e && e.buffer && ak(e.buffer), t;
}
const UO = uf("string"), Zt = uf("function"), lk = uf("number"), su = (e) => e !== null && typeof e == "object", WO = (e) => e === !0 || e === !1, sd = (e) => {
  if (lf(e) !== "object")
    return !1;
  const t = Fv(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(sk in e) && !(af in e);
}, zO = (e) => {
  if (!su(e) || ou(e))
    return !1;
  try {
    return Object.keys(e).length === 0 && Object.getPrototypeOf(e) === Object.prototype;
  } catch {
    return !1;
  }
}, HO = Yn("Date"), KO = Yn("File"), GO = Yn("Blob"), YO = Yn("FileList"), qO = (e) => su(e) && Zt(e.pipe), XO = (e) => {
  let t;
  return e && (typeof FormData == "function" && e instanceof FormData || Zt(e.append) && ((t = lf(e)) === "formdata" || // detect form-data instance
  t === "object" && Zt(e.toString) && e.toString() === "[object FormData]"));
}, ZO = Yn("URLSearchParams"), [QO, JO, eB, tB] = ["ReadableStream", "Request", "Response", "Headers"].map(Yn), nB = (e) => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function au(e, t, { allOwnKeys: n = !1 } = {}) {
  if (e === null || typeof e > "u")
    return;
  let r, i;
  if (typeof e != "object" && (e = [e]), Hs(e))
    for (r = 0, i = e.length; r < i; r++)
      t.call(null, e[r], r, e);
  else {
    if (ou(e))
      return;
    const s = n ? Object.getOwnPropertyNames(e) : Object.keys(e), l = s.length;
    let u;
    for (r = 0; r < l; r++)
      u = s[r], t.call(null, e[u], u, e);
  }
}
function uk(e, t) {
  if (ou(e))
    return null;
  t = t.toLowerCase();
  const n = Object.keys(e);
  let r = n.length, i;
  for (; r-- > 0; )
    if (i = n[r], t === i.toLowerCase())
      return i;
  return null;
}
const zi = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, ck = (e) => !Is(e) && e !== zi;
function Km() {
  const { caseless: e, skipUndefined: t } = ck(this) && this || {}, n = {}, r = (i, s) => {
    const l = e && uk(n, s) || s;
    sd(n[l]) && sd(i) ? n[l] = Km(n[l], i) : sd(i) ? n[l] = Km({}, i) : Hs(i) ? n[l] = i.slice() : (!t || !Is(i)) && (n[l] = i);
  };
  for (let i = 0, s = arguments.length; i < s; i++)
    arguments[i] && au(arguments[i], r);
  return n;
}
const rB = (e, t, n, { allOwnKeys: r } = {}) => (au(t, (i, s) => {
  n && Zt(i) ? e[s] = ok(i, n) : e[s] = i;
}, { allOwnKeys: r }), e), iB = (e) => (e.charCodeAt(0) === 65279 && (e = e.slice(1)), e), oB = (e, t, n, r) => {
  e.prototype = Object.create(t.prototype, r), e.prototype.constructor = e, Object.defineProperty(e, "super", {
    value: t.prototype
  }), n && Object.assign(e.prototype, n);
}, sB = (e, t, n, r) => {
  let i, s, l;
  const u = {};
  if (t = t || {}, e == null) return t;
  do {
    for (i = Object.getOwnPropertyNames(e), s = i.length; s-- > 0; )
      l = i[s], (!r || r(l, e, t)) && !u[l] && (t[l] = e[l], u[l] = !0);
    e = n !== !1 && Fv(e);
  } while (e && (!n || n(e, t)) && e !== Object.prototype);
  return t;
}, aB = (e, t, n) => {
  e = String(e), (n === void 0 || n > e.length) && (n = e.length), n -= t.length;
  const r = e.indexOf(t, n);
  return r !== -1 && r === n;
}, lB = (e) => {
  if (!e) return null;
  if (Hs(e)) return e;
  let t = e.length;
  if (!lk(t)) return null;
  const n = new Array(t);
  for (; t-- > 0; )
    n[t] = e[t];
  return n;
}, uB = /* @__PURE__ */ ((e) => (t) => e && t instanceof e)(typeof Uint8Array < "u" && Fv(Uint8Array)), cB = (e, t) => {
  const r = (e && e[af]).call(e);
  let i;
  for (; (i = r.next()) && !i.done; ) {
    const s = i.value;
    t.call(e, s[0], s[1]);
  }
}, dB = (e, t) => {
  let n;
  const r = [];
  for (; (n = e.exec(t)) !== null; )
    r.push(n);
  return r;
}, fB = Yn("HTMLFormElement"), hB = (e) => e.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(n, r, i) {
    return r.toUpperCase() + i;
  }
), sE = (({ hasOwnProperty: e }) => (t, n) => e.call(t, n))(Object.prototype), pB = Yn("RegExp"), dk = (e, t) => {
  const n = Object.getOwnPropertyDescriptors(e), r = {};
  au(n, (i, s) => {
    let l;
    (l = t(i, s, e)) !== !1 && (r[s] = l || i);
  }), Object.defineProperties(e, r);
}, mB = (e) => {
  dk(e, (t, n) => {
    if (Zt(e) && ["arguments", "caller", "callee"].indexOf(n) !== -1)
      return !1;
    const r = e[n];
    if (Zt(r)) {
      if (t.enumerable = !1, "writable" in t) {
        t.writable = !1;
        return;
      }
      t.set || (t.set = () => {
        throw Error("Can not rewrite read-only method '" + n + "'");
      });
    }
  });
}, gB = (e, t) => {
  const n = {}, r = (i) => {
    i.forEach((s) => {
      n[s] = !0;
    });
  };
  return Hs(e) ? r(e) : r(String(e).split(t)), n;
}, vB = () => {
}, yB = (e, t) => e != null && Number.isFinite(e = +e) ? e : t;
function wB(e) {
  return !!(e && Zt(e.append) && e[sk] === "FormData" && e[af]);
}
const bB = (e) => {
  const t = new Array(10), n = (r, i) => {
    if (su(r)) {
      if (t.indexOf(r) >= 0)
        return;
      if (ou(r))
        return r;
      if (!("toJSON" in r)) {
        t[i] = r;
        const s = Hs(r) ? [] : {};
        return au(r, (l, u) => {
          const d = n(l, i + 1);
          !Is(d) && (s[u] = d);
        }), t[i] = void 0, s;
      }
    }
    return r;
  };
  return n(e, 0);
}, CB = Yn("AsyncFunction"), EB = (e) => e && (su(e) || Zt(e)) && Zt(e.then) && Zt(e.catch), fk = ((e, t) => e ? setImmediate : t ? ((n, r) => (zi.addEventListener("message", ({ source: i, data: s }) => {
  i === zi && s === n && r.length && r.shift()();
}, !1), (i) => {
  r.push(i), zi.postMessage(n, "*");
}))(`axios@${Math.random()}`, []) : (n) => setTimeout(n))(
  typeof setImmediate == "function",
  Zt(zi.postMessage)
), AB = typeof queueMicrotask < "u" ? queueMicrotask.bind(zi) : typeof process < "u" && process.nextTick || fk, xB = (e) => e != null && Zt(e[af]), Z = {
  isArray: Hs,
  isArrayBuffer: ak,
  isBuffer: ou,
  isFormData: XO,
  isArrayBufferView: FO,
  isString: UO,
  isNumber: lk,
  isBoolean: WO,
  isObject: su,
  isPlainObject: sd,
  isEmptyObject: zO,
  isReadableStream: QO,
  isRequest: JO,
  isResponse: eB,
  isHeaders: tB,
  isUndefined: Is,
  isDate: HO,
  isFile: KO,
  isBlob: GO,
  isRegExp: pB,
  isFunction: Zt,
  isStream: qO,
  isURLSearchParams: ZO,
  isTypedArray: uB,
  isFileList: YO,
  forEach: au,
  merge: Km,
  extend: rB,
  trim: nB,
  stripBOM: iB,
  inherits: oB,
  toFlatObject: sB,
  kindOf: lf,
  kindOfTest: Yn,
  endsWith: aB,
  toArray: lB,
  forEachEntry: cB,
  matchAll: dB,
  isHTMLForm: fB,
  hasOwnProperty: sE,
  hasOwnProp: sE,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: dk,
  freezeMethods: mB,
  toObjectSet: gB,
  toCamelCase: hB,
  noop: vB,
  toFiniteNumber: yB,
  findKey: uk,
  global: zi,
  isContextDefined: ck,
  isSpecCompliantForm: wB,
  toJSONObject: bB,
  isAsyncFn: CB,
  isThenable: EB,
  setImmediate: fk,
  asap: AB,
  isIterable: xB
};
function _e(e, t, n, r, i) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e, this.name = "AxiosError", t && (this.code = t), n && (this.config = n), r && (this.request = r), i && (this.response = i, this.status = i.status ? i.status : null);
}
Z.inherits(_e, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: Z.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const hk = _e.prototype, pk = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((e) => {
  pk[e] = { value: e };
});
Object.defineProperties(_e, pk);
Object.defineProperty(hk, "isAxiosError", { value: !0 });
_e.from = (e, t, n, r, i, s) => {
  const l = Object.create(hk);
  Z.toFlatObject(e, l, function(f) {
    return f !== Error.prototype;
  }, (h) => h !== "isAxiosError");
  const u = e && e.message ? e.message : "Error", d = t == null && e ? e.code : t;
  return _e.call(l, u, d, n, r, i), e && l.cause == null && Object.defineProperty(l, "cause", { value: e, configurable: !0 }), l.name = e && e.name || "Error", s && Object.assign(l, s), l;
};
const SB = null;
function Gm(e) {
  return Z.isPlainObject(e) || Z.isArray(e);
}
function mk(e) {
  return Z.endsWith(e, "[]") ? e.slice(0, -2) : e;
}
function aE(e, t, n) {
  return e ? e.concat(t).map(function(i, s) {
    return i = mk(i), !n && s ? "[" + i + "]" : i;
  }).join(n ? "." : "") : t;
}
function kB(e) {
  return Z.isArray(e) && !e.some(Gm);
}
const RB = Z.toFlatObject(Z, {}, null, function(t) {
  return /^is[A-Z]/.test(t);
});
function cf(e, t, n) {
  if (!Z.isObject(e))
    throw new TypeError("target must be an object");
  t = t || new FormData(), n = Z.toFlatObject(n, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(b, A) {
    return !Z.isUndefined(A[b]);
  });
  const r = n.metaTokens, i = n.visitor || f, s = n.dots, l = n.indexes, d = (n.Blob || typeof Blob < "u" && Blob) && Z.isSpecCompliantForm(t);
  if (!Z.isFunction(i))
    throw new TypeError("visitor must be a function");
  function h(E) {
    if (E === null) return "";
    if (Z.isDate(E))
      return E.toISOString();
    if (Z.isBoolean(E))
      return E.toString();
    if (!d && Z.isBlob(E))
      throw new _e("Blob is not supported. Use a Buffer instead.");
    return Z.isArrayBuffer(E) || Z.isTypedArray(E) ? d && typeof Blob == "function" ? new Blob([E]) : Buffer.from(E) : E;
  }
  function f(E, b, A) {
    let x = E;
    if (E && !A && typeof E == "object") {
      if (Z.endsWith(b, "{}"))
        b = r ? b : b.slice(0, -2), E = JSON.stringify(E);
      else if (Z.isArray(E) && kB(E) || (Z.isFileList(E) || Z.endsWith(b, "[]")) && (x = Z.toArray(E)))
        return b = mk(b), x.forEach(function(_, L) {
          !(Z.isUndefined(_) || _ === null) && t.append(
            // eslint-disable-next-line no-nested-ternary
            l === !0 ? aE([b], L, s) : l === null ? b : b + "[]",
            h(_)
          );
        }), !1;
    }
    return Gm(E) ? !0 : (t.append(aE(A, b, s), h(E)), !1);
  }
  const m = [], g = Object.assign(RB, {
    defaultVisitor: f,
    convertValue: h,
    isVisitable: Gm
  });
  function w(E, b) {
    if (!Z.isUndefined(E)) {
      if (m.indexOf(E) !== -1)
        throw Error("Circular reference detected in " + b.join("."));
      m.push(E), Z.forEach(E, function(x, R) {
        (!(Z.isUndefined(x) || x === null) && i.call(
          t,
          x,
          Z.isString(R) ? R.trim() : R,
          b,
          g
        )) === !0 && w(x, b ? b.concat(R) : [R]);
      }), m.pop();
    }
  }
  if (!Z.isObject(e))
    throw new TypeError("data must be an object");
  return w(e), t;
}
function lE(e) {
  const t = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function(r) {
    return t[r];
  });
}
function Uv(e, t) {
  this._pairs = [], e && cf(e, this, t);
}
const gk = Uv.prototype;
gk.append = function(t, n) {
  this._pairs.push([t, n]);
};
gk.toString = function(t) {
  const n = t ? function(r) {
    return t.call(this, r, lE);
  } : lE;
  return this._pairs.map(function(i) {
    return n(i[0]) + "=" + n(i[1]);
  }, "").join("&");
};
function TB(e) {
  return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+");
}
function vk(e, t, n) {
  if (!t)
    return e;
  const r = n && n.encode || TB;
  Z.isFunction(n) && (n = {
    serialize: n
  });
  const i = n && n.serialize;
  let s;
  if (i ? s = i(t, n) : s = Z.isURLSearchParams(t) ? t.toString() : new Uv(t, n).toString(r), s) {
    const l = e.indexOf("#");
    l !== -1 && (e = e.slice(0, l)), e += (e.indexOf("?") === -1 ? "?" : "&") + s;
  }
  return e;
}
class uE {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(t, n, r) {
    return this.handlers.push({
      fulfilled: t,
      rejected: n,
      synchronous: r ? r.synchronous : !1,
      runWhen: r ? r.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {void}
   */
  eject(t) {
    this.handlers[t] && (this.handlers[t] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(t) {
    Z.forEach(this.handlers, function(r) {
      r !== null && t(r);
    });
  }
}
const yk = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, $B = typeof URLSearchParams < "u" ? URLSearchParams : Uv, VB = typeof FormData < "u" ? FormData : null, _B = typeof Blob < "u" ? Blob : null, IB = {
  isBrowser: !0,
  classes: {
    URLSearchParams: $B,
    FormData: VB,
    Blob: _B
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
}, Wv = typeof window < "u" && typeof document < "u", Ym = typeof navigator == "object" && navigator || void 0, LB = Wv && (!Ym || ["ReactNative", "NativeScript", "NS"].indexOf(Ym.product) < 0), PB = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", MB = Wv && window.location.href || "http://localhost", OB = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv: Wv,
  hasStandardBrowserEnv: LB,
  hasStandardBrowserWebWorkerEnv: PB,
  navigator: Ym,
  origin: MB
}, Symbol.toStringTag, { value: "Module" })), Lt = {
  ...OB,
  ...IB
};
function BB(e, t) {
  return cf(e, new Lt.classes.URLSearchParams(), {
    visitor: function(n, r, i, s) {
      return Lt.isNode && Z.isBuffer(n) ? (this.append(r, n.toString("base64")), !1) : s.defaultVisitor.apply(this, arguments);
    },
    ...t
  });
}
function NB(e) {
  return Z.matchAll(/\w+|\[(\w*)]/g, e).map((t) => t[0] === "[]" ? "" : t[1] || t[0]);
}
function DB(e) {
  const t = {}, n = Object.keys(e);
  let r;
  const i = n.length;
  let s;
  for (r = 0; r < i; r++)
    s = n[r], t[s] = e[s];
  return t;
}
function wk(e) {
  function t(n, r, i, s) {
    let l = n[s++];
    if (l === "__proto__") return !0;
    const u = Number.isFinite(+l), d = s >= n.length;
    return l = !l && Z.isArray(i) ? i.length : l, d ? (Z.hasOwnProp(i, l) ? i[l] = [i[l], r] : i[l] = r, !u) : ((!i[l] || !Z.isObject(i[l])) && (i[l] = []), t(n, r, i[l], s) && Z.isArray(i[l]) && (i[l] = DB(i[l])), !u);
  }
  if (Z.isFormData(e) && Z.isFunction(e.entries)) {
    const n = {};
    return Z.forEachEntry(e, (r, i) => {
      t(NB(r), i, n, 0);
    }), n;
  }
  return null;
}
function jB(e, t, n) {
  if (Z.isString(e))
    try {
      return (t || JSON.parse)(e), Z.trim(e);
    } catch (r) {
      if (r.name !== "SyntaxError")
        throw r;
    }
  return (n || JSON.stringify)(e);
}
const lu = {
  transitional: yk,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function(t, n) {
    const r = n.getContentType() || "", i = r.indexOf("application/json") > -1, s = Z.isObject(t);
    if (s && Z.isHTMLForm(t) && (t = new FormData(t)), Z.isFormData(t))
      return i ? JSON.stringify(wk(t)) : t;
    if (Z.isArrayBuffer(t) || Z.isBuffer(t) || Z.isStream(t) || Z.isFile(t) || Z.isBlob(t) || Z.isReadableStream(t))
      return t;
    if (Z.isArrayBufferView(t))
      return t.buffer;
    if (Z.isURLSearchParams(t))
      return n.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), t.toString();
    let u;
    if (s) {
      if (r.indexOf("application/x-www-form-urlencoded") > -1)
        return BB(t, this.formSerializer).toString();
      if ((u = Z.isFileList(t)) || r.indexOf("multipart/form-data") > -1) {
        const d = this.env && this.env.FormData;
        return cf(
          u ? { "files[]": t } : t,
          d && new d(),
          this.formSerializer
        );
      }
    }
    return s || i ? (n.setContentType("application/json", !1), jB(t)) : t;
  }],
  transformResponse: [function(t) {
    const n = this.transitional || lu.transitional, r = n && n.forcedJSONParsing, i = this.responseType === "json";
    if (Z.isResponse(t) || Z.isReadableStream(t))
      return t;
    if (t && Z.isString(t) && (r && !this.responseType || i)) {
      const l = !(n && n.silentJSONParsing) && i;
      try {
        return JSON.parse(t, this.parseReviver);
      } catch (u) {
        if (l)
          throw u.name === "SyntaxError" ? _e.from(u, _e.ERR_BAD_RESPONSE, this, null, this.response) : u;
      }
    }
    return t;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: Lt.classes.FormData,
    Blob: Lt.classes.Blob
  },
  validateStatus: function(t) {
    return t >= 200 && t < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
Z.forEach(["delete", "get", "head", "post", "put", "patch"], (e) => {
  lu.headers[e] = {};
});
const FB = Z.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), UB = (e) => {
  const t = {};
  let n, r, i;
  return e && e.split(`
`).forEach(function(l) {
    i = l.indexOf(":"), n = l.substring(0, i).trim().toLowerCase(), r = l.substring(i + 1).trim(), !(!n || t[n] && FB[n]) && (n === "set-cookie" ? t[n] ? t[n].push(r) : t[n] = [r] : t[n] = t[n] ? t[n] + ", " + r : r);
  }), t;
}, cE = Symbol("internals");
function dl(e) {
  return e && String(e).trim().toLowerCase();
}
function ad(e) {
  return e === !1 || e == null ? e : Z.isArray(e) ? e.map(ad) : String(e);
}
function WB(e) {
  const t = /* @__PURE__ */ Object.create(null), n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let r;
  for (; r = n.exec(e); )
    t[r[1]] = r[2];
  return t;
}
const zB = (e) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim());
function Wp(e, t, n, r, i) {
  if (Z.isFunction(r))
    return r.call(this, t, n);
  if (i && (t = n), !!Z.isString(t)) {
    if (Z.isString(r))
      return t.indexOf(r) !== -1;
    if (Z.isRegExp(r))
      return r.test(t);
  }
}
function HB(e) {
  return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (t, n, r) => n.toUpperCase() + r);
}
function KB(e, t) {
  const n = Z.toCamelCase(" " + t);
  ["get", "set", "has"].forEach((r) => {
    Object.defineProperty(e, r + n, {
      value: function(i, s, l) {
        return this[r].call(this, t, i, s, l);
      },
      configurable: !0
    });
  });
}
let Qt = class {
  constructor(t) {
    t && this.set(t);
  }
  set(t, n, r) {
    const i = this;
    function s(u, d, h) {
      const f = dl(d);
      if (!f)
        throw new Error("header name must be a non-empty string");
      const m = Z.findKey(i, f);
      (!m || i[m] === void 0 || h === !0 || h === void 0 && i[m] !== !1) && (i[m || d] = ad(u));
    }
    const l = (u, d) => Z.forEach(u, (h, f) => s(h, f, d));
    if (Z.isPlainObject(t) || t instanceof this.constructor)
      l(t, n);
    else if (Z.isString(t) && (t = t.trim()) && !zB(t))
      l(UB(t), n);
    else if (Z.isObject(t) && Z.isIterable(t)) {
      let u = {}, d, h;
      for (const f of t) {
        if (!Z.isArray(f))
          throw TypeError("Object iterator must return a key-value pair");
        u[h = f[0]] = (d = u[h]) ? Z.isArray(d) ? [...d, f[1]] : [d, f[1]] : f[1];
      }
      l(u, n);
    } else
      t != null && s(n, t, r);
    return this;
  }
  get(t, n) {
    if (t = dl(t), t) {
      const r = Z.findKey(this, t);
      if (r) {
        const i = this[r];
        if (!n)
          return i;
        if (n === !0)
          return WB(i);
        if (Z.isFunction(n))
          return n.call(this, i, r);
        if (Z.isRegExp(n))
          return n.exec(i);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(t, n) {
    if (t = dl(t), t) {
      const r = Z.findKey(this, t);
      return !!(r && this[r] !== void 0 && (!n || Wp(this, this[r], r, n)));
    }
    return !1;
  }
  delete(t, n) {
    const r = this;
    let i = !1;
    function s(l) {
      if (l = dl(l), l) {
        const u = Z.findKey(r, l);
        u && (!n || Wp(r, r[u], u, n)) && (delete r[u], i = !0);
      }
    }
    return Z.isArray(t) ? t.forEach(s) : s(t), i;
  }
  clear(t) {
    const n = Object.keys(this);
    let r = n.length, i = !1;
    for (; r--; ) {
      const s = n[r];
      (!t || Wp(this, this[s], s, t, !0)) && (delete this[s], i = !0);
    }
    return i;
  }
  normalize(t) {
    const n = this, r = {};
    return Z.forEach(this, (i, s) => {
      const l = Z.findKey(r, s);
      if (l) {
        n[l] = ad(i), delete n[s];
        return;
      }
      const u = t ? HB(s) : String(s).trim();
      u !== s && delete n[s], n[u] = ad(i), r[u] = !0;
    }), this;
  }
  concat(...t) {
    return this.constructor.concat(this, ...t);
  }
  toJSON(t) {
    const n = /* @__PURE__ */ Object.create(null);
    return Z.forEach(this, (r, i) => {
      r != null && r !== !1 && (n[i] = t && Z.isArray(r) ? r.join(", ") : r);
    }), n;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([t, n]) => t + ": " + n).join(`
`);
  }
  getSetCookie() {
    return this.get("set-cookie") || [];
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(t) {
    return t instanceof this ? t : new this(t);
  }
  static concat(t, ...n) {
    const r = new this(t);
    return n.forEach((i) => r.set(i)), r;
  }
  static accessor(t) {
    const r = (this[cE] = this[cE] = {
      accessors: {}
    }).accessors, i = this.prototype;
    function s(l) {
      const u = dl(l);
      r[u] || (KB(i, l), r[u] = !0);
    }
    return Z.isArray(t) ? t.forEach(s) : s(t), this;
  }
};
Qt.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
Z.reduceDescriptors(Qt.prototype, ({ value: e }, t) => {
  let n = t[0].toUpperCase() + t.slice(1);
  return {
    get: () => e,
    set(r) {
      this[n] = r;
    }
  };
});
Z.freezeMethods(Qt);
function zp(e, t) {
  const n = this || lu, r = t || n, i = Qt.from(r.headers);
  let s = r.data;
  return Z.forEach(e, function(u) {
    s = u.call(n, s, i.normalize(), t ? t.status : void 0);
  }), i.normalize(), s;
}
function bk(e) {
  return !!(e && e.__CANCEL__);
}
function Ks(e, t, n) {
  _e.call(this, e ?? "canceled", _e.ERR_CANCELED, t, n), this.name = "CanceledError";
}
Z.inherits(Ks, _e, {
  __CANCEL__: !0
});
function Ck(e, t, n) {
  const r = n.config.validateStatus;
  !n.status || !r || r(n.status) ? e(n) : t(new _e(
    "Request failed with status code " + n.status,
    [_e.ERR_BAD_REQUEST, _e.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4],
    n.config,
    n.request,
    n
  ));
}
function GB(e) {
  const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
  return t && t[1] || "";
}
function YB(e, t) {
  e = e || 10;
  const n = new Array(e), r = new Array(e);
  let i = 0, s = 0, l;
  return t = t !== void 0 ? t : 1e3, function(d) {
    const h = Date.now(), f = r[s];
    l || (l = h), n[i] = d, r[i] = h;
    let m = s, g = 0;
    for (; m !== i; )
      g += n[m++], m = m % e;
    if (i = (i + 1) % e, i === s && (s = (s + 1) % e), h - l < t)
      return;
    const w = f && h - f;
    return w ? Math.round(g * 1e3 / w) : void 0;
  };
}
function qB(e, t) {
  let n = 0, r = 1e3 / t, i, s;
  const l = (h, f = Date.now()) => {
    n = f, i = null, s && (clearTimeout(s), s = null), e(...h);
  };
  return [(...h) => {
    const f = Date.now(), m = f - n;
    m >= r ? l(h, f) : (i = h, s || (s = setTimeout(() => {
      s = null, l(i);
    }, r - m)));
  }, () => i && l(i)];
}
const kd = (e, t, n = 3) => {
  let r = 0;
  const i = YB(50, 250);
  return qB((s) => {
    const l = s.loaded, u = s.lengthComputable ? s.total : void 0, d = l - r, h = i(d), f = l <= u;
    r = l;
    const m = {
      loaded: l,
      total: u,
      progress: u ? l / u : void 0,
      bytes: d,
      rate: h || void 0,
      estimated: h && u && f ? (u - l) / h : void 0,
      event: s,
      lengthComputable: u != null,
      [t ? "download" : "upload"]: !0
    };
    e(m);
  }, n);
}, dE = (e, t) => {
  const n = e != null;
  return [(r) => t[0]({
    lengthComputable: n,
    total: e,
    loaded: r
  }), t[1]];
}, fE = (e) => (...t) => Z.asap(() => e(...t)), XB = Lt.hasStandardBrowserEnv ? /* @__PURE__ */ ((e, t) => (n) => (n = new URL(n, Lt.origin), e.protocol === n.protocol && e.host === n.host && (t || e.port === n.port)))(
  new URL(Lt.origin),
  Lt.navigator && /(msie|trident)/i.test(Lt.navigator.userAgent)
) : () => !0, ZB = Lt.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(e, t, n, r, i, s, l) {
      if (typeof document > "u") return;
      const u = [`${e}=${encodeURIComponent(t)}`];
      Z.isNumber(n) && u.push(`expires=${new Date(n).toUTCString()}`), Z.isString(r) && u.push(`path=${r}`), Z.isString(i) && u.push(`domain=${i}`), s === !0 && u.push("secure"), Z.isString(l) && u.push(`SameSite=${l}`), document.cookie = u.join("; ");
    },
    read(e) {
      if (typeof document > "u") return null;
      const t = document.cookie.match(new RegExp("(?:^|; )" + e + "=([^;]*)"));
      return t ? decodeURIComponent(t[1]) : null;
    },
    remove(e) {
      this.write(e, "", Date.now() - 864e5, "/");
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function QB(e) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e);
}
function JB(e, t) {
  return t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e;
}
function Ek(e, t, n) {
  let r = !QB(t);
  return e && (r || n == !1) ? JB(e, t) : t;
}
const hE = (e) => e instanceof Qt ? { ...e } : e;
function mo(e, t) {
  t = t || {};
  const n = {};
  function r(h, f, m, g) {
    return Z.isPlainObject(h) && Z.isPlainObject(f) ? Z.merge.call({ caseless: g }, h, f) : Z.isPlainObject(f) ? Z.merge({}, f) : Z.isArray(f) ? f.slice() : f;
  }
  function i(h, f, m, g) {
    if (Z.isUndefined(f)) {
      if (!Z.isUndefined(h))
        return r(void 0, h, m, g);
    } else return r(h, f, m, g);
  }
  function s(h, f) {
    if (!Z.isUndefined(f))
      return r(void 0, f);
  }
  function l(h, f) {
    if (Z.isUndefined(f)) {
      if (!Z.isUndefined(h))
        return r(void 0, h);
    } else return r(void 0, f);
  }
  function u(h, f, m) {
    if (m in t)
      return r(h, f);
    if (m in e)
      return r(void 0, h);
  }
  const d = {
    url: s,
    method: s,
    data: s,
    baseURL: l,
    transformRequest: l,
    transformResponse: l,
    paramsSerializer: l,
    timeout: l,
    timeoutMessage: l,
    withCredentials: l,
    withXSRFToken: l,
    adapter: l,
    responseType: l,
    xsrfCookieName: l,
    xsrfHeaderName: l,
    onUploadProgress: l,
    onDownloadProgress: l,
    decompress: l,
    maxContentLength: l,
    maxBodyLength: l,
    beforeRedirect: l,
    transport: l,
    httpAgent: l,
    httpsAgent: l,
    cancelToken: l,
    socketPath: l,
    responseEncoding: l,
    validateStatus: u,
    headers: (h, f, m) => i(hE(h), hE(f), m, !0)
  };
  return Z.forEach(Object.keys({ ...e, ...t }), function(f) {
    const m = d[f] || i, g = m(e[f], t[f], f);
    Z.isUndefined(g) && m !== u || (n[f] = g);
  }), n;
}
const Ak = (e) => {
  const t = mo({}, e);
  let { data: n, withXSRFToken: r, xsrfHeaderName: i, xsrfCookieName: s, headers: l, auth: u } = t;
  if (t.headers = l = Qt.from(l), t.url = vk(Ek(t.baseURL, t.url, t.allowAbsoluteUrls), e.params, e.paramsSerializer), u && l.set(
    "Authorization",
    "Basic " + btoa((u.username || "") + ":" + (u.password ? unescape(encodeURIComponent(u.password)) : ""))
  ), Z.isFormData(n)) {
    if (Lt.hasStandardBrowserEnv || Lt.hasStandardBrowserWebWorkerEnv)
      l.setContentType(void 0);
    else if (Z.isFunction(n.getHeaders)) {
      const d = n.getHeaders(), h = ["content-type", "content-length"];
      Object.entries(d).forEach(([f, m]) => {
        h.includes(f.toLowerCase()) && l.set(f, m);
      });
    }
  }
  if (Lt.hasStandardBrowserEnv && (r && Z.isFunction(r) && (r = r(t)), r || r !== !1 && XB(t.url))) {
    const d = i && s && ZB.read(s);
    d && l.set(i, d);
  }
  return t;
}, e3 = typeof XMLHttpRequest < "u", t3 = e3 && function(e) {
  return new Promise(function(n, r) {
    const i = Ak(e);
    let s = i.data;
    const l = Qt.from(i.headers).normalize();
    let { responseType: u, onUploadProgress: d, onDownloadProgress: h } = i, f, m, g, w, E;
    function b() {
      w && w(), E && E(), i.cancelToken && i.cancelToken.unsubscribe(f), i.signal && i.signal.removeEventListener("abort", f);
    }
    let A = new XMLHttpRequest();
    A.open(i.method.toUpperCase(), i.url, !0), A.timeout = i.timeout;
    function x() {
      if (!A)
        return;
      const _ = Qt.from(
        "getAllResponseHeaders" in A && A.getAllResponseHeaders()
      ), V = {
        data: !u || u === "text" || u === "json" ? A.responseText : A.response,
        status: A.status,
        statusText: A.statusText,
        headers: _,
        config: e,
        request: A
      };
      Ck(function(D) {
        n(D), b();
      }, function(D) {
        r(D), b();
      }, V), A = null;
    }
    "onloadend" in A ? A.onloadend = x : A.onreadystatechange = function() {
      !A || A.readyState !== 4 || A.status === 0 && !(A.responseURL && A.responseURL.indexOf("file:") === 0) || setTimeout(x);
    }, A.onabort = function() {
      A && (r(new _e("Request aborted", _e.ECONNABORTED, e, A)), A = null);
    }, A.onerror = function(L) {
      const V = L && L.message ? L.message : "Network Error", O = new _e(V, _e.ERR_NETWORK, e, A);
      O.event = L || null, r(O), A = null;
    }, A.ontimeout = function() {
      let L = i.timeout ? "timeout of " + i.timeout + "ms exceeded" : "timeout exceeded";
      const V = i.transitional || yk;
      i.timeoutErrorMessage && (L = i.timeoutErrorMessage), r(new _e(
        L,
        V.clarifyTimeoutError ? _e.ETIMEDOUT : _e.ECONNABORTED,
        e,
        A
      )), A = null;
    }, s === void 0 && l.setContentType(null), "setRequestHeader" in A && Z.forEach(l.toJSON(), function(L, V) {
      A.setRequestHeader(V, L);
    }), Z.isUndefined(i.withCredentials) || (A.withCredentials = !!i.withCredentials), u && u !== "json" && (A.responseType = i.responseType), h && ([g, E] = kd(h, !0), A.addEventListener("progress", g)), d && A.upload && ([m, w] = kd(d), A.upload.addEventListener("progress", m), A.upload.addEventListener("loadend", w)), (i.cancelToken || i.signal) && (f = (_) => {
      A && (r(!_ || _.type ? new Ks(null, e, A) : _), A.abort(), A = null);
    }, i.cancelToken && i.cancelToken.subscribe(f), i.signal && (i.signal.aborted ? f() : i.signal.addEventListener("abort", f)));
    const R = GB(i.url);
    if (R && Lt.protocols.indexOf(R) === -1) {
      r(new _e("Unsupported protocol " + R + ":", _e.ERR_BAD_REQUEST, e));
      return;
    }
    A.send(s || null);
  });
}, n3 = (e, t) => {
  const { length: n } = e = e ? e.filter(Boolean) : [];
  if (t || n) {
    let r = new AbortController(), i;
    const s = function(h) {
      if (!i) {
        i = !0, u();
        const f = h instanceof Error ? h : this.reason;
        r.abort(f instanceof _e ? f : new Ks(f instanceof Error ? f.message : f));
      }
    };
    let l = t && setTimeout(() => {
      l = null, s(new _e(`timeout ${t} of ms exceeded`, _e.ETIMEDOUT));
    }, t);
    const u = () => {
      e && (l && clearTimeout(l), l = null, e.forEach((h) => {
        h.unsubscribe ? h.unsubscribe(s) : h.removeEventListener("abort", s);
      }), e = null);
    };
    e.forEach((h) => h.addEventListener("abort", s));
    const { signal: d } = r;
    return d.unsubscribe = () => Z.asap(u), d;
  }
}, r3 = function* (e, t) {
  let n = e.byteLength;
  if (n < t) {
    yield e;
    return;
  }
  let r = 0, i;
  for (; r < n; )
    i = r + t, yield e.slice(r, i), r = i;
}, i3 = async function* (e, t) {
  for await (const n of o3(e))
    yield* r3(n, t);
}, o3 = async function* (e) {
  if (e[Symbol.asyncIterator]) {
    yield* e;
    return;
  }
  const t = e.getReader();
  try {
    for (; ; ) {
      const { done: n, value: r } = await t.read();
      if (n)
        break;
      yield r;
    }
  } finally {
    await t.cancel();
  }
}, pE = (e, t, n, r) => {
  const i = i3(e, t);
  let s = 0, l, u = (d) => {
    l || (l = !0, r && r(d));
  };
  return new ReadableStream({
    async pull(d) {
      try {
        const { done: h, value: f } = await i.next();
        if (h) {
          u(), d.close();
          return;
        }
        let m = f.byteLength;
        if (n) {
          let g = s += m;
          n(g);
        }
        d.enqueue(new Uint8Array(f));
      } catch (h) {
        throw u(h), h;
      }
    },
    cancel(d) {
      return u(d), i.return();
    }
  }, {
    highWaterMark: 2
  });
}, mE = 64 * 1024, { isFunction: Nc } = Z, s3 = (({ Request: e, Response: t }) => ({
  Request: e,
  Response: t
}))(Z.global), {
  ReadableStream: gE,
  TextEncoder: vE
} = Z.global, yE = (e, ...t) => {
  try {
    return !!e(...t);
  } catch {
    return !1;
  }
}, a3 = (e) => {
  e = Z.merge.call({
    skipUndefined: !0
  }, s3, e);
  const { fetch: t, Request: n, Response: r } = e, i = t ? Nc(t) : typeof fetch == "function", s = Nc(n), l = Nc(r);
  if (!i)
    return !1;
  const u = i && Nc(gE), d = i && (typeof vE == "function" ? /* @__PURE__ */ ((E) => (b) => E.encode(b))(new vE()) : async (E) => new Uint8Array(await new n(E).arrayBuffer())), h = s && u && yE(() => {
    let E = !1;
    const b = new n(Lt.origin, {
      body: new gE(),
      method: "POST",
      get duplex() {
        return E = !0, "half";
      }
    }).headers.has("Content-Type");
    return E && !b;
  }), f = l && u && yE(() => Z.isReadableStream(new r("").body)), m = {
    stream: f && ((E) => E.body)
  };
  i && ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((E) => {
    !m[E] && (m[E] = (b, A) => {
      let x = b && b[E];
      if (x)
        return x.call(b);
      throw new _e(`Response type '${E}' is not supported`, _e.ERR_NOT_SUPPORT, A);
    });
  });
  const g = async (E) => {
    if (E == null)
      return 0;
    if (Z.isBlob(E))
      return E.size;
    if (Z.isSpecCompliantForm(E))
      return (await new n(Lt.origin, {
        method: "POST",
        body: E
      }).arrayBuffer()).byteLength;
    if (Z.isArrayBufferView(E) || Z.isArrayBuffer(E))
      return E.byteLength;
    if (Z.isURLSearchParams(E) && (E = E + ""), Z.isString(E))
      return (await d(E)).byteLength;
  }, w = async (E, b) => {
    const A = Z.toFiniteNumber(E.getContentLength());
    return A ?? g(b);
  };
  return async (E) => {
    let {
      url: b,
      method: A,
      data: x,
      signal: R,
      cancelToken: _,
      timeout: L,
      onDownloadProgress: V,
      onUploadProgress: O,
      responseType: D,
      headers: B,
      withCredentials: H = "same-origin",
      fetchOptions: J
    } = Ak(E), ce = t || fetch;
    D = D ? (D + "").toLowerCase() : "text";
    let fe = n3([R, _ && _.toAbortSignal()], L), de = null;
    const he = fe && fe.unsubscribe && (() => {
      fe.unsubscribe();
    });
    let le;
    try {
      if (O && h && A !== "get" && A !== "head" && (le = await w(B, x)) !== 0) {
        let $ = new n(b, {
          method: "POST",
          body: x,
          duplex: "half"
        }), M;
        if (Z.isFormData(x) && (M = $.headers.get("content-type")) && B.setContentType(M), $.body) {
          const [W, G] = dE(
            le,
            kd(fE(O))
          );
          x = pE($.body, mE, W, G);
        }
      }
      Z.isString(H) || (H = H ? "include" : "omit");
      const Y = s && "credentials" in n.prototype, te = {
        ...J,
        signal: fe,
        method: A.toUpperCase(),
        headers: B.normalize().toJSON(),
        body: x,
        duplex: "half",
        credentials: Y ? H : void 0
      };
      de = s && new n(b, te);
      let S = await (s ? ce(de, J) : ce(b, te));
      const T = f && (D === "stream" || D === "response");
      if (f && (V || T && he)) {
        const $ = {};
        ["status", "statusText", "headers"].forEach((ee) => {
          $[ee] = S[ee];
        });
        const M = Z.toFiniteNumber(S.headers.get("content-length")), [W, G] = V && dE(
          M,
          kd(fE(V), !0)
        ) || [];
        S = new r(
          pE(S.body, mE, W, () => {
            G && G(), he && he();
          }),
          $
        );
      }
      D = D || "text";
      let P = await m[Z.findKey(m, D) || "text"](S, E);
      return !T && he && he(), await new Promise(($, M) => {
        Ck($, M, {
          data: P,
          headers: Qt.from(S.headers),
          status: S.status,
          statusText: S.statusText,
          config: E,
          request: de
        });
      });
    } catch (Y) {
      throw he && he(), Y && Y.name === "TypeError" && /Load failed|fetch/i.test(Y.message) ? Object.assign(
        new _e("Network Error", _e.ERR_NETWORK, E, de),
        {
          cause: Y.cause || Y
        }
      ) : _e.from(Y, Y && Y.code, E, de);
    }
  };
}, l3 = /* @__PURE__ */ new Map(), xk = (e) => {
  let t = e && e.env || {};
  const { fetch: n, Request: r, Response: i } = t, s = [
    r,
    i,
    n
  ];
  let l = s.length, u = l, d, h, f = l3;
  for (; u--; )
    d = s[u], h = f.get(d), h === void 0 && f.set(d, h = u ? /* @__PURE__ */ new Map() : a3(t)), f = h;
  return h;
};
xk();
const zv = {
  http: SB,
  xhr: t3,
  fetch: {
    get: xk
  }
};
Z.forEach(zv, (e, t) => {
  if (e) {
    try {
      Object.defineProperty(e, "name", { value: t });
    } catch {
    }
    Object.defineProperty(e, "adapterName", { value: t });
  }
});
const wE = (e) => `- ${e}`, u3 = (e) => Z.isFunction(e) || e === null || e === !1;
function c3(e, t) {
  e = Z.isArray(e) ? e : [e];
  const { length: n } = e;
  let r, i;
  const s = {};
  for (let l = 0; l < n; l++) {
    r = e[l];
    let u;
    if (i = r, !u3(r) && (i = zv[(u = String(r)).toLowerCase()], i === void 0))
      throw new _e(`Unknown adapter '${u}'`);
    if (i && (Z.isFunction(i) || (i = i.get(t))))
      break;
    s[u || "#" + l] = i;
  }
  if (!i) {
    const l = Object.entries(s).map(
      ([d, h]) => `adapter ${d} ` + (h === !1 ? "is not supported by the environment" : "is not available in the build")
    );
    let u = n ? l.length > 1 ? `since :
` + l.map(wE).join(`
`) : " " + wE(l[0]) : "as no adapter specified";
    throw new _e(
      "There is no suitable adapter to dispatch the request " + u,
      "ERR_NOT_SUPPORT"
    );
  }
  return i;
}
const Sk = {
  /**
   * Resolve an adapter from a list of adapter names or functions.
   * @type {Function}
   */
  getAdapter: c3,
  /**
   * Exposes all known adapters
   * @type {Object<string, Function|Object>}
   */
  adapters: zv
};
function Hp(e) {
  if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted)
    throw new Ks(null, e);
}
function bE(e) {
  return Hp(e), e.headers = Qt.from(e.headers), e.data = zp.call(
    e,
    e.transformRequest
  ), ["post", "put", "patch"].indexOf(e.method) !== -1 && e.headers.setContentType("application/x-www-form-urlencoded", !1), Sk.getAdapter(e.adapter || lu.adapter, e)(e).then(function(r) {
    return Hp(e), r.data = zp.call(
      e,
      e.transformResponse,
      r
    ), r.headers = Qt.from(r.headers), r;
  }, function(r) {
    return bk(r) || (Hp(e), r && r.response && (r.response.data = zp.call(
      e,
      e.transformResponse,
      r.response
    ), r.response.headers = Qt.from(r.response.headers))), Promise.reject(r);
  });
}
const kk = "1.13.2", df = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((e, t) => {
  df[e] = function(r) {
    return typeof r === e || "a" + (t < 1 ? "n " : " ") + e;
  };
});
const CE = {};
df.transitional = function(t, n, r) {
  function i(s, l) {
    return "[Axios v" + kk + "] Transitional option '" + s + "'" + l + (r ? ". " + r : "");
  }
  return (s, l, u) => {
    if (t === !1)
      throw new _e(
        i(l, " has been removed" + (n ? " in " + n : "")),
        _e.ERR_DEPRECATED
      );
    return n && !CE[l] && (CE[l] = !0, console.warn(
      i(
        l,
        " has been deprecated since v" + n + " and will be removed in the near future"
      )
    )), t ? t(s, l, u) : !0;
  };
};
df.spelling = function(t) {
  return (n, r) => (console.warn(`${r} is likely a misspelling of ${t}`), !0);
};
function d3(e, t, n) {
  if (typeof e != "object")
    throw new _e("options must be an object", _e.ERR_BAD_OPTION_VALUE);
  const r = Object.keys(e);
  let i = r.length;
  for (; i-- > 0; ) {
    const s = r[i], l = t[s];
    if (l) {
      const u = e[s], d = u === void 0 || l(u, s, e);
      if (d !== !0)
        throw new _e("option " + s + " must be " + d, _e.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (n !== !0)
      throw new _e("Unknown option " + s, _e.ERR_BAD_OPTION);
  }
}
const ld = {
  assertOptions: d3,
  validators: df
}, rr = ld.validators;
let ro = class {
  constructor(t) {
    this.defaults = t || {}, this.interceptors = {
      request: new uE(),
      response: new uE()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(t, n) {
    try {
      return await this._request(t, n);
    } catch (r) {
      if (r instanceof Error) {
        let i = {};
        Error.captureStackTrace ? Error.captureStackTrace(i) : i = new Error();
        const s = i.stack ? i.stack.replace(/^.+\n/, "") : "";
        try {
          r.stack ? s && !String(r.stack).endsWith(s.replace(/^.+\n.+\n/, "")) && (r.stack += `
` + s) : r.stack = s;
        } catch {
        }
      }
      throw r;
    }
  }
  _request(t, n) {
    typeof t == "string" ? (n = n || {}, n.url = t) : n = t || {}, n = mo(this.defaults, n);
    const { transitional: r, paramsSerializer: i, headers: s } = n;
    r !== void 0 && ld.assertOptions(r, {
      silentJSONParsing: rr.transitional(rr.boolean),
      forcedJSONParsing: rr.transitional(rr.boolean),
      clarifyTimeoutError: rr.transitional(rr.boolean)
    }, !1), i != null && (Z.isFunction(i) ? n.paramsSerializer = {
      serialize: i
    } : ld.assertOptions(i, {
      encode: rr.function,
      serialize: rr.function
    }, !0)), n.allowAbsoluteUrls !== void 0 || (this.defaults.allowAbsoluteUrls !== void 0 ? n.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : n.allowAbsoluteUrls = !0), ld.assertOptions(n, {
      baseUrl: rr.spelling("baseURL"),
      withXsrfToken: rr.spelling("withXSRFToken")
    }, !0), n.method = (n.method || this.defaults.method || "get").toLowerCase();
    let l = s && Z.merge(
      s.common,
      s[n.method]
    );
    s && Z.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (E) => {
        delete s[E];
      }
    ), n.headers = Qt.concat(l, s);
    const u = [];
    let d = !0;
    this.interceptors.request.forEach(function(b) {
      typeof b.runWhen == "function" && b.runWhen(n) === !1 || (d = d && b.synchronous, u.unshift(b.fulfilled, b.rejected));
    });
    const h = [];
    this.interceptors.response.forEach(function(b) {
      h.push(b.fulfilled, b.rejected);
    });
    let f, m = 0, g;
    if (!d) {
      const E = [bE.bind(this), void 0];
      for (E.unshift(...u), E.push(...h), g = E.length, f = Promise.resolve(n); m < g; )
        f = f.then(E[m++], E[m++]);
      return f;
    }
    g = u.length;
    let w = n;
    for (; m < g; ) {
      const E = u[m++], b = u[m++];
      try {
        w = E(w);
      } catch (A) {
        b.call(this, A);
        break;
      }
    }
    try {
      f = bE.call(this, w);
    } catch (E) {
      return Promise.reject(E);
    }
    for (m = 0, g = h.length; m < g; )
      f = f.then(h[m++], h[m++]);
    return f;
  }
  getUri(t) {
    t = mo(this.defaults, t);
    const n = Ek(t.baseURL, t.url, t.allowAbsoluteUrls);
    return vk(n, t.params, t.paramsSerializer);
  }
};
Z.forEach(["delete", "get", "head", "options"], function(t) {
  ro.prototype[t] = function(n, r) {
    return this.request(mo(r || {}, {
      method: t,
      url: n,
      data: (r || {}).data
    }));
  };
});
Z.forEach(["post", "put", "patch"], function(t) {
  function n(r) {
    return function(s, l, u) {
      return this.request(mo(u || {}, {
        method: t,
        headers: r ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: s,
        data: l
      }));
    };
  }
  ro.prototype[t] = n(), ro.prototype[t + "Form"] = n(!0);
});
let f3 = class Rk {
  constructor(t) {
    if (typeof t != "function")
      throw new TypeError("executor must be a function.");
    let n;
    this.promise = new Promise(function(s) {
      n = s;
    });
    const r = this;
    this.promise.then((i) => {
      if (!r._listeners) return;
      let s = r._listeners.length;
      for (; s-- > 0; )
        r._listeners[s](i);
      r._listeners = null;
    }), this.promise.then = (i) => {
      let s;
      const l = new Promise((u) => {
        r.subscribe(u), s = u;
      }).then(i);
      return l.cancel = function() {
        r.unsubscribe(s);
      }, l;
    }, t(function(s, l, u) {
      r.reason || (r.reason = new Ks(s, l, u), n(r.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(t) {
    if (this.reason) {
      t(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(t) : this._listeners = [t];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(t) {
    if (!this._listeners)
      return;
    const n = this._listeners.indexOf(t);
    n !== -1 && this._listeners.splice(n, 1);
  }
  toAbortSignal() {
    const t = new AbortController(), n = (r) => {
      t.abort(r);
    };
    return this.subscribe(n), t.signal.unsubscribe = () => this.unsubscribe(n), t.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let t;
    return {
      token: new Rk(function(i) {
        t = i;
      }),
      cancel: t
    };
  }
};
function h3(e) {
  return function(n) {
    return e.apply(null, n);
  };
}
function p3(e) {
  return Z.isObject(e) && e.isAxiosError === !0;
}
const qm = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511,
  WebServerIsDown: 521,
  ConnectionTimedOut: 522,
  OriginIsUnreachable: 523,
  TimeoutOccurred: 524,
  SslHandshakeFailed: 525,
  InvalidSslCertificate: 526
};
Object.entries(qm).forEach(([e, t]) => {
  qm[t] = e;
});
function Tk(e) {
  const t = new ro(e), n = ok(ro.prototype.request, t);
  return Z.extend(n, ro.prototype, t, { allOwnKeys: !0 }), Z.extend(n, t, null, { allOwnKeys: !0 }), n.create = function(i) {
    return Tk(mo(e, i));
  }, n;
}
const lt = Tk(lu);
lt.Axios = ro;
lt.CanceledError = Ks;
lt.CancelToken = f3;
lt.isCancel = bk;
lt.VERSION = kk;
lt.toFormData = cf;
lt.AxiosError = _e;
lt.Cancel = lt.CanceledError;
lt.all = function(t) {
  return Promise.all(t);
};
lt.spread = h3;
lt.isAxiosError = p3;
lt.mergeConfig = mo;
lt.AxiosHeaders = Qt;
lt.formToJSON = (e) => wk(Z.isHTMLForm(e) ? new FormData(e) : e);
lt.getAdapter = Sk.getAdapter;
lt.HttpStatusCode = qm;
lt.default = lt;
const {
  Axios: xre,
  AxiosError: Sre,
  CanceledError: kre,
  isCancel: Rre,
  CancelToken: Tre,
  VERSION: $re,
  all: Vre,
  Cancel: _re,
  isAxiosError: Ire,
  spread: Lre,
  toFormData: Pre,
  AxiosHeaders: Mre,
  HttpStatusCode: Ore,
  formToJSON: Bre,
  getAdapter: Nre,
  mergeConfig: Dre
} = lt;
var Kp, EE;
function m3() {
  if (EE) return Kp;
  EE = 1;
  const e = /* @__PURE__ */ new Set([
    "ENOTFOUND",
    "ENETUNREACH",
    // SSL errors from https://github.com/nodejs/node/blob/fc8e3e2cdc521978351de257030db0076d79e0ab/src/crypto/crypto_common.cc#L301-L328
    "UNABLE_TO_GET_ISSUER_CERT",
    "UNABLE_TO_GET_CRL",
    "UNABLE_TO_DECRYPT_CERT_SIGNATURE",
    "UNABLE_TO_DECRYPT_CRL_SIGNATURE",
    "UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY",
    "CERT_SIGNATURE_FAILURE",
    "CRL_SIGNATURE_FAILURE",
    "CERT_NOT_YET_VALID",
    "CERT_HAS_EXPIRED",
    "CRL_NOT_YET_VALID",
    "CRL_HAS_EXPIRED",
    "ERROR_IN_CERT_NOT_BEFORE_FIELD",
    "ERROR_IN_CERT_NOT_AFTER_FIELD",
    "ERROR_IN_CRL_LAST_UPDATE_FIELD",
    "ERROR_IN_CRL_NEXT_UPDATE_FIELD",
    "OUT_OF_MEM",
    "DEPTH_ZERO_SELF_SIGNED_CERT",
    "SELF_SIGNED_CERT_IN_CHAIN",
    "UNABLE_TO_GET_ISSUER_CERT_LOCALLY",
    "UNABLE_TO_VERIFY_LEAF_SIGNATURE",
    "CERT_CHAIN_TOO_LONG",
    "CERT_REVOKED",
    "INVALID_CA",
    "PATH_LENGTH_EXCEEDED",
    "INVALID_PURPOSE",
    "CERT_UNTRUSTED",
    "CERT_REJECTED",
    "HOSTNAME_MISMATCH"
  ]);
  return Kp = (t) => !e.has(t && t.code), Kp;
}
var g3 = m3();
const v3 = /* @__PURE__ */ ru(g3), Hv = "axios-retry";
function $k(e) {
  const t = ["ERR_CANCELED", "ECONNABORTED"];
  return e.response || !e.code || t.includes(e.code) ? !1 : v3(e);
}
const Vk = ["get", "head", "options"], y3 = Vk.concat(["put", "delete"]);
function Kv(e) {
  return e.code !== "ECONNABORTED" && (!e.response || e.response.status === 429 || e.response.status >= 500 && e.response.status <= 599);
}
function w3(e) {
  var t;
  return (t = e.config) != null && t.method ? Kv(e) && Vk.indexOf(e.config.method) !== -1 : !1;
}
function _k(e) {
  var t;
  return (t = e.config) != null && t.method ? Kv(e) && y3.indexOf(e.config.method) !== -1 : !1;
}
function Ik(e) {
  return $k(e) || _k(e);
}
function Gv(e = void 0) {
  var r;
  const t = (r = e == null ? void 0 : e.response) == null ? void 0 : r.headers["retry-after"];
  if (!t)
    return 0;
  let n = (Number(t) || 0) * 1e3;
  return n === 0 && (n = (new Date(t).valueOf() || 0) - Date.now()), Math.max(0, n);
}
function b3(e = 0, t = void 0) {
  return Math.max(0, Gv(t));
}
function C3(e = 0, t = void 0, n = 100) {
  const r = 2 ** e * n, i = Math.max(r, Gv(t)), s = i * 0.2 * Math.random();
  return i + s;
}
function E3(e = 100) {
  return (t = 0, n = void 0) => {
    const r = t * e;
    return Math.max(r, Gv(n));
  };
}
const A3 = {
  retries: 3,
  retryCondition: Ik,
  retryDelay: b3,
  shouldResetTimeout: !1,
  onRetry: () => {
  },
  onMaxRetryTimesExceeded: () => {
  },
  validateResponse: null
};
function x3(e, t) {
  return { ...A3, ...t, ...e[Hv] };
}
function AE(e, t, n = !1) {
  const r = x3(e, t || {});
  return r.retryCount = r.retryCount || 0, (!r.lastRequestTime || n) && (r.lastRequestTime = Date.now()), e[Hv] = r, r;
}
function S3(e, t) {
  e.defaults.agent === t.agent && delete t.agent, e.defaults.httpAgent === t.httpAgent && delete t.httpAgent, e.defaults.httpsAgent === t.httpsAgent && delete t.httpsAgent;
}
async function k3(e, t) {
  const { retries: n, retryCondition: r } = e, i = (e.retryCount || 0) < n && r(t);
  if (typeof i == "object")
    try {
      return await i !== !1;
    } catch {
      return !1;
    }
  return i;
}
async function R3(e, t, n, r) {
  var d;
  t.retryCount += 1;
  const { retryDelay: i, shouldResetTimeout: s, onRetry: l } = t, u = i(t.retryCount, n);
  if (S3(e, r), !s && r.timeout && t.lastRequestTime) {
    const h = Date.now() - t.lastRequestTime, f = r.timeout - h - u;
    if (f <= 0)
      return Promise.reject(n);
    r.timeout = f;
  }
  return r.transformRequest = [(h) => h], await l(t.retryCount, n, r), (d = r.signal) != null && d.aborted ? Promise.resolve(e(r)) : new Promise((h) => {
    var g;
    const f = () => {
      clearTimeout(m), h(e(r));
    }, m = setTimeout(() => {
      var w;
      h(e(r)), (w = r.signal) != null && w.removeEventListener && r.signal.removeEventListener("abort", f);
    }, u);
    (g = r.signal) != null && g.addEventListener && r.signal.addEventListener("abort", f, { once: !0 });
  });
}
async function T3(e, t) {
  e.retryCount >= e.retries && await e.onMaxRetryTimesExceeded(t, e.retryCount);
}
const cr = (e, t) => {
  const n = e.interceptors.request.use((i) => {
    var s;
    return AE(i, t, !0), (s = i[Hv]) != null && s.validateResponse && (i.validateStatus = () => !1), i;
  }), r = e.interceptors.response.use(null, async (i) => {
    var u;
    const { config: s } = i;
    if (!s)
      return Promise.reject(i);
    const l = AE(s, t);
    return i.response && ((u = l.validateResponse) != null && u.call(l, i.response)) ? i.response : await k3(l, i) ? R3(e, l, i, s) : (await T3(l, i), Promise.reject(i));
  });
  return { requestInterceptorId: n, responseInterceptorId: r };
};
cr.isNetworkError = $k;
cr.isSafeRequestError = w3;
cr.isIdempotentRequestError = _k;
cr.isNetworkOrIdempotentRequestError = Ik;
cr.exponentialDelay = C3;
cr.linearDelay = E3;
cr.isRetryableError = Kv;
var xl = (e) => typeof e == "function" ? e : function() {
  return e;
}, $3 = typeof self < "u" ? self : null, gl = typeof window < "u" ? window : null, io = $3 || gl || io, V3 = "2.0.0", ar = { connecting: 0, open: 1, closing: 2, closed: 3 }, _3 = 1e4, I3 = 1e3, ln = {
  closed: "closed",
  errored: "errored",
  joined: "joined",
  joining: "joining",
  leaving: "leaving"
}, xr = {
  close: "phx_close",
  error: "phx_error",
  join: "phx_join",
  reply: "phx_reply",
  leave: "phx_leave"
}, Xm = {
  longpoll: "longpoll",
  websocket: "websocket"
}, L3 = {
  complete: 4
}, Dc = class {
  constructor(e, t, n, r) {
    this.channel = e, this.event = t, this.payload = n || function() {
      return {};
    }, this.receivedResp = null, this.timeout = r, this.timeoutTimer = null, this.recHooks = [], this.sent = !1;
  }
  /**
   *
   * @param {number} timeout
   */
  resend(e) {
    this.timeout = e, this.reset(), this.send();
  }
  /**
   *
   */
  send() {
    this.hasReceived("timeout") || (this.startTimeout(), this.sent = !0, this.channel.socket.push({
      topic: this.channel.topic,
      event: this.event,
      payload: this.payload(),
      ref: this.ref,
      join_ref: this.channel.joinRef()
    }));
  }
  /**
   *
   * @param {*} status
   * @param {*} callback
   */
  receive(e, t) {
    return this.hasReceived(e) && t(this.receivedResp.response), this.recHooks.push({ status: e, callback: t }), this;
  }
  /**
   * @private
   */
  reset() {
    this.cancelRefEvent(), this.ref = null, this.refEvent = null, this.receivedResp = null, this.sent = !1;
  }
  /**
   * @private
   */
  matchReceive({ status: e, response: t, _ref: n }) {
    this.recHooks.filter((r) => r.status === e).forEach((r) => r.callback(t));
  }
  /**
   * @private
   */
  cancelRefEvent() {
    this.refEvent && this.channel.off(this.refEvent);
  }
  /**
   * @private
   */
  cancelTimeout() {
    clearTimeout(this.timeoutTimer), this.timeoutTimer = null;
  }
  /**
   * @private
   */
  startTimeout() {
    this.timeoutTimer && this.cancelTimeout(), this.ref = this.channel.socket.makeRef(), this.refEvent = this.channel.replyEventName(this.ref), this.channel.on(this.refEvent, (e) => {
      this.cancelRefEvent(), this.cancelTimeout(), this.receivedResp = e, this.matchReceive(e);
    }), this.timeoutTimer = setTimeout(() => {
      this.trigger("timeout", {});
    }, this.timeout);
  }
  /**
   * @private
   */
  hasReceived(e) {
    return this.receivedResp && this.receivedResp.status === e;
  }
  /**
   * @private
   */
  trigger(e, t) {
    this.channel.trigger(this.refEvent, { status: e, response: t });
  }
}, Lk = class {
  constructor(e, t) {
    this.callback = e, this.timerCalc = t, this.timer = null, this.tries = 0;
  }
  reset() {
    this.tries = 0, clearTimeout(this.timer);
  }
  /**
   * Cancels any previous scheduleTimeout and schedules callback
   */
  scheduleTimeout() {
    clearTimeout(this.timer), this.timer = setTimeout(() => {
      this.tries = this.tries + 1, this.callback();
    }, this.timerCalc(this.tries + 1));
  }
}, P3 = class {
  constructor(e, t, n) {
    this.state = ln.closed, this.topic = e, this.params = xl(t || {}), this.socket = n, this.bindings = [], this.bindingRef = 0, this.timeout = this.socket.timeout, this.joinedOnce = !1, this.joinPush = new Dc(this, xr.join, this.params, this.timeout), this.pushBuffer = [], this.stateChangeRefs = [], this.rejoinTimer = new Lk(() => {
      this.socket.isConnected() && this.rejoin();
    }, this.socket.rejoinAfterMs), this.stateChangeRefs.push(this.socket.onError(() => this.rejoinTimer.reset())), this.stateChangeRefs.push(
      this.socket.onOpen(() => {
        this.rejoinTimer.reset(), this.isErrored() && this.rejoin();
      })
    ), this.joinPush.receive("ok", () => {
      this.state = ln.joined, this.rejoinTimer.reset(), this.pushBuffer.forEach((r) => r.send()), this.pushBuffer = [];
    }), this.joinPush.receive("error", () => {
      this.state = ln.errored, this.socket.isConnected() && this.rejoinTimer.scheduleTimeout();
    }), this.onClose(() => {
      this.rejoinTimer.reset(), this.socket.hasLogger() && this.socket.log("channel", `close ${this.topic} ${this.joinRef()}`), this.state = ln.closed, this.socket.remove(this);
    }), this.onError((r) => {
      this.socket.hasLogger() && this.socket.log("channel", `error ${this.topic}`, r), this.isJoining() && this.joinPush.reset(), this.state = ln.errored, this.socket.isConnected() && this.rejoinTimer.scheduleTimeout();
    }), this.joinPush.receive("timeout", () => {
      this.socket.hasLogger() && this.socket.log("channel", `timeout ${this.topic} (${this.joinRef()})`, this.joinPush.timeout), new Dc(this, xr.leave, xl({}), this.timeout).send(), this.state = ln.errored, this.joinPush.reset(), this.socket.isConnected() && this.rejoinTimer.scheduleTimeout();
    }), this.on(xr.reply, (r, i) => {
      this.trigger(this.replyEventName(i), r);
    });
  }
  /**
   * Join the channel
   * @param {integer} timeout
   * @returns {Push}
   */
  join(e = this.timeout) {
    if (this.joinedOnce)
      throw new Error("tried to join multiple times. 'join' can only be called a single time per channel instance");
    return this.timeout = e, this.joinedOnce = !0, this.rejoin(), this.joinPush;
  }
  /**
   * Hook into channel close
   * @param {Function} callback
   */
  onClose(e) {
    this.on(xr.close, e);
  }
  /**
   * Hook into channel errors
   * @param {Function} callback
   */
  onError(e) {
    return this.on(xr.error, (t) => e(t));
  }
  /**
   * Subscribes on channel events
   *
   * Subscription returns a ref counter, which can be used later to
   * unsubscribe the exact event listener
   *
   * @example
   * const ref1 = channel.on("event", do_stuff)
   * const ref2 = channel.on("event", do_other_stuff)
   * channel.off("event", ref1)
   * // Since unsubscription, do_stuff won't fire,
   * // while do_other_stuff will keep firing on the "event"
   *
   * @param {string} event
   * @param {Function} callback
   * @returns {integer} ref
   */
  on(e, t) {
    let n = this.bindingRef++;
    return this.bindings.push({ event: e, ref: n, callback: t }), n;
  }
  /**
   * Unsubscribes off of channel events
   *
   * Use the ref returned from a channel.on() to unsubscribe one
   * handler, or pass nothing for the ref to unsubscribe all
   * handlers for the given event.
   *
   * @example
   * // Unsubscribe the do_stuff handler
   * const ref1 = channel.on("event", do_stuff)
   * channel.off("event", ref1)
   *
   * // Unsubscribe all handlers from event
   * channel.off("event")
   *
   * @param {string} event
   * @param {integer} ref
   */
  off(e, t) {
    this.bindings = this.bindings.filter((n) => !(n.event === e && (typeof t > "u" || t === n.ref)));
  }
  /**
   * @private
   */
  canPush() {
    return this.socket.isConnected() && this.isJoined();
  }
  /**
   * Sends a message `event` to phoenix with the payload `payload`.
   * Phoenix receives this in the `handle_in(event, payload, socket)`
   * function. if phoenix replies or it times out (default 10000ms),
   * then optionally the reply can be received.
   *
   * @example
   * channel.push("event")
   *   .receive("ok", payload => console.log("phoenix replied:", payload))
   *   .receive("error", err => console.log("phoenix errored", err))
   *   .receive("timeout", () => console.log("timed out pushing"))
   * @param {string} event
   * @param {Object} payload
   * @param {number} [timeout]
   * @returns {Push}
   */
  push(e, t, n = this.timeout) {
    if (t = t || {}, !this.joinedOnce)
      throw new Error(`tried to push '${e}' to '${this.topic}' before joining. Use channel.join() before pushing events`);
    let r = new Dc(this, e, function() {
      return t;
    }, n);
    return this.canPush() ? r.send() : (r.startTimeout(), this.pushBuffer.push(r)), r;
  }
  /** Leaves the channel
   *
   * Unsubscribes from server events, and
   * instructs channel to terminate on server
   *
   * Triggers onClose() hooks
   *
   * To receive leave acknowledgements, use the `receive`
   * hook to bind to the server ack, ie:
   *
   * @example
   * channel.leave().receive("ok", () => alert("left!") )
   *
   * @param {integer} timeout
   * @returns {Push}
   */
  leave(e = this.timeout) {
    this.rejoinTimer.reset(), this.joinPush.cancelTimeout(), this.state = ln.leaving;
    let t = () => {
      this.socket.hasLogger() && this.socket.log("channel", `leave ${this.topic}`), this.trigger(xr.close, "leave");
    }, n = new Dc(this, xr.leave, xl({}), e);
    return n.receive("ok", () => t()).receive("timeout", () => t()), n.send(), this.canPush() || n.trigger("ok", {}), n;
  }
  /**
   * Overridable message hook
   *
   * Receives all events for specialized message handling
   * before dispatching to the channel callbacks.
   *
   * Must return the payload, modified or unmodified
   * @param {string} event
   * @param {Object} payload
   * @param {integer} ref
   * @returns {Object}
   */
  onMessage(e, t, n) {
    return t;
  }
  /**
   * @private
   */
  isMember(e, t, n, r) {
    return this.topic !== e ? !1 : r && r !== this.joinRef() ? (this.socket.hasLogger() && this.socket.log("channel", "dropping outdated message", { topic: e, event: t, payload: n, joinRef: r }), !1) : !0;
  }
  /**
   * @private
   */
  joinRef() {
    return this.joinPush.ref;
  }
  /**
   * @private
   */
  rejoin(e = this.timeout) {
    this.isLeaving() || (this.socket.leaveOpenTopic(this.topic), this.state = ln.joining, this.joinPush.resend(e));
  }
  /**
   * @private
   */
  trigger(e, t, n, r) {
    let i = this.onMessage(e, t, n, r);
    if (t && !i)
      throw new Error("channel onMessage callbacks must return the payload, modified or unmodified");
    let s = this.bindings.filter((l) => l.event === e);
    for (let l = 0; l < s.length; l++)
      s[l].callback(i, n, r || this.joinRef());
  }
  /**
   * @private
   */
  replyEventName(e) {
    return `chan_reply_${e}`;
  }
  /**
   * @private
   */
  isClosed() {
    return this.state === ln.closed;
  }
  /**
   * @private
   */
  isErrored() {
    return this.state === ln.errored;
  }
  /**
   * @private
   */
  isJoined() {
    return this.state === ln.joined;
  }
  /**
   * @private
   */
  isJoining() {
    return this.state === ln.joining;
  }
  /**
   * @private
   */
  isLeaving() {
    return this.state === ln.leaving;
  }
}, Rd = class {
  static request(e, t, n, r, i, s, l) {
    if (io.XDomainRequest) {
      let u = new io.XDomainRequest();
      return this.xdomainRequest(u, e, t, r, i, s, l);
    } else {
      let u = new io.XMLHttpRequest();
      return this.xhrRequest(u, e, t, n, r, i, s, l);
    }
  }
  static xdomainRequest(e, t, n, r, i, s, l) {
    return e.timeout = i, e.open(t, n), e.onload = () => {
      let u = this.parseJSON(e.responseText);
      l && l(u);
    }, s && (e.ontimeout = s), e.onprogress = () => {
    }, e.send(r), e;
  }
  static xhrRequest(e, t, n, r, i, s, l, u) {
    return e.open(t, n, !0), e.timeout = s, e.setRequestHeader("Content-Type", r), e.onerror = () => u && u(null), e.onreadystatechange = () => {
      if (e.readyState === L3.complete && u) {
        let d = this.parseJSON(e.responseText);
        u(d);
      }
    }, l && (e.ontimeout = l), e.send(i), e;
  }
  static parseJSON(e) {
    if (!e || e === "")
      return null;
    try {
      return JSON.parse(e);
    } catch {
      return console && console.log("failed to parse JSON response", e), null;
    }
  }
  static serialize(e, t) {
    let n = [];
    for (var r in e) {
      if (!Object.prototype.hasOwnProperty.call(e, r))
        continue;
      let i = t ? `${t}[${r}]` : r, s = e[r];
      typeof s == "object" ? n.push(this.serialize(s, i)) : n.push(encodeURIComponent(i) + "=" + encodeURIComponent(s));
    }
    return n.join("&");
  }
  static appendParams(e, t) {
    if (Object.keys(t).length === 0)
      return e;
    let n = e.match(/\?/) ? "&" : "?";
    return `${e}${n}${this.serialize(t)}`;
  }
}, M3 = (e) => {
  let t = "", n = new Uint8Array(e), r = n.byteLength;
  for (let i = 0; i < r; i++)
    t += String.fromCharCode(n[i]);
  return btoa(t);
}, fl = class {
  constructor(e) {
    this.endPoint = null, this.token = null, this.skipHeartbeat = !0, this.reqs = /* @__PURE__ */ new Set(), this.awaitingBatchAck = !1, this.currentBatch = null, this.currentBatchTimer = null, this.batchBuffer = [], this.onopen = function() {
    }, this.onerror = function() {
    }, this.onmessage = function() {
    }, this.onclose = function() {
    }, this.pollEndpoint = this.normalizeEndpoint(e), this.readyState = ar.connecting, setTimeout(() => this.poll(), 0);
  }
  normalizeEndpoint(e) {
    return e.replace("ws://", "http://").replace("wss://", "https://").replace(new RegExp("(.*)/" + Xm.websocket), "$1/" + Xm.longpoll);
  }
  endpointURL() {
    return Rd.appendParams(this.pollEndpoint, { token: this.token });
  }
  closeAndRetry(e, t, n) {
    this.close(e, t, n), this.readyState = ar.connecting;
  }
  ontimeout() {
    this.onerror("timeout"), this.closeAndRetry(1005, "timeout", !1);
  }
  isActive() {
    return this.readyState === ar.open || this.readyState === ar.connecting;
  }
  poll() {
    this.ajax("GET", "application/json", null, () => this.ontimeout(), (e) => {
      if (e) {
        var { status: t, token: n, messages: r } = e;
        this.token = n;
      } else
        t = 0;
      switch (t) {
        case 200:
          r.forEach((i) => {
            setTimeout(() => this.onmessage({ data: i }), 0);
          }), this.poll();
          break;
        case 204:
          this.poll();
          break;
        case 410:
          this.readyState = ar.open, this.onopen({}), this.poll();
          break;
        case 403:
          this.onerror(403), this.close(1008, "forbidden", !1);
          break;
        case 0:
        case 500:
          this.onerror(500), this.closeAndRetry(1011, "internal server error", 500);
          break;
        default:
          throw new Error(`unhandled poll status ${t}`);
      }
    });
  }
  // we collect all pushes within the current event loop by
  // setTimeout 0, which optimizes back-to-back procedural
  // pushes against an empty buffer
  send(e) {
    typeof e != "string" && (e = M3(e)), this.currentBatch ? this.currentBatch.push(e) : this.awaitingBatchAck ? this.batchBuffer.push(e) : (this.currentBatch = [e], this.currentBatchTimer = setTimeout(() => {
      this.batchSend(this.currentBatch), this.currentBatch = null;
    }, 0));
  }
  batchSend(e) {
    this.awaitingBatchAck = !0, this.ajax("POST", "application/x-ndjson", e.join(`
`), () => this.onerror("timeout"), (t) => {
      this.awaitingBatchAck = !1, !t || t.status !== 200 ? (this.onerror(t && t.status), this.closeAndRetry(1011, "internal server error", !1)) : this.batchBuffer.length > 0 && (this.batchSend(this.batchBuffer), this.batchBuffer = []);
    });
  }
  close(e, t, n) {
    for (let i of this.reqs)
      i.abort();
    this.readyState = ar.closed;
    let r = Object.assign({ code: 1e3, reason: void 0, wasClean: !0 }, { code: e, reason: t, wasClean: n });
    this.batchBuffer = [], clearTimeout(this.currentBatchTimer), this.currentBatchTimer = null, typeof CloseEvent < "u" ? this.onclose(new CloseEvent("close", r)) : this.onclose(r);
  }
  ajax(e, t, n, r, i) {
    let s, l = () => {
      this.reqs.delete(s), r();
    };
    s = Rd.request(e, this.endpointURL(), t, n, this.timeout, l, (u) => {
      this.reqs.delete(s), this.isActive() && i(u);
    }), this.reqs.add(s);
  }
}, jc = {
  HEADER_LENGTH: 1,
  META_LENGTH: 4,
  KINDS: { push: 0, reply: 1, broadcast: 2 },
  encode(e, t) {
    if (e.payload.constructor === ArrayBuffer)
      return t(this.binaryEncode(e));
    {
      let n = [e.join_ref, e.ref, e.topic, e.event, e.payload];
      return t(JSON.stringify(n));
    }
  },
  decode(e, t) {
    if (e.constructor === ArrayBuffer)
      return t(this.binaryDecode(e));
    {
      let [n, r, i, s, l] = JSON.parse(e);
      return t({ join_ref: n, ref: r, topic: i, event: s, payload: l });
    }
  },
  // private
  binaryEncode(e) {
    let { join_ref: t, ref: n, event: r, topic: i, payload: s } = e, l = this.META_LENGTH + t.length + n.length + i.length + r.length, u = new ArrayBuffer(this.HEADER_LENGTH + l), d = new DataView(u), h = 0;
    d.setUint8(h++, this.KINDS.push), d.setUint8(h++, t.length), d.setUint8(h++, n.length), d.setUint8(h++, i.length), d.setUint8(h++, r.length), Array.from(t, (m) => d.setUint8(h++, m.charCodeAt(0))), Array.from(n, (m) => d.setUint8(h++, m.charCodeAt(0))), Array.from(i, (m) => d.setUint8(h++, m.charCodeAt(0))), Array.from(r, (m) => d.setUint8(h++, m.charCodeAt(0)));
    var f = new Uint8Array(u.byteLength + s.byteLength);
    return f.set(new Uint8Array(u), 0), f.set(new Uint8Array(s), u.byteLength), f.buffer;
  },
  binaryDecode(e) {
    let t = new DataView(e), n = t.getUint8(0), r = new TextDecoder();
    switch (n) {
      case this.KINDS.push:
        return this.decodePush(e, t, r);
      case this.KINDS.reply:
        return this.decodeReply(e, t, r);
      case this.KINDS.broadcast:
        return this.decodeBroadcast(e, t, r);
    }
  },
  decodePush(e, t, n) {
    let r = t.getUint8(1), i = t.getUint8(2), s = t.getUint8(3), l = this.HEADER_LENGTH + this.META_LENGTH - 1, u = n.decode(e.slice(l, l + r));
    l = l + r;
    let d = n.decode(e.slice(l, l + i));
    l = l + i;
    let h = n.decode(e.slice(l, l + s));
    l = l + s;
    let f = e.slice(l, e.byteLength);
    return { join_ref: u, ref: null, topic: d, event: h, payload: f };
  },
  decodeReply(e, t, n) {
    let r = t.getUint8(1), i = t.getUint8(2), s = t.getUint8(3), l = t.getUint8(4), u = this.HEADER_LENGTH + this.META_LENGTH, d = n.decode(e.slice(u, u + r));
    u = u + r;
    let h = n.decode(e.slice(u, u + i));
    u = u + i;
    let f = n.decode(e.slice(u, u + s));
    u = u + s;
    let m = n.decode(e.slice(u, u + l));
    u = u + l;
    let g = e.slice(u, e.byteLength), w = { status: m, response: g };
    return { join_ref: d, ref: h, topic: f, event: xr.reply, payload: w };
  },
  decodeBroadcast(e, t, n) {
    let r = t.getUint8(1), i = t.getUint8(2), s = this.HEADER_LENGTH + 2, l = n.decode(e.slice(s, s + r));
    s = s + r;
    let u = n.decode(e.slice(s, s + i));
    s = s + i;
    let d = e.slice(s, e.byteLength);
    return { join_ref: null, ref: null, topic: l, event: u, payload: d };
  }
}, O3 = class {
  constructor(e, t = {}) {
    this.stateChangeCallbacks = { open: [], close: [], error: [], message: [] }, this.channels = [], this.sendBuffer = [], this.ref = 0, this.timeout = t.timeout || _3, this.transport = t.transport || io.WebSocket || fl, this.primaryPassedHealthCheck = !1, this.longPollFallbackMs = t.longPollFallbackMs, this.fallbackTimer = null, this.sessionStore = t.sessionStorage || io && io.sessionStorage, this.establishedConnections = 0, this.defaultEncoder = jc.encode.bind(jc), this.defaultDecoder = jc.decode.bind(jc), this.closeWasClean = !1, this.disconnecting = !1, this.binaryType = t.binaryType || "arraybuffer", this.connectClock = 1, this.transport !== fl ? (this.encode = t.encode || this.defaultEncoder, this.decode = t.decode || this.defaultDecoder) : (this.encode = this.defaultEncoder, this.decode = this.defaultDecoder);
    let n = null;
    gl && gl.addEventListener && (gl.addEventListener("pagehide", (r) => {
      this.conn && (this.disconnect(), n = this.connectClock);
    }), gl.addEventListener("pageshow", (r) => {
      n === this.connectClock && (n = null, this.connect());
    })), this.heartbeatIntervalMs = t.heartbeatIntervalMs || 3e4, this.rejoinAfterMs = (r) => t.rejoinAfterMs ? t.rejoinAfterMs(r) : [1e3, 2e3, 5e3][r - 1] || 1e4, this.reconnectAfterMs = (r) => t.reconnectAfterMs ? t.reconnectAfterMs(r) : [10, 50, 100, 150, 200, 250, 500, 1e3, 2e3][r - 1] || 5e3, this.logger = t.logger || null, !this.logger && t.debug && (this.logger = (r, i, s) => {
      console.log(`${r}: ${i}`, s);
    }), this.longpollerTimeout = t.longpollerTimeout || 2e4, this.params = xl(t.params || {}), this.endPoint = `${e}/${Xm.websocket}`, this.vsn = t.vsn || V3, this.heartbeatTimeoutTimer = null, this.heartbeatTimer = null, this.pendingHeartbeatRef = null, this.reconnectTimer = new Lk(() => {
      this.teardown(() => this.connect());
    }, this.reconnectAfterMs);
  }
  /**
   * Returns the LongPoll transport reference
   */
  getLongPollTransport() {
    return fl;
  }
  /**
   * Disconnects and replaces the active transport
   *
   * @param {Function} newTransport - The new transport class to instantiate
   *
   */
  replaceTransport(e) {
    this.connectClock++, this.closeWasClean = !0, clearTimeout(this.fallbackTimer), this.reconnectTimer.reset(), this.conn && (this.conn.close(), this.conn = null), this.transport = e;
  }
  /**
   * Returns the socket protocol
   *
   * @returns {string}
   */
  protocol() {
    return location.protocol.match(/^https/) ? "wss" : "ws";
  }
  /**
   * The fully qualified socket url
   *
   * @returns {string}
   */
  endPointURL() {
    let e = Rd.appendParams(
      Rd.appendParams(this.endPoint, this.params()),
      { vsn: this.vsn }
    );
    return e.charAt(0) !== "/" ? e : e.charAt(1) === "/" ? `${this.protocol()}:${e}` : `${this.protocol()}://${location.host}${e}`;
  }
  /**
   * Disconnects the socket
   *
   * See https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes for valid status codes.
   *
   * @param {Function} callback - Optional callback which is called after socket is disconnected.
   * @param {integer} code - A status code for disconnection (Optional).
   * @param {string} reason - A textual description of the reason to disconnect. (Optional)
   */
  disconnect(e, t, n) {
    this.connectClock++, this.disconnecting = !0, this.closeWasClean = !0, clearTimeout(this.fallbackTimer), this.reconnectTimer.reset(), this.teardown(() => {
      this.disconnecting = !1, e && e();
    }, t, n);
  }
  /**
   *
   * @param {Object} params - The params to send when connecting, for example `{user_id: userToken}`
   *
   * Passing params to connect is deprecated; pass them in the Socket constructor instead:
   * `new Socket("/socket", {params: {user_id: userToken}})`.
   */
  connect(e) {
    e && (console && console.log("passing params to connect is deprecated. Instead pass :params to the Socket constructor"), this.params = xl(e)), !(this.conn && !this.disconnecting) && (this.longPollFallbackMs && this.transport !== fl ? this.connectWithFallback(fl, this.longPollFallbackMs) : this.transportConnect());
  }
  /**
   * Logs the message. Override `this.logger` for specialized logging. noops by default
   * @param {string} kind
   * @param {string} msg
   * @param {Object} data
   */
  log(e, t, n) {
    this.logger && this.logger(e, t, n);
  }
  /**
   * Returns true if a logger has been set on this socket.
   */
  hasLogger() {
    return this.logger !== null;
  }
  /**
   * Registers callbacks for connection open events
   *
   * @example socket.onOpen(function(){ console.info("the socket was opened") })
   *
   * @param {Function} callback
   */
  onOpen(e) {
    let t = this.makeRef();
    return this.stateChangeCallbacks.open.push([t, e]), t;
  }
  /**
   * Registers callbacks for connection close events
   * @param {Function} callback
   */
  onClose(e) {
    let t = this.makeRef();
    return this.stateChangeCallbacks.close.push([t, e]), t;
  }
  /**
   * Registers callbacks for connection error events
   *
   * @example socket.onError(function(error){ alert("An error occurred") })
   *
   * @param {Function} callback
   */
  onError(e) {
    let t = this.makeRef();
    return this.stateChangeCallbacks.error.push([t, e]), t;
  }
  /**
   * Registers callbacks for connection message events
   * @param {Function} callback
   */
  onMessage(e) {
    let t = this.makeRef();
    return this.stateChangeCallbacks.message.push([t, e]), t;
  }
  /**
   * Pings the server and invokes the callback with the RTT in milliseconds
   * @param {Function} callback
   *
   * Returns true if the ping was pushed or false if unable to be pushed.
   */
  ping(e) {
    if (!this.isConnected())
      return !1;
    let t = this.makeRef(), n = Date.now();
    this.push({ topic: "phoenix", event: "heartbeat", payload: {}, ref: t });
    let r = this.onMessage((i) => {
      i.ref === t && (this.off([r]), e(Date.now() - n));
    });
    return !0;
  }
  /**
   * @private
   */
  transportConnect() {
    this.connectClock++, this.closeWasClean = !1, this.conn = new this.transport(this.endPointURL()), this.conn.binaryType = this.binaryType, this.conn.timeout = this.longpollerTimeout, this.conn.onopen = () => this.onConnOpen(), this.conn.onerror = (e) => this.onConnError(e), this.conn.onmessage = (e) => this.onConnMessage(e), this.conn.onclose = (e) => this.onConnClose(e);
  }
  getSession(e) {
    return this.sessionStore && this.sessionStore.getItem(e);
  }
  storeSession(e, t) {
    this.sessionStore && this.sessionStore.setItem(e, t);
  }
  connectWithFallback(e, t = 2500) {
    clearTimeout(this.fallbackTimer);
    let n = !1, r = !0, i, s, l = (u) => {
      this.log("transport", `falling back to ${e.name}...`, u), this.off([i, s]), r = !1, this.replaceTransport(e), this.transportConnect();
    };
    if (this.getSession(`phx:fallback:${e.name}`))
      return l("memorized");
    this.fallbackTimer = setTimeout(l, t), s = this.onError((u) => {
      this.log("transport", "error", u), r && !n && (clearTimeout(this.fallbackTimer), l(u));
    }), this.onOpen(() => {
      if (n = !0, !r)
        return this.primaryPassedHealthCheck || this.storeSession(`phx:fallback:${e.name}`, "true"), this.log("transport", `established ${e.name} fallback`);
      clearTimeout(this.fallbackTimer), this.fallbackTimer = setTimeout(l, t), this.ping((u) => {
        this.log("transport", "connected to primary after", u), this.primaryPassedHealthCheck = !0, clearTimeout(this.fallbackTimer);
      });
    }), this.transportConnect();
  }
  clearHeartbeats() {
    clearTimeout(this.heartbeatTimer), clearTimeout(this.heartbeatTimeoutTimer);
  }
  onConnOpen() {
    this.hasLogger() && this.log("transport", `${this.transport.name} connected to ${this.endPointURL()}`), this.closeWasClean = !1, this.disconnecting = !1, this.establishedConnections++, this.flushSendBuffer(), this.reconnectTimer.reset(), this.resetHeartbeat(), this.stateChangeCallbacks.open.forEach(([, e]) => e());
  }
  /**
   * @private
   */
  heartbeatTimeout() {
    this.pendingHeartbeatRef && (this.pendingHeartbeatRef = null, this.hasLogger() && this.log("transport", "heartbeat timeout. Attempting to re-establish connection"), this.triggerChanError(), this.closeWasClean = !1, this.teardown(() => this.reconnectTimer.scheduleTimeout(), I3, "heartbeat timeout"));
  }
  resetHeartbeat() {
    this.conn && this.conn.skipHeartbeat || (this.pendingHeartbeatRef = null, this.clearHeartbeats(), this.heartbeatTimer = setTimeout(() => this.sendHeartbeat(), this.heartbeatIntervalMs));
  }
  teardown(e, t, n) {
    if (!this.conn)
      return e && e();
    let r = this.connectClock;
    this.waitForBufferDone(() => {
      r === this.connectClock && (this.conn && (t ? this.conn.close(t, n || "") : this.conn.close()), this.waitForSocketClosed(() => {
        r === this.connectClock && (this.conn && (this.conn.onopen = function() {
        }, this.conn.onerror = function() {
        }, this.conn.onmessage = function() {
        }, this.conn.onclose = function() {
        }, this.conn = null), e && e());
      }));
    });
  }
  waitForBufferDone(e, t = 1) {
    if (t === 5 || !this.conn || !this.conn.bufferedAmount) {
      e();
      return;
    }
    setTimeout(() => {
      this.waitForBufferDone(e, t + 1);
    }, 150 * t);
  }
  waitForSocketClosed(e, t = 1) {
    if (t === 5 || !this.conn || this.conn.readyState === ar.closed) {
      e();
      return;
    }
    setTimeout(() => {
      this.waitForSocketClosed(e, t + 1);
    }, 150 * t);
  }
  onConnClose(e) {
    let t = e && e.code;
    this.hasLogger() && this.log("transport", "close", e), this.triggerChanError(), this.clearHeartbeats(), !this.closeWasClean && t !== 1e3 && this.reconnectTimer.scheduleTimeout(), this.stateChangeCallbacks.close.forEach(([, n]) => n(e));
  }
  /**
   * @private
   */
  onConnError(e) {
    this.hasLogger() && this.log("transport", e);
    let t = this.transport, n = this.establishedConnections;
    this.stateChangeCallbacks.error.forEach(([, r]) => {
      r(e, t, n);
    }), (t === this.transport || n > 0) && this.triggerChanError();
  }
  /**
   * @private
   */
  triggerChanError() {
    this.channels.forEach((e) => {
      e.isErrored() || e.isLeaving() || e.isClosed() || e.trigger(xr.error);
    });
  }
  /**
   * @returns {string}
   */
  connectionState() {
    switch (this.conn && this.conn.readyState) {
      case ar.connecting:
        return "connecting";
      case ar.open:
        return "open";
      case ar.closing:
        return "closing";
      default:
        return "closed";
    }
  }
  /**
   * @returns {boolean}
   */
  isConnected() {
    return this.connectionState() === "open";
  }
  /**
   * @private
   *
   * @param {Channel}
   */
  remove(e) {
    this.off(e.stateChangeRefs), this.channels = this.channels.filter((t) => t !== e);
  }
  /**
   * Removes `onOpen`, `onClose`, `onError,` and `onMessage` registrations.
   *
   * @param {refs} - list of refs returned by calls to
   *                 `onOpen`, `onClose`, `onError,` and `onMessage`
   */
  off(e) {
    for (let t in this.stateChangeCallbacks)
      this.stateChangeCallbacks[t] = this.stateChangeCallbacks[t].filter(([n]) => e.indexOf(n) === -1);
  }
  /**
   * Initiates a new channel for the given topic
   *
   * @param {string} topic
   * @param {Object} chanParams - Parameters for the channel
   * @returns {Channel}
   */
  channel(e, t = {}) {
    let n = new P3(e, t, this);
    return this.channels.push(n), n;
  }
  /**
   * @param {Object} data
   */
  push(e) {
    if (this.hasLogger()) {
      let { topic: t, event: n, payload: r, ref: i, join_ref: s } = e;
      this.log("push", `${t} ${n} (${s}, ${i})`, r);
    }
    this.isConnected() ? this.encode(e, (t) => this.conn.send(t)) : this.sendBuffer.push(() => this.encode(e, (t) => this.conn.send(t)));
  }
  /**
   * Return the next message ref, accounting for overflows
   * @returns {string}
   */
  makeRef() {
    let e = this.ref + 1;
    return e === this.ref ? this.ref = 0 : this.ref = e, this.ref.toString();
  }
  sendHeartbeat() {
    this.pendingHeartbeatRef && !this.isConnected() || (this.pendingHeartbeatRef = this.makeRef(), this.push({ topic: "phoenix", event: "heartbeat", payload: {}, ref: this.pendingHeartbeatRef }), this.heartbeatTimeoutTimer = setTimeout(() => this.heartbeatTimeout(), this.heartbeatIntervalMs));
  }
  flushSendBuffer() {
    this.isConnected() && this.sendBuffer.length > 0 && (this.sendBuffer.forEach((e) => e()), this.sendBuffer = []);
  }
  onConnMessage(e) {
    this.decode(e.data, (t) => {
      let { topic: n, event: r, payload: i, ref: s, join_ref: l } = t;
      s && s === this.pendingHeartbeatRef && (this.clearHeartbeats(), this.pendingHeartbeatRef = null, this.heartbeatTimer = setTimeout(() => this.sendHeartbeat(), this.heartbeatIntervalMs)), this.hasLogger() && this.log("receive", `${i.status || ""} ${n} ${r} ${s && "(" + s + ")" || ""}`, i);
      for (let u = 0; u < this.channels.length; u++) {
        const d = this.channels[u];
        d.isMember(n, r, i, l) && d.trigger(r, i, s, l);
      }
      for (let u = 0; u < this.stateChangeCallbacks.message.length; u++) {
        let [, d] = this.stateChangeCallbacks.message[u];
        d(t);
      }
    });
  }
  leaveOpenTopic(e) {
    let t = this.channels.find((n) => n.topic === e && (n.isJoined() || n.isJoining()));
    t && (this.hasLogger() && this.log("transport", `leaving duplicate topic "${e}"`), t.leave());
  }
}, B3 = Object.defineProperty, N3 = (e, t, n) => t in e ? B3(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Jo = (e, t, n) => N3(e, typeof t != "symbol" ? t + "" : t, n);
let D3 = class {
  constructor(t) {
    Jo(this, "host"), Jo(this, "apiKey"), Jo(this, "userToken"), Jo(this, "branch"), Jo(this, "axiosClient"), Jo(this, "socket"), this.host = t.host, this.apiKey = t.apiKey, this.userToken = t.userToken || null, this.branch = t.branch || null, this.axiosClient = lt.create({
      baseURL: this.host,
      headers: {
        Accept: "application/json",
        "Content-Type": "application/json",
        Authorization: `Bearer ${this.apiKey}`,
        "X-Knock-User-Token": this.userToken,
        "X-Knock-Client": this.getKnockClientHeader(),
        "X-Knock-Branch": this.branch
      }
    }), typeof window < "u" && (this.socket = new O3(`${this.host.replace("http", "ws")}/ws/v1`, {
      params: {
        user_token: this.userToken,
        api_key: this.apiKey,
        branch_slug: this.branch
      }
    })), cr(this.axiosClient, {
      retries: 3,
      retryCondition: this.canRetryRequest,
      retryDelay: cr.exponentialDelay
    });
  }
  async makeRequest(t) {
    try {
      const n = await this.axiosClient(t);
      return {
        statusCode: n.status < 300 ? "ok" : "error",
        body: n.data,
        error: void 0,
        status: n.status
      };
    } catch (n) {
      return console.error(n), {
        statusCode: "error",
        status: 500,
        body: void 0,
        error: n
      };
    }
  }
  canRetryRequest(t) {
    return cr.isNetworkError(t) ? !0 : t.response ? t.response.status >= 500 && t.response.status <= 599 || t.response.status === 429 : !1;
  }
  getKnockClientHeader() {
    return "Knock/ClientJS 0.19.3";
  }
};
var j3 = Object.defineProperty, F3 = (e, t, n) => t in e ? j3(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, U3 = (e, t, n) => F3(e, t + "", n);
let W3 = class {
  constructor(t) {
    U3(this, "knock"), this.knock = t;
  }
  async get(t) {
    const n = await this.knock.client().makeRequest({
      method: "GET",
      url: `/v1/messages/${t}`
    });
    return this.handleResponse(n);
  }
  async updateStatus(t, n, r) {
    const i = n === "interacted" && r ? { metadata: r.metadata } : void 0, s = await this.knock.client().makeRequest({
      method: "PUT",
      url: `/v1/messages/${t}/${n}`,
      data: i
    });
    return this.handleResponse(s);
  }
  async removeStatus(t, n) {
    const r = await this.knock.client().makeRequest({
      method: "DELETE",
      url: `/v1/messages/${t}/${n}`
    });
    return this.handleResponse(r);
  }
  async batchUpdateStatuses(t, n, r) {
    const i = n === "interacted" && r ? { metadata: r.metadata } : {}, s = await this.knock.client().makeRequest({
      method: "POST",
      url: `/v1/messages/batch/${n}`,
      data: { message_ids: t, ...i }
    });
    return this.handleResponse(s);
  }
  async bulkUpdateAllStatusesInChannel({
    channelId: t,
    status: n,
    options: r
  }) {
    const i = await this.knock.client().makeRequest({
      method: "POST",
      url: `/v1/channels/${t}/messages/bulk/${n}`,
      data: r
    });
    return this.handleResponse(i);
  }
  handleResponse(t) {
    var n, r;
    if (t.statusCode === "error") {
      if (((r = (n = t.error) == null ? void 0 : n.response) == null ? void 0 : r.status) < 500)
        return t.error || t.body;
      throw new Error(t.error || t.body);
    }
    return t.body;
  }
};
const Hi = "$tenants";
var z3 = Object.defineProperty, H3 = (e, t, n) => t in e ? z3(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, K3 = (e, t, n) => H3(e, t + "", n);
let G3 = class {
  constructor(t) {
    K3(this, "instance"), this.instance = t;
  }
  async authCheck({ tenant: t, knockChannelId: n }) {
    const r = await this.instance.client().makeRequest({
      method: "GET",
      url: `/v1/providers/ms-teams/${n}/auth_check`,
      params: {
        ms_teams_tenant_object: {
          object_id: t,
          collection: Hi
        },
        channel_id: n
      }
    });
    return this.handleResponse(r);
  }
  async getTeams(t) {
    const { knockChannelId: n, tenant: r } = t, i = t.queryOptions || {}, s = await this.instance.client().makeRequest({
      method: "GET",
      url: `/v1/providers/ms-teams/${n}/teams`,
      params: {
        ms_teams_tenant_object: {
          object_id: r,
          collection: Hi
        },
        query_options: {
          $filter: i.$filter,
          $select: i.$select,
          $top: i.$top,
          $skiptoken: i.$skiptoken
        }
      }
    });
    return this.handleResponse(s);
  }
  async getChannels(t) {
    const { knockChannelId: n, teamId: r, tenant: i } = t, s = t.queryOptions || {}, l = await this.instance.client().makeRequest({
      method: "GET",
      url: `/v1/providers/ms-teams/${n}/channels`,
      params: {
        ms_teams_tenant_object: {
          object_id: i,
          collection: Hi
        },
        team_id: r,
        query_options: {
          $filter: s.$filter,
          $select: s.$select
        }
      }
    });
    return this.handleResponse(l);
  }
  async revokeAccessToken({
    tenant: t,
    knockChannelId: n
  }) {
    const r = await this.instance.client().makeRequest({
      method: "PUT",
      url: `/v1/providers/ms-teams/${n}/revoke_access`,
      params: {
        ms_teams_tenant_object: {
          object_id: t,
          collection: Hi
        },
        channel_id: n
      }
    });
    return this.handleResponse(r);
  }
  handleResponse(t) {
    var n, r;
    if (t.statusCode === "error") {
      if (((r = (n = t.error) == null ? void 0 : n.response) == null ? void 0 : r.status) < 500)
        return t.error || t.body;
      throw new Error(t.error || t.body);
    }
    return t.body;
  }
};
var Y3 = Object.defineProperty, q3 = (e, t, n) => t in e ? Y3(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, X3 = (e, t, n) => q3(e, t + "", n);
let Z3 = class {
  constructor(t) {
    X3(this, "instance"), this.instance = t;
  }
  async getChannelData({
    collection: t,
    objectId: n,
    channelId: r
  }) {
    const i = await this.instance.client().makeRequest({
      method: "GET",
      url: `/v1/objects/${t}/${n}/channel_data/${r}`
    });
    return this.handleResponse(i);
  }
  async setChannelData({
    objectId: t,
    collection: n,
    channelId: r,
    data: i
  }) {
    const s = await this.instance.client().makeRequest({
      method: "PUT",
      url: `v1/objects/${n}/${t}/channel_data/${r}`,
      data: { data: i }
    });
    return this.handleResponse(s);
  }
  handleResponse(t) {
    if (t.statusCode === "error")
      throw new Error(t.error || t.body);
    return t.body;
  }
};
var Q3 = Object.defineProperty, J3 = (e, t, n) => t in e ? Q3(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, eN = (e, t, n) => J3(e, t + "", n);
const li = "default";
function xE(e) {
  return typeof e == "object" ? e : { subscribed: e };
}
let tN = class {
  constructor(t) {
    eN(this, "instance"), this.instance = t;
  }
  /**
   * @deprecated Use `user.getAllPreferences()` instead
   */
  async getAll() {
    this.instance.failIfNotAuthenticated();
    const t = await this.instance.client().makeRequest({
      method: "GET",
      url: `/v1/users/${this.instance.userId}/preferences`
    });
    return this.handleResponse(t);
  }
  /**
   * @deprecated Use `user.getPreferences()` instead
   */
  async get(t = {}) {
    this.instance.failIfNotAuthenticated();
    const n = t.preferenceSet || li, r = await this.instance.client().makeRequest({
      method: "GET",
      url: `/v1/users/${this.instance.userId}/preferences/${n}`
    });
    return this.handleResponse(r);
  }
  /**
   * @deprecated Use `user.setPreferences(preferenceSet, options)` instead
   */
  async set(t, n = {}) {
    this.instance.failIfNotAuthenticated();
    const r = n.preferenceSet || li, i = await this.instance.client().makeRequest({
      method: "PUT",
      url: `/v1/users/${this.instance.userId}/preferences/${r}`,
      data: t
    });
    return this.handleResponse(i);
  }
  /**
   * @deprecated Use `user.setPreferences(preferenceSet, options)` instead
   */
  async setChannelTypes(t, n = {}) {
    this.instance.failIfNotAuthenticated();
    const r = n.preferenceSet || li, i = await this.instance.client().makeRequest({
      method: "PUT",
      url: `/v1/users/${this.instance.userId}/preferences/${r}/channel_types`,
      data: t
    });
    return this.handleResponse(i);
  }
  /**
   * @deprecated Use `user.setPreferences(preferenceSet, options)` instead
   */
  async setChannelType(t, n, r = {}) {
    this.instance.failIfNotAuthenticated();
    const i = r.preferenceSet || li, s = await this.instance.client().makeRequest({
      method: "PUT",
      url: `/v1/users/${this.instance.userId}/preferences/${i}/channel_types/${t}`,
      data: { subscribed: n }
    });
    return this.handleResponse(s);
  }
  /**
   * @deprecated Use `user.setPreferences(preferenceSet, options)` instead
   */
  async setWorkflows(t, n = {}) {
    this.instance.failIfNotAuthenticated();
    const r = n.preferenceSet || li, i = await this.instance.client().makeRequest({
      method: "PUT",
      url: `/v1/users/${this.instance.userId}/preferences/${r}/workflows`,
      data: t
    });
    return this.handleResponse(i);
  }
  /**
   * @deprecated Use `user.setPreferences(preferenceSet, options)` instead
   */
  async setWorkflow(t, n, r = {}) {
    this.instance.failIfNotAuthenticated();
    const i = r.preferenceSet || li, s = xE(n), l = await this.instance.client().makeRequest({
      method: "PUT",
      url: `/v1/users/${this.instance.userId}/preferences/${i}/workflows/${t}`,
      data: s
    });
    return this.handleResponse(l);
  }
  /**
   * @deprecated Use `user.setPreferences(preferenceSet, options)` instead
   */
  async setCategories(t, n = {}) {
    this.instance.failIfNotAuthenticated();
    const r = n.preferenceSet || li, i = await this.instance.client().makeRequest({
      method: "PUT",
      url: `/v1/users/${this.instance.userId}/preferences/${r}/categories`,
      data: t
    });
    return this.handleResponse(i);
  }
  /**
   * @deprecated Use `user.setPreferences(preferenceSet, options)` instead
   */
  async setCategory(t, n, r = {}) {
    this.instance.failIfNotAuthenticated();
    const i = r.preferenceSet || li, s = xE(n), l = await this.instance.client().makeRequest({
      method: "PUT",
      url: `/v1/users/${this.instance.userId}/preferences/${i}/categories/${t}`,
      data: s
    });
    return this.handleResponse(l);
  }
  handleResponse(t) {
    if (t.statusCode === "error")
      throw new Error(t.error || t.body);
    return t.body;
  }
};
var nN = Object.defineProperty, rN = (e, t, n) => t in e ? nN(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, iN = (e, t, n) => rN(e, t + "", n);
let oN = class {
  constructor(t) {
    iN(this, "instance"), this.instance = t;
  }
  async authCheck({ tenant: t, knockChannelId: n }) {
    const r = await this.instance.client().makeRequest({
      method: "GET",
      url: `/v1/providers/slack/${n}/auth_check`,
      params: {
        access_token_object: {
          object_id: t,
          collection: Hi
        },
        channel_id: n
      }
    });
    return this.handleResponse(r);
  }
  async getChannels(t) {
    const { knockChannelId: n, tenant: r } = t, i = t.queryOptions || {}, s = await this.instance.client().makeRequest({
      method: "GET",
      url: `/v1/providers/slack/${n}/channels`,
      params: {
        access_token_object: {
          object_id: r,
          collection: Hi
        },
        channel_id: n,
        query_options: {
          cursor: i.cursor,
          limit: i.limit,
          exclude_archived: i.excludeArchived,
          team_id: i.teamId,
          types: i.types
        }
      }
    });
    return this.handleResponse(s);
  }
  async revokeAccessToken({ tenant: t, knockChannelId: n }) {
    const r = await this.instance.client().makeRequest({
      method: "PUT",
      url: `/v1/providers/slack/${n}/revoke_access`,
      params: {
        access_token_object: {
          object_id: t,
          collection: Hi
        },
        channel_id: n
      }
    });
    return this.handleResponse(r);
  }
  handleResponse(t) {
    var n, r;
    if (t.statusCode === "error") {
      if (((r = (n = t.error) == null ? void 0 : n.response) == null ? void 0 : r.status) < 500)
        return t.error || t.body;
      throw new Error(t.error || t.body);
    }
    return t.body;
  }
};
var sN = Object.defineProperty, xe = (e, t) => sN(e, "name", { value: t, configurable: !0 }), ps = class {
  constructor(t, n, r, i, s, l) {
    Ni(this, "type", 3);
    Ni(this, "name", "");
    Ni(this, "prefix", "");
    Ni(this, "value", "");
    Ni(this, "suffix", "");
    Ni(this, "modifier", 3);
    this.type = t, this.name = n, this.prefix = r, this.value = i, this.suffix = s, this.modifier = l;
  }
  hasCustomName() {
    return this.name !== "" && typeof this.name != "number";
  }
};
xe(ps, "Part");
var aN = /[$_\p{ID_Start}]/u, lN = /[$_\u200C\u200D\p{ID_Continue}]/u, Zm = ".*";
function Pk(e, t) {
  return (t ? /^[\x00-\xFF]*$/ : /^[\x00-\x7F]*$/).test(e);
}
xe(Pk, "isASCII");
function Yv(e, t = !1) {
  let n = [], r = 0;
  for (; r < e.length; ) {
    let i = e[r], s = xe(function(l) {
      if (!t) throw new TypeError(l);
      n.push({ type: "INVALID_CHAR", index: r, value: e[r++] });
    }, "ErrorOrInvalid");
    if (i === "*") {
      n.push({ type: "ASTERISK", index: r, value: e[r++] });
      continue;
    }
    if (i === "+" || i === "?") {
      n.push({ type: "OTHER_MODIFIER", index: r, value: e[r++] });
      continue;
    }
    if (i === "\\") {
      n.push({ type: "ESCAPED_CHAR", index: r++, value: e[r++] });
      continue;
    }
    if (i === "{") {
      n.push({ type: "OPEN", index: r, value: e[r++] });
      continue;
    }
    if (i === "}") {
      n.push({ type: "CLOSE", index: r, value: e[r++] });
      continue;
    }
    if (i === ":") {
      let l = "", u = r + 1;
      for (; u < e.length; ) {
        let d = e.substr(u, 1);
        if (u === r + 1 && aN.test(d) || u !== r + 1 && lN.test(d)) {
          l += e[u++];
          continue;
        }
        break;
      }
      if (!l) {
        s(`Missing parameter name at ${r}`);
        continue;
      }
      n.push({ type: "NAME", index: r, value: l }), r = u;
      continue;
    }
    if (i === "(") {
      let l = 1, u = "", d = r + 1, h = !1;
      if (e[d] === "?") {
        s(`Pattern cannot start with "?" at ${d}`);
        continue;
      }
      for (; d < e.length; ) {
        if (!Pk(e[d], !1)) {
          s(`Invalid character '${e[d]}' at ${d}.`), h = !0;
          break;
        }
        if (e[d] === "\\") {
          u += e[d++] + e[d++];
          continue;
        }
        if (e[d] === ")") {
          if (l--, l === 0) {
            d++;
            break;
          }
        } else if (e[d] === "(" && (l++, e[d + 1] !== "?")) {
          s(`Capturing groups are not allowed at ${d}`), h = !0;
          break;
        }
        u += e[d++];
      }
      if (h) continue;
      if (l) {
        s(`Unbalanced pattern at ${r}`);
        continue;
      }
      if (!u) {
        s(`Missing pattern at ${r}`);
        continue;
      }
      n.push({ type: "REGEX", index: r, value: u }), r = d;
      continue;
    }
    n.push({ type: "CHAR", index: r, value: e[r++] });
  }
  return n.push({ type: "END", index: r, value: "" }), n;
}
xe(Yv, "lexer");
function qv(e, t = {}) {
  let n = Yv(e);
  t.delimiter ?? (t.delimiter = "/#?"), t.prefixes ?? (t.prefixes = "./");
  let r = `[^${un(t.delimiter)}]+?`, i = [], s = 0, l = 0, u = /* @__PURE__ */ new Set(), d = xe((R) => {
    if (l < n.length && n[l].type === R) return n[l++].value;
  }, "tryConsume"), h = xe(() => d("OTHER_MODIFIER") ?? d("ASTERISK"), "tryConsumeModifier"), f = xe((R) => {
    let _ = d(R);
    if (_ !== void 0) return _;
    let { type: L, index: V } = n[l];
    throw new TypeError(`Unexpected ${L} at ${V}, expected ${R}`);
  }, "mustConsume"), m = xe(() => {
    let R = "", _;
    for (; _ = d("CHAR") ?? d("ESCAPED_CHAR"); ) R += _;
    return R;
  }, "consumeText"), g = xe((R) => R, "DefaultEncodePart"), w = t.encodePart || g, E = "", b = xe((R) => {
    E += R;
  }, "appendToPendingFixedValue"), A = xe(() => {
    E.length && (i.push(new ps(3, "", "", w(E), "", 3)), E = "");
  }, "maybeAddPartFromPendingFixedValue"), x = xe((R, _, L, V, O) => {
    let D = 3;
    switch (O) {
      case "?":
        D = 1;
        break;
      case "*":
        D = 0;
        break;
      case "+":
        D = 2;
        break;
    }
    if (!_ && !L && D === 3) {
      b(R);
      return;
    }
    if (A(), !_ && !L) {
      if (!R) return;
      i.push(new ps(3, "", "", w(R), "", D));
      return;
    }
    let B;
    L ? L === "*" ? B = Zm : B = L : B = r;
    let H = 2;
    B === r ? (H = 1, B = "") : B === Zm && (H = 0, B = "");
    let J;
    if (_ ? J = _ : L && (J = s++), u.has(J)) throw new TypeError(`Duplicate name '${J}'.`);
    u.add(J), i.push(new ps(H, J, w(R), B, w(V), D));
  }, "addPart");
  for (; l < n.length; ) {
    let R = d("CHAR"), _ = d("NAME"), L = d("REGEX");
    if (!_ && !L && (L = d("ASTERISK")), _ || L) {
      let O = R ?? "";
      t.prefixes.indexOf(O) === -1 && (b(O), O = ""), A();
      let D = h();
      x(O, _, L, "", D);
      continue;
    }
    let V = R ?? d("ESCAPED_CHAR");
    if (V) {
      b(V);
      continue;
    }
    if (d("OPEN")) {
      let O = m(), D = d("NAME"), B = d("REGEX");
      !D && !B && (B = d("ASTERISK"));
      let H = m();
      f("CLOSE");
      let J = h();
      x(O, D, B, H, J);
      continue;
    }
    A(), f("END");
  }
  return i;
}
xe(qv, "parse");
function un(e) {
  return e.replace(/([.+*?^${}()[\]|/\\])/g, "\\$1");
}
xe(un, "escapeString");
function Qm(e) {
  return e && e.ignoreCase ? "ui" : "u";
}
xe(Qm, "flags");
function Mk(e, t, n) {
  return Xv(qv(e, n), t, n);
}
xe(Mk, "stringToRegexp");
function Ki(e) {
  switch (e) {
    case 0:
      return "*";
    case 1:
      return "?";
    case 2:
      return "+";
    case 3:
      return "";
  }
}
xe(Ki, "modifierToString");
function Xv(e, t, n = {}) {
  n.delimiter ?? (n.delimiter = "/#?"), n.prefixes ?? (n.prefixes = "./"), n.sensitive ?? (n.sensitive = !1), n.strict ?? (n.strict = !1), n.end ?? (n.end = !0), n.start ?? (n.start = !0), n.endsWith = "";
  let r = n.start ? "^" : "";
  for (let u of e) {
    if (u.type === 3) {
      u.modifier === 3 ? r += un(u.value) : r += `(?:${un(u.value)})${Ki(u.modifier)}`;
      continue;
    }
    t && t.push(u.name);
    let d = `[^${un(n.delimiter)}]+?`, h = u.value;
    if (u.type === 1 ? h = d : u.type === 0 && (h = Zm), !u.prefix.length && !u.suffix.length) {
      u.modifier === 3 || u.modifier === 1 ? r += `(${h})${Ki(u.modifier)}` : r += `((?:${h})${Ki(u.modifier)})`;
      continue;
    }
    if (u.modifier === 3 || u.modifier === 1) {
      r += `(?:${un(u.prefix)}(${h})${un(u.suffix)})`, r += Ki(u.modifier);
      continue;
    }
    r += `(?:${un(u.prefix)}`, r += `((?:${h})(?:`, r += un(u.suffix), r += un(u.prefix), r += `(?:${h}))*)${un(u.suffix)})`, u.modifier === 0 && (r += "?");
  }
  let i = `[${un(n.endsWith)}]|$`, s = `[${un(n.delimiter)}]`;
  if (n.end) return n.strict || (r += `${s}?`), n.endsWith.length ? r += `(?=${i})` : r += "$", new RegExp(r, Qm(n));
  n.strict || (r += `(?:${s}(?=${i}))?`);
  let l = !1;
  if (e.length) {
    let u = e[e.length - 1];
    u.type === 3 && u.modifier === 3 && (l = n.delimiter.indexOf(u) > -1);
  }
  return l || (r += `(?=${s}|${i})`), new RegExp(r, Qm(n));
}
xe(Xv, "partsToRegexp");
var di = { delimiter: "", prefixes: "", sensitive: !0, strict: !0 }, uN = { delimiter: ".", prefixes: "", sensitive: !0, strict: !0 }, cN = { delimiter: "/", prefixes: "/", sensitive: !0, strict: !0 };
function Ok(e, t) {
  return e.length ? e[0] === "/" ? !0 : !t || e.length < 2 ? !1 : (e[0] == "\\" || e[0] == "{") && e[1] == "/" : !1;
}
xe(Ok, "isAbsolutePathname");
function Zv(e, t) {
  return e.startsWith(t) ? e.substring(t.length, e.length) : e;
}
xe(Zv, "maybeStripPrefix");
function Bk(e, t) {
  return e.endsWith(t) ? e.substr(0, e.length - t.length) : e;
}
xe(Bk, "maybeStripSuffix");
function Qv(e) {
  return !e || e.length < 2 ? !1 : e[0] === "[" || (e[0] === "\\" || e[0] === "{") && e[1] === "[";
}
xe(Qv, "treatAsIPv6Hostname");
var Nk = ["ftp", "file", "http", "https", "ws", "wss"];
function Jv(e) {
  if (!e) return !0;
  for (let t of Nk) if (e.test(t)) return !0;
  return !1;
}
xe(Jv, "isSpecialScheme");
function Dk(e, t) {
  if (e = Zv(e, "#"), t || e === "") return e;
  let n = new URL("https://example.com");
  return n.hash = e, n.hash ? n.hash.substring(1, n.hash.length) : "";
}
xe(Dk, "canonicalizeHash");
function jk(e, t) {
  if (e = Zv(e, "?"), t || e === "") return e;
  let n = new URL("https://example.com");
  return n.search = e, n.search ? n.search.substring(1, n.search.length) : "";
}
xe(jk, "canonicalizeSearch");
function Fk(e, t) {
  return t || e === "" ? e : Qv(e) ? ny(e) : ty(e);
}
xe(Fk, "canonicalizeHostname");
function Uk(e, t) {
  if (t || e === "") return e;
  let n = new URL("https://example.com");
  return n.password = e, n.password;
}
xe(Uk, "canonicalizePassword");
function Wk(e, t) {
  if (t || e === "") return e;
  let n = new URL("https://example.com");
  return n.username = e, n.username;
}
xe(Wk, "canonicalizeUsername");
function zk(e, t, n) {
  if (n || e === "") return e;
  if (t && !Nk.includes(t)) return new URL(`${t}:${e}`).pathname;
  let r = e[0] == "/";
  return e = new URL(r ? e : "/-" + e, "https://example.com").pathname, r || (e = e.substring(2, e.length)), e;
}
xe(zk, "canonicalizePathname");
function Hk(e, t, n) {
  return ey(t) === e && (e = ""), n || e === "" ? e : ry(e);
}
xe(Hk, "canonicalizePort");
function Kk(e, t) {
  return e = Bk(e, ":"), t || e === "" ? e : ff(e);
}
xe(Kk, "canonicalizeProtocol");
function ey(e) {
  switch (e) {
    case "ws":
    case "http":
      return "80";
    case "wws":
    case "https":
      return "443";
    case "ftp":
      return "21";
    default:
      return "";
  }
}
xe(ey, "defaultPortForProtocol");
function ff(e) {
  if (e === "") return e;
  if (/^[-+.A-Za-z0-9]*$/.test(e)) return e.toLowerCase();
  throw new TypeError(`Invalid protocol '${e}'.`);
}
xe(ff, "protocolEncodeCallback");
function Gk(e) {
  if (e === "") return e;
  let t = new URL("https://example.com");
  return t.username = e, t.username;
}
xe(Gk, "usernameEncodeCallback");
function Yk(e) {
  if (e === "") return e;
  let t = new URL("https://example.com");
  return t.password = e, t.password;
}
xe(Yk, "passwordEncodeCallback");
function ty(e) {
  if (e === "") return e;
  if (/[\t\n\r #%/:<>?@[\]^\\|]/g.test(e)) throw new TypeError(`Invalid hostname '${e}'`);
  let t = new URL("https://example.com");
  return t.hostname = e, t.hostname;
}
xe(ty, "hostnameEncodeCallback");
function ny(e) {
  if (e === "") return e;
  if (/[^0-9a-fA-F[\]:]/g.test(e)) throw new TypeError(`Invalid IPv6 hostname '${e}'`);
  return e.toLowerCase();
}
xe(ny, "ipv6HostnameEncodeCallback");
function ry(e) {
  if (e === "" || /^[0-9]*$/.test(e) && parseInt(e) <= 65535) return e;
  throw new TypeError(`Invalid port '${e}'.`);
}
xe(ry, "portEncodeCallback");
function qk(e) {
  if (e === "") return e;
  let t = new URL("https://example.com");
  return t.pathname = e[0] !== "/" ? "/-" + e : e, e[0] !== "/" ? t.pathname.substring(2, t.pathname.length) : t.pathname;
}
xe(qk, "standardURLPathnameEncodeCallback");
function Xk(e) {
  return e === "" ? e : new URL(`data:${e}`).pathname;
}
xe(Xk, "pathURLPathnameEncodeCallback");
function Zk(e) {
  if (e === "") return e;
  let t = new URL("https://example.com");
  return t.search = e, t.search.substring(1, t.search.length);
}
xe(Zk, "searchEncodeCallback");
function Qk(e) {
  if (e === "") return e;
  let t = new URL("https://example.com");
  return t.hash = e, t.hash.substring(1, t.hash.length);
}
xe(Qk, "hashEncodeCallback");
var Ss, Bt, xt, Ze, to, ks, cn, Rs, Ts, $s, se, yt, eR, Jm, vl, ud, An, eg, tR, cd, nR, rR, dd, rs, Wi, iR, oR, sR, aR, ir, lR, ek, Jk = (ek = class {
  constructor(t) {
    At(this, se);
    At(this, Ss);
    At(this, Bt, []);
    At(this, xt, {});
    At(this, Ze, 0);
    At(this, to, 1);
    At(this, ks, 0);
    At(this, cn, 0);
    At(this, Rs, 0);
    At(this, Ts, 0);
    At(this, $s, !1);
    vt(this, Ss, t);
  }
  get result() {
    return ne(this, xt);
  }
  parse() {
    for (vt(this, Bt, Yv(ne(this, Ss), !0)); ne(this, Ze) < ne(this, Bt).length; vt(this, Ze, ne(this, Ze) + ne(this, to))) {
      if (vt(this, to, 1), ne(this, Bt)[ne(this, Ze)].type === "END") {
        if (ne(this, cn) === 0) {
          pe(this, se, Jm).call(this), pe(this, se, Wi).call(this) ? pe(this, se, yt).call(this, 9, 1) : pe(this, se, rs).call(this) ? pe(this, se, yt).call(this, 8, 1) : pe(this, se, yt).call(this, 7, 0);
          continue;
        } else if (ne(this, cn) === 2) {
          pe(this, se, vl).call(this, 5);
          continue;
        }
        pe(this, se, yt).call(this, 10, 0);
        break;
      }
      if (ne(this, Rs) > 0) if (pe(this, se, oR).call(this)) vt(this, Rs, ne(this, Rs) - 1);
      else continue;
      if (pe(this, se, iR).call(this)) {
        vt(this, Rs, ne(this, Rs) + 1);
        continue;
      }
      switch (ne(this, cn)) {
        case 0:
          pe(this, se, eg).call(this) && pe(this, se, vl).call(this, 1);
          break;
        case 1:
          if (pe(this, se, eg).call(this)) {
            pe(this, se, lR).call(this);
            let t = 7, n = 1;
            pe(this, se, tR).call(this) ? (t = 2, n = 3) : ne(this, $s) && (t = 2), pe(this, se, yt).call(this, t, n);
          }
          break;
        case 2:
          pe(this, se, cd).call(this) ? pe(this, se, vl).call(this, 3) : (pe(this, se, dd).call(this) || pe(this, se, rs).call(this) || pe(this, se, Wi).call(this)) && pe(this, se, vl).call(this, 5);
          break;
        case 3:
          pe(this, se, nR).call(this) ? pe(this, se, yt).call(this, 4, 1) : pe(this, se, cd).call(this) && pe(this, se, yt).call(this, 5, 1);
          break;
        case 4:
          pe(this, se, cd).call(this) && pe(this, se, yt).call(this, 5, 1);
          break;
        case 5:
          pe(this, se, sR).call(this) ? vt(this, Ts, ne(this, Ts) + 1) : pe(this, se, aR).call(this) && vt(this, Ts, ne(this, Ts) - 1), pe(this, se, rR).call(this) && !ne(this, Ts) ? pe(this, se, yt).call(this, 6, 1) : pe(this, se, dd).call(this) ? pe(this, se, yt).call(this, 7, 0) : pe(this, se, rs).call(this) ? pe(this, se, yt).call(this, 8, 1) : pe(this, se, Wi).call(this) && pe(this, se, yt).call(this, 9, 1);
          break;
        case 6:
          pe(this, se, dd).call(this) ? pe(this, se, yt).call(this, 7, 0) : pe(this, se, rs).call(this) ? pe(this, se, yt).call(this, 8, 1) : pe(this, se, Wi).call(this) && pe(this, se, yt).call(this, 9, 1);
          break;
        case 7:
          pe(this, se, rs).call(this) ? pe(this, se, yt).call(this, 8, 1) : pe(this, se, Wi).call(this) && pe(this, se, yt).call(this, 9, 1);
          break;
        case 8:
          pe(this, se, Wi).call(this) && pe(this, se, yt).call(this, 9, 1);
          break;
      }
    }
    ne(this, xt).hostname !== void 0 && ne(this, xt).port === void 0 && (ne(this, xt).port = "");
  }
}, Ss = new WeakMap(), Bt = new WeakMap(), xt = new WeakMap(), Ze = new WeakMap(), to = new WeakMap(), ks = new WeakMap(), cn = new WeakMap(), Rs = new WeakMap(), Ts = new WeakMap(), $s = new WeakMap(), se = new WeakSet(), yt = function(t, n) {
  var r, i, s;
  switch (ne(this, cn)) {
    case 0:
      break;
    case 1:
      ne(this, xt).protocol = pe(this, se, ir).call(this);
      break;
    case 2:
      break;
    case 3:
      ne(this, xt).username = pe(this, se, ir).call(this);
      break;
    case 4:
      ne(this, xt).password = pe(this, se, ir).call(this);
      break;
    case 5:
      ne(this, xt).hostname = pe(this, se, ir).call(this);
      break;
    case 6:
      ne(this, xt).port = pe(this, se, ir).call(this);
      break;
    case 7:
      ne(this, xt).pathname = pe(this, se, ir).call(this);
      break;
    case 8:
      ne(this, xt).search = pe(this, se, ir).call(this);
      break;
    case 9:
      ne(this, xt).hash = pe(this, se, ir).call(this);
      break;
  }
  ne(this, cn) !== 0 && t !== 10 && ([1, 2, 3, 4].includes(ne(this, cn)) && [6, 7, 8, 9].includes(t) && ((r = ne(this, xt)).hostname ?? (r.hostname = "")), [1, 2, 3, 4, 5, 6].includes(ne(this, cn)) && [8, 9].includes(t) && ((i = ne(this, xt)).pathname ?? (i.pathname = ne(this, $s) ? "/" : "")), [1, 2, 3, 4, 5, 6, 7].includes(ne(this, cn)) && t === 9 && ((s = ne(this, xt)).search ?? (s.search = ""))), pe(this, se, eR).call(this, t, n);
}, eR = function(t, n) {
  vt(this, cn, t), vt(this, ks, ne(this, Ze) + n), vt(this, Ze, ne(this, Ze) + n), vt(this, to, 0);
}, Jm = function() {
  vt(this, Ze, ne(this, ks)), vt(this, to, 0);
}, vl = function(t) {
  pe(this, se, Jm).call(this), vt(this, cn, t);
}, ud = function(t) {
  return t < 0 && (t = ne(this, Bt).length - t), t < ne(this, Bt).length ? ne(this, Bt)[t] : ne(this, Bt)[ne(this, Bt).length - 1];
}, An = function(t, n) {
  let r = pe(this, se, ud).call(this, t);
  return r.value === n && (r.type === "CHAR" || r.type === "ESCAPED_CHAR" || r.type === "INVALID_CHAR");
}, eg = function() {
  return pe(this, se, An).call(this, ne(this, Ze), ":");
}, tR = function() {
  return pe(this, se, An).call(this, ne(this, Ze) + 1, "/") && pe(this, se, An).call(this, ne(this, Ze) + 2, "/");
}, cd = function() {
  return pe(this, se, An).call(this, ne(this, Ze), "@");
}, nR = function() {
  return pe(this, se, An).call(this, ne(this, Ze), ":");
}, rR = function() {
  return pe(this, se, An).call(this, ne(this, Ze), ":");
}, dd = function() {
  return pe(this, se, An).call(this, ne(this, Ze), "/");
}, rs = function() {
  if (pe(this, se, An).call(this, ne(this, Ze), "?")) return !0;
  if (ne(this, Bt)[ne(this, Ze)].value !== "?") return !1;
  let t = pe(this, se, ud).call(this, ne(this, Ze) - 1);
  return t.type !== "NAME" && t.type !== "REGEX" && t.type !== "CLOSE" && t.type !== "ASTERISK";
}, Wi = function() {
  return pe(this, se, An).call(this, ne(this, Ze), "#");
}, iR = function() {
  return ne(this, Bt)[ne(this, Ze)].type == "OPEN";
}, oR = function() {
  return ne(this, Bt)[ne(this, Ze)].type == "CLOSE";
}, sR = function() {
  return pe(this, se, An).call(this, ne(this, Ze), "[");
}, aR = function() {
  return pe(this, se, An).call(this, ne(this, Ze), "]");
}, ir = function() {
  let t = ne(this, Bt)[ne(this, Ze)], n = pe(this, se, ud).call(this, ne(this, ks)).index;
  return ne(this, Ss).substring(n, t.index);
}, lR = function() {
  let t = {};
  Object.assign(t, di), t.encodePart = ff;
  let n = Mk(pe(this, se, ir).call(this), void 0, t);
  vt(this, $s, Jv(n));
}, ek);
xe(Jk, "Parser");
var Gp = ["protocol", "username", "password", "hostname", "port", "pathname", "search", "hash"], ui = "*";
function tg(e, t) {
  if (typeof e != "string") throw new TypeError("parameter 1 is not of type 'string'.");
  let n = new URL(e, t);
  return { protocol: n.protocol.substring(0, n.protocol.length - 1), username: n.username, password: n.password, hostname: n.hostname, port: n.port, pathname: n.pathname, search: n.search !== "" ? n.search.substring(1, n.search.length) : void 0, hash: n.hash !== "" ? n.hash.substring(1, n.hash.length) : void 0 };
}
xe(tg, "extractValues");
function or(e, t) {
  return t ? ss(e) : e;
}
xe(or, "processBaseURLString");
function is(e, t, n) {
  let r;
  if (typeof t.baseURL == "string") try {
    r = new URL(t.baseURL), t.protocol === void 0 && (e.protocol = or(r.protocol.substring(0, r.protocol.length - 1), n)), !n && t.protocol === void 0 && t.hostname === void 0 && t.port === void 0 && t.username === void 0 && (e.username = or(r.username, n)), !n && t.protocol === void 0 && t.hostname === void 0 && t.port === void 0 && t.username === void 0 && t.password === void 0 && (e.password = or(r.password, n)), t.protocol === void 0 && t.hostname === void 0 && (e.hostname = or(r.hostname, n)), t.protocol === void 0 && t.hostname === void 0 && t.port === void 0 && (e.port = or(r.port, n)), t.protocol === void 0 && t.hostname === void 0 && t.port === void 0 && t.pathname === void 0 && (e.pathname = or(r.pathname, n)), t.protocol === void 0 && t.hostname === void 0 && t.port === void 0 && t.pathname === void 0 && t.search === void 0 && (e.search = or(r.search.substring(1, r.search.length), n)), t.protocol === void 0 && t.hostname === void 0 && t.port === void 0 && t.pathname === void 0 && t.search === void 0 && t.hash === void 0 && (e.hash = or(r.hash.substring(1, r.hash.length), n));
  } catch {
    throw new TypeError(`invalid baseURL '${t.baseURL}'.`);
  }
  if (typeof t.protocol == "string" && (e.protocol = Kk(t.protocol, n)), typeof t.username == "string" && (e.username = Wk(t.username, n)), typeof t.password == "string" && (e.password = Uk(t.password, n)), typeof t.hostname == "string" && (e.hostname = Fk(t.hostname, n)), typeof t.port == "string" && (e.port = Hk(t.port, e.protocol, n)), typeof t.pathname == "string") {
    if (e.pathname = t.pathname, r && !Ok(e.pathname, n)) {
      let i = r.pathname.lastIndexOf("/");
      i >= 0 && (e.pathname = or(r.pathname.substring(0, i + 1), n) + e.pathname);
    }
    e.pathname = zk(e.pathname, e.protocol, n);
  }
  return typeof t.search == "string" && (e.search = jk(t.search, n)), typeof t.hash == "string" && (e.hash = Dk(t.hash, n)), e;
}
xe(is, "applyInit");
function ss(e) {
  return e.replace(/([+*?:{}()\\])/g, "\\$1");
}
xe(ss, "escapePatternString");
function uR(e) {
  return e.replace(/([.+*?^${}()[\]|/\\])/g, "\\$1");
}
xe(uR, "escapeRegexpString");
function cR(e, t) {
  t.delimiter ?? (t.delimiter = "/#?"), t.prefixes ?? (t.prefixes = "./"), t.sensitive ?? (t.sensitive = !1), t.strict ?? (t.strict = !1), t.end ?? (t.end = !0), t.start ?? (t.start = !0), t.endsWith = "";
  let n = ".*", r = `[^${uR(t.delimiter)}]+?`, i = /[$_\u200C\u200D\p{ID_Continue}]/u, s = "";
  for (let l = 0; l < e.length; ++l) {
    let u = e[l];
    if (u.type === 3) {
      if (u.modifier === 3) {
        s += ss(u.value);
        continue;
      }
      s += `{${ss(u.value)}}${Ki(u.modifier)}`;
      continue;
    }
    let d = u.hasCustomName(), h = !!u.suffix.length || !!u.prefix.length && (u.prefix.length !== 1 || !t.prefixes.includes(u.prefix)), f = l > 0 ? e[l - 1] : null, m = l < e.length - 1 ? e[l + 1] : null;
    if (!h && d && u.type === 1 && u.modifier === 3 && m && !m.prefix.length && !m.suffix.length) if (m.type === 3) {
      let g = m.value.length > 0 ? m.value[0] : "";
      h = i.test(g);
    } else h = !m.hasCustomName();
    if (!h && !u.prefix.length && f && f.type === 3) {
      let g = f.value[f.value.length - 1];
      h = t.prefixes.includes(g);
    }
    h && (s += "{"), s += ss(u.prefix), d && (s += `:${u.name}`), u.type === 2 ? s += `(${u.value})` : u.type === 1 ? d || (s += `(${r})`) : u.type === 0 && (!d && (!f || f.type === 3 || f.modifier !== 3 || h || u.prefix !== "") ? s += "*" : s += `(${n})`), u.type === 1 && d && u.suffix.length && i.test(u.suffix[0]) && (s += "\\"), s += ss(u.suffix), h && (s += "}"), u.modifier !== 3 && (s += Ki(u.modifier));
  }
  return s;
}
xe(cR, "partsToPattern");
var sr, no, Vs, St, Fn, _s, tk, iy = (tk = class {
  constructor(t = {}, n, r) {
    At(this, sr);
    At(this, no, {});
    At(this, Vs, {});
    At(this, St, {});
    At(this, Fn, {});
    At(this, _s, !1);
    try {
      let i;
      if (typeof n == "string" ? i = n : r = n, typeof t == "string") {
        let d = new Jk(t);
        if (d.parse(), t = d.result, i === void 0 && typeof t.protocol != "string") throw new TypeError("A base URL must be provided for a relative constructor string.");
        t.baseURL = i;
      } else {
        if (!t || typeof t != "object") throw new TypeError("parameter 1 is not of type 'string' and cannot convert to dictionary.");
        if (i) throw new TypeError("parameter 1 is not of type 'string'.");
      }
      typeof r > "u" && (r = { ignoreCase: !1 });
      let s = { ignoreCase: r.ignoreCase === !0 };
      vt(this, sr, is({ pathname: ui, protocol: ui, username: ui, password: ui, hostname: ui, port: ui, search: ui, hash: ui }, t, !0)), ey(ne(this, sr).protocol) === ne(this, sr).port && (ne(this, sr).port = "");
      let u;
      for (u of Gp) {
        if (!(u in ne(this, sr))) continue;
        let d = {}, h = ne(this, sr)[u];
        switch (ne(this, Vs)[u] = [], u) {
          case "protocol":
            Object.assign(d, di), d.encodePart = ff;
            break;
          case "username":
            Object.assign(d, di), d.encodePart = Gk;
            break;
          case "password":
            Object.assign(d, di), d.encodePart = Yk;
            break;
          case "hostname":
            Object.assign(d, uN), Qv(h) ? d.encodePart = ny : d.encodePart = ty;
            break;
          case "port":
            Object.assign(d, di), d.encodePart = ry;
            break;
          case "pathname":
            Jv(ne(this, no).protocol) ? (Object.assign(d, cN, s), d.encodePart = qk) : (Object.assign(d, di, s), d.encodePart = Xk);
            break;
          case "search":
            Object.assign(d, di, s), d.encodePart = Zk;
            break;
          case "hash":
            Object.assign(d, di, s), d.encodePart = Qk;
            break;
        }
        try {
          ne(this, Fn)[u] = qv(h, d), ne(this, no)[u] = Xv(ne(this, Fn)[u], ne(this, Vs)[u], d), ne(this, St)[u] = cR(ne(this, Fn)[u], d), vt(this, _s, ne(this, _s) || ne(this, Fn)[u].some((f) => f.type === 2));
        } catch {
          throw new TypeError(`invalid ${u} pattern '${ne(this, sr)[u]}'.`);
        }
      }
    } catch (i) {
      throw new TypeError(`Failed to construct 'URLPattern': ${i.message}`);
    }
  }
  get [Symbol.toStringTag]() {
    return "URLPattern";
  }
  test(t = {}, n) {
    let r = { pathname: "", protocol: "", username: "", password: "", hostname: "", port: "", search: "", hash: "" };
    if (typeof t != "string" && n) throw new TypeError("parameter 1 is not of type 'string'.");
    if (typeof t > "u") return !1;
    try {
      typeof t == "object" ? r = is(r, t, !1) : r = is(r, tg(t, n), !1);
    } catch {
      return !1;
    }
    let i;
    for (i of Gp) if (!ne(this, no)[i].exec(r[i])) return !1;
    return !0;
  }
  exec(t = {}, n) {
    let r = { pathname: "", protocol: "", username: "", password: "", hostname: "", port: "", search: "", hash: "" };
    if (typeof t != "string" && n) throw new TypeError("parameter 1 is not of type 'string'.");
    if (typeof t > "u") return;
    try {
      typeof t == "object" ? r = is(r, t, !1) : r = is(r, tg(t, n), !1);
    } catch {
      return null;
    }
    let i = {};
    n ? i.inputs = [t, n] : i.inputs = [t];
    let s;
    for (s of Gp) {
      let l = ne(this, no)[s].exec(r[s]);
      if (!l) return null;
      let u = {};
      for (let [d, h] of ne(this, Vs)[s].entries()) if (typeof h == "string" || typeof h == "number") {
        let f = l[d + 1];
        u[h] = f;
      }
      i[s] = { input: r[s] ?? "", groups: u };
    }
    return i;
  }
  static compareComponent(t, n, r) {
    let i = xe((d, h) => {
      for (let f of ["type", "modifier", "prefix", "value", "suffix"]) {
        if (d[f] < h[f]) return -1;
        if (d[f] !== h[f])
          return 1;
      }
      return 0;
    }, "comparePart"), s = new ps(3, "", "", "", "", 3), l = new ps(0, "", "", "", "", 3), u = xe((d, h) => {
      let f = 0;
      for (; f < Math.min(d.length, h.length); ++f) {
        let m = i(d[f], h[f]);
        if (m) return m;
      }
      return d.length === h.length ? 0 : i(d[f] ?? s, h[f] ?? s);
    }, "comparePartList");
    return !ne(n, St)[t] && !ne(r, St)[t] ? 0 : ne(n, St)[t] && !ne(r, St)[t] ? u(ne(n, Fn)[t], [l]) : !ne(n, St)[t] && ne(r, St)[t] ? u([l], ne(r, Fn)[t]) : u(ne(n, Fn)[t], ne(r, Fn)[t]);
  }
  get protocol() {
    return ne(this, St).protocol;
  }
  get username() {
    return ne(this, St).username;
  }
  get password() {
    return ne(this, St).password;
  }
  get hostname() {
    return ne(this, St).hostname;
  }
  get port() {
    return ne(this, St).port;
  }
  get pathname() {
    return ne(this, St).pathname;
  }
  get search() {
    return ne(this, St).search;
  }
  get hash() {
    return ne(this, St).hash;
  }
  get hasRegExpGroups() {
    return ne(this, _s);
  }
}, sr = new WeakMap(), no = new WeakMap(), Vs = new WeakMap(), St = new WeakMap(), Fn = new WeakMap(), _s = new WeakMap(), tk);
xe(iy, "URLPattern");
globalThis.URLPattern || (globalThis.URLPattern = iy);
var dN = Object.defineProperty, fN = (e, t, n) => t in e ? dN(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, hN = (e, t, n) => fN(e, t + "", n);
let pN = class extends Map {
  constructor() {
    super(), hN(this, "metadata");
  }
};
const SE = (e) => `status=${e.status}, resolved=${e.resolved}`, kE = (e) => `loc=${e.location}`, RE = (e = {}) => [
  e.key && `key=${e.key}`,
  e.type && `type=${e.type}`
].filter((t) => t).join(", "), mN = (e) => e.reduce((t, n) => ({ ...t, [n.key]: n }), {}), gN = (e) => [...e].sort(
  (t, n) => new Date(t.inserted_at).getTime() - new Date(n.inserted_at).getTime()
), ng = "default", dR = "$default", vN = (e = []) => {
  const t = /* @__PURE__ */ new Date();
  return {
    __typename: "GuideGroup",
    key: dR,
    display_sequence: gN(e).map((n) => n.key),
    display_interval: null,
    inserted_at: t.toISOString(),
    updated_at: t.toISOString()
  };
}, fR = (e) => e.find(
  (t) => t.key === ng || t.key === dR
), yN = (e, t) => {
  const n = new Date(e);
  if (isNaN(n.getTime()))
    return !1;
  const r = n.getTime() + t * 1e3;
  return (/* @__PURE__ */ new Date()).getTime() <= r;
}, wN = (e) => {
  try {
    return new URL(e);
  } catch {
    return;
  }
}, TE = (e, t) => t.variable === "pathname" ? t.operator === "equal_to" ? (t.argument.startsWith("/") ? t.argument : `/${t.argument}`) === e.pathname : t.operator === "contains" ? e.pathname.includes(t.argument) : !1 : !1, bN = (e, t) => t.reduce((n, r) => {
  if (n === !1) return !1;
  switch (r.directive) {
    case "allow":
      return n === !0 || TE(e, r) ? !0 : void 0;
    case "block":
      return TE(e, r) ? !1 : n;
  }
}, void 0), CN = (e, t) => t.reduce((n, r) => {
  if (n === !1) return !1;
  switch (r.directive) {
    case "allow":
      return n === !0 || r.pattern.test(e) ? !0 : void 0;
    case "block":
      return r.pattern.test(e) ? !1 : n;
  }
}, void 0);
var EN = Object.defineProperty, AN = (e, t, n) => t in e ? EN(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, jn = (e, t, n) => AN(e, typeof t != "symbol" ? t + "" : t, n);
const xN = 50, SN = 30 * 1e3, kN = 3, as = {
  GUIDE_KEY: "knock_guide_key",
  PREVIEW_SESSION_ID: "knock_preview_session_id"
}, rg = "knock_guide_debug", os = () => {
  if (typeof window < "u")
    return window;
}, ig = (e) => `/v1/users/${e}/guides`, $E = () => {
  const e = os();
  if (!e)
    return { forcedGuideKey: null, previewSessionId: null };
  const t = new URLSearchParams(e.location.search), n = t.get(as.GUIDE_KEY), r = t.get(
    as.PREVIEW_SESSION_ID
  );
  if (n || r) {
    if (e.localStorage)
      try {
        const l = {
          forcedGuideKey: n,
          previewSessionId: r
        };
        e.localStorage.setItem(rg, JSON.stringify(l));
      } catch {
      }
    return {
      forcedGuideKey: n,
      previewSessionId: r
    };
  }
  let i = null, s = null;
  if (e.localStorage)
    try {
      const l = e.localStorage.getItem(rg);
      if (l) {
        const u = RN(l);
        i = u.forcedGuideKey, s = u.previewSessionId;
      }
    } catch {
    }
  return {
    forcedGuideKey: i,
    previewSessionId: s
  };
}, RN = (e) => {
  try {
    const t = JSON.parse(e);
    return {
      forcedGuideKey: (t == null ? void 0 : t.forcedGuideKey) ?? null,
      previewSessionId: (t == null ? void 0 : t.previewSessionId) ?? null
    };
  } catch {
    return {
      forcedGuideKey: null,
      previewSessionId: null
    };
  }
}, VE = (e, t = {}) => {
  const n = new pN(), r = fR(e.guideGroups);
  if (!r) return n;
  const i = [...r.display_sequence], s = e.location;
  if (e.debug.forcedGuideKey) {
    const l = i.indexOf(e.debug.forcedGuideKey);
    l > -1 && i.splice(l, 1), i.unshift(e.debug.forcedGuideKey);
  }
  for (const [l, u] of i.entries()) {
    let d = e.guides[u];
    e.debug.forcedGuideKey === u && e.previewGuides[u] && (d = e.previewGuides[u]), !(!d || !TN(d, {
      location: s,
      filters: t,
      debug: e.debug
    })) && n.set(l, d);
  }
  return n.metadata = { guideGroup: r }, n;
}, TN = (e, { location: t, filters: n = {}, debug: r = {} }) => {
  if (n.type && n.type !== e.type || n.key && n.key !== e.key)
    return !1;
  if (r.forcedGuideKey === e.key)
    return !0;
  if (!e.active || e.steps.every((u) => !!u.message.archived_at))
    return !1;
  const i = t ? wN(t) : void 0, s = e.activation_url_rules || [], l = e.activation_url_patterns || [];
  if (i && s.length > 0) {
    if (!bN(i, s)) return !1;
  } else if (i && l.length > 0 && !CN(i, l))
    return !1;
  return !0;
};
let $N = class {
  constructor(t, n, r = {}, i = {}) {
    jn(this, "store"), jn(this, "socket"), jn(this, "socketChannel"), jn(this, "socketChannelTopic"), jn(this, "socketEventTypes", [
      "guide.added",
      "guide.updated",
      "guide.removed",
      "guide_group.added",
      "guide_group.updated",
      "guide.live_preview_updated"
    ]), jn(this, "subscribeRetryCount", 0), jn(this, "pushStateFn"), jn(this, "replaceStateFn"), jn(this, "stage"), jn(this, "counterIntervalId"), jn(this, "handleLocationChange", () => {
      this.knock.log("[Guide] .handleLocationChange");
      const m = os();
      if (!(m != null && m.location)) return;
      const g = m.location.href;
      if (this.store.state.location === g) return;
      this.knock.log(`[Guide] Detected a location change: ${g}`);
      const w = this.store.state.debug, E = $E();
      this.setLocation(g, { debug: E }), this.checkDebugStateChanged(
        w,
        E
      ) && (this.knock.log(
        "[Guide] Debug state changed, refetching guides and resubscribing to the websocket channel"
      ), this.fetch(), this.subscribe());
    }), this.knock = t, this.channelId = n, this.targetParams = r, this.options = i;
    const {
      trackLocationFromWindow: s = !0,
      throttleCheckInterval: l = SN
    } = i, u = os(), d = s ? u == null ? void 0 : u.location.href : void 0, h = $E();
    this.store = new Bl({
      guideGroups: [],
      guideGroupDisplayLogs: {},
      guides: {},
      previewGuides: {},
      queries: {},
      location: d,
      // Increment to update the state store and trigger re-selection.
      counter: 0,
      debug: h
    });
    const { socket: f } = this.knock.client();
    this.socket = f, this.socketChannelTopic = `guides:${n}`, s && this.listenForLocationChangesFromWindow(), l && this.startCounterInterval(l), this.knock.log("[Guide] Initialized a guide client");
  }
  incrementCounter() {
    this.knock.log("[Guide] Incrementing the counter"), this.store.setState((t) => ({ ...t, counter: t.counter + 1 }));
  }
  startCounterInterval(t) {
    this.counterIntervalId = setInterval(() => {
      this.knock.log("[Guide] Counter interval tick"), !(this.stage && this.stage.status !== "closed") && this.incrementCounter();
    }, t);
  }
  clearCounterInterval() {
    this.counterIntervalId && (clearInterval(this.counterIntervalId), this.counterIntervalId = void 0);
  }
  cleanup() {
    this.unsubscribe(), this.removeLocationChangeEventListeners(), this.clearGroupStage(), this.clearCounterInterval();
  }
  async fetch(t) {
    this.knock.log("[Guide] .fetch"), this.knock.failIfNotAuthenticated();
    const n = this.buildQueryParams(t == null ? void 0 : t.filters), r = this.formatQueryKey(n), i = this.store.state.queries[r];
    if (i)
      return i;
    this.store.setState((l) => ({
      ...l,
      queries: { ...l.queries, [r]: { status: "loading" } }
    }));
    let s;
    try {
      this.knock.log("[Guide] Fetching all eligible guides");
      const l = await this.knock.user.getGuides(this.channelId, n);
      s = { status: "ok" };
      const { entries: u, guide_groups: d, guide_group_display_logs: h } = l;
      this.knock.log("[Guide] Loading fetched guides"), this.store.setState((f) => ({
        ...f,
        guideGroups: (d == null ? void 0 : d.length) > 0 ? d : [vN(u)],
        guideGroupDisplayLogs: h || {},
        guides: mN(u.map((m) => this.localCopy(m))),
        queries: { ...f.queries, [r]: s }
      }));
    } catch (l) {
      s = { status: "error", error: l }, this.store.setState((u) => ({
        ...u,
        queries: { ...u.queries, [r]: s }
      }));
    }
    return s;
  }
  subscribe() {
    if (!this.socket) return;
    this.knock.failIfNotAuthenticated(), this.knock.log("[Guide] Subscribing to real time updates"), this.socket.isConnected() || this.socket.connect(), this.socketChannel && this.unsubscribe();
    const t = this.store.state.debug, n = {
      ...this.targetParams,
      user_id: this.knock.userId,
      force_all_guides: t.forcedGuideKey ? !0 : void 0,
      preview_session_id: t.previewSessionId || void 0
    }, r = this.socket.channel(this.socketChannelTopic, n);
    for (const i of this.socketEventTypes)
      r.on(i, (s) => this.handleSocketEvent(s));
    ["closed", "errored"].includes(r.state) && (this.subscribeRetryCount = 0, r.join().receive("ok", () => {
      this.knock.log("[Guide] Successfully joined channel");
    }).receive("error", (i) => {
      this.knock.log(
        `[Guide] Failed to join channel: ${JSON.stringify(i)}`
      ), this.handleChannelJoinError();
    }).receive("timeout", () => {
      this.knock.log("[Guide] Channel join timed out"), this.handleChannelJoinError();
    })), this.socketChannel = r;
  }
  handleChannelJoinError() {
    if (this.subscribeRetryCount >= kN) {
      this.knock.log(
        `[Guide] Channel join max retry limit reached: ${this.subscribeRetryCount}`
      ), this.unsubscribe();
      return;
    }
    this.subscribeRetryCount++;
  }
  unsubscribe() {
    if (this.socketChannel) {
      this.knock.log("[Guide] Unsubscribing from real time updates");
      for (const t of this.socketEventTypes)
        this.socketChannel.off(t);
      this.socketChannel.leave(), this.socketChannel = void 0;
    }
  }
  handleSocketEvent(t) {
    const { event: n, data: r } = t;
    switch (n) {
      case "guide.added":
        return this.addOrReplaceGuide(t);
      case "guide.updated":
        return r.eligible ? this.addOrReplaceGuide(t) : this.removeGuide(t);
      case "guide.removed":
        return this.removeGuide(t);
      case "guide_group.added":
      case "guide_group.updated":
        return this.addOrReplaceGuideGroup(t);
      case "guide.live_preview_updated":
        return this.updatePreviewGuide(t);
      default:
        return;
    }
  }
  setLocation(t, n = {}) {
    this.knock.log(`[Guide] .setLocation (loc=${t})`), this.clearGroupStage(), this.knock.log("[Guide] Updating the tracked location"), this.store.setState((r) => {
      var i;
      const s = (i = n == null ? void 0 : n.debug) != null && i.previewSessionId ? r.previewGuides : {};
      return {
        ...r,
        ...n,
        previewGuides: s,
        location: t
      };
    });
  }
  exitDebugMode() {
    this.knock.log("[Guide] Exiting debug mode");
    const t = os();
    if (t != null && t.localStorage)
      try {
        t.localStorage.removeItem(rg);
      } catch {
      }
    if (this.store.setState((n) => ({
      ...n,
      debug: { forcedGuideKey: null, previewSessionId: null },
      previewGuides: {}
      // Clear preview guides when exiting debug mode
    })), t) {
      const n = new URL(t.location.href);
      (n.searchParams.has(as.GUIDE_KEY) || n.searchParams.has(as.PREVIEW_SESSION_ID)) && (n.searchParams.delete(as.GUIDE_KEY), n.searchParams.delete(as.PREVIEW_SESSION_ID), t.location.href = n.toString());
    }
  }
  //
  // Store selector
  //
  selectGuides(t, n = {}) {
    if (this.knock.log(
      `[Guide] .selectGuides (filters: ${RE(n)}; state: ${kE(t)})`
    ), Object.keys(t.guides).length === 0 && Object.keys(t.previewGuides).length === 0)
      return this.knock.log("[Guide] Exiting selection (no guides)"), [];
    const r = VE(t, n);
    return r.size === 0 ? (this.knock.log("[Guide] Selection returned zero result"), []) : [...r.values()];
  }
  selectGuide(t, n = {}) {
    if (this.knock.log(
      `[Guide] .selectGuide (filters: ${RE(n)}; state: ${kE(t)})`
    ), Object.keys(t.guides).length === 0 && Object.keys(t.previewGuides).length === 0) {
      this.knock.log("[Guide] Exiting selection (no guides)");
      return;
    }
    const r = VE(t, n);
    if (r.size === 0) {
      this.knock.log("[Guide] Selection found zero result");
      return;
    }
    const [i, s] = [...r][0];
    if (this.knock.log(
      `[Guide] Selection found: \`${s.key}\` (total: ${r.size})`
    ), s.bypass_global_group_limit)
      return this.knock.log(`[Guide] Returning the unthrottled guide: ${s.key}`), s;
    const l = fR(t.guideGroups), u = t.guideGroupDisplayLogs[ng];
    if (l && l.display_interval && u && yN(
      u,
      l.display_interval
    )) {
      this.knock.log(`[Guide] Throttling the selected guide: ${s.key}`);
      return;
    }
    switch (this.stage || (this.stage = this.openGroupStage()), this.stage.status) {
      case "open": {
        this.knock.log(`[Guide] Adding to the group stage: ${s.key}`), this.stage.ordered[i] = s.key;
        return;
      }
      case "patch": {
        this.knock.log(`[Guide] Patching the group stage: ${s.key}`), this.stage.ordered[i] = s.key;
        const d = this.stage.resolved === s.key ? s : void 0;
        return this.knock.log(
          `[Guide] Returning \`${d == null ? void 0 : d.key}\` (stage: ${SE(this.stage)})`
        ), d;
      }
      case "closed": {
        const d = this.stage.resolved === s.key ? s : void 0;
        return this.knock.log(
          `[Guide] Returning \`${d == null ? void 0 : d.key}\` (stage: ${SE(this.stage)})`
        ), d;
      }
    }
  }
  openGroupStage() {
    this.knock.log("[Guide] Opening a new group stage");
    const {
      orderResolutionDuration: t = xN
    } = this.options, n = setTimeout(() => {
      this.closePendingGroupStage(), this.incrementCounter();
    }, t);
    return this.stage = {
      status: "open",
      ordered: [],
      timeoutId: n
    }, this.stage;
  }
  // Close the current non-closed stage to resolve the prevailing guide up next
  // for display amongst the ones that have been staged.
  closePendingGroupStage() {
    if (this.knock.log("[Guide] .closePendingGroupStage"), !this.stage || this.stage.status === "closed") return;
    this.ensureClearTimeout();
    let t;
    return this.store.state.debug.forcedGuideKey && (t = this.stage.ordered.find(
      (n) => n === this.store.state.debug.forcedGuideKey
    )), t || (t = this.stage.ordered.find((n) => n !== void 0)), this.knock.log(
      `[Guide] Closing the current group stage: resolved=${t}`
    ), this.stage = {
      ...this.stage,
      status: "closed",
      resolved: t,
      timeoutId: null
    }, this.stage;
  }
  // Set the current closed stage status to "patch" to allow re-running
  // selections and re-building a group stage with the latest/updated state,
  // while keeping the currently resolved guide in place so that it stays
  // rendered until we are ready to resolve the updated stage and re-render.
  // Note, must be called ahead of updating the state store.
  patchClosedGroupStage() {
    var t;
    if (this.knock.log("[Guide] .patchClosedGroupStage"), ((t = this.stage) == null ? void 0 : t.status) !== "closed") return;
    const { orderResolutionDuration: n = 0 } = this.options, r = setTimeout(() => {
      this.closePendingGroupStage(), this.incrementCounter();
    }, n);
    return this.ensureClearTimeout(), this.knock.log("[Guide] Patching the current group stage"), this.stage = {
      ...this.stage,
      status: "patch",
      ordered: [],
      timeoutId: r
    }, this.stage;
  }
  clearGroupStage() {
    this.knock.log("[Guide] .clearGroupStage"), this.stage && (this.knock.log("[Guide] Clearing the current group stage"), this.ensureClearTimeout(), this.stage = void 0);
  }
  ensureClearTimeout() {
    var t;
    (t = this.stage) != null && t.timeoutId && clearTimeout(this.stage.timeoutId);
  }
  // Test helper that opens and closes the group stage to return the select
  // result immediately.
  _selectGuide(t, n = {}) {
    return this.openGroupStage(), this.selectGuide(t, n), this.closePendingGroupStage(), this.selectGuide(t, n);
  }
  //
  // Engagement event handlers
  //
  // Make an optimistic update on the client side first, then send an engagement
  // event to the backend.
  //
  async markAsSeen(t, n) {
    if (n.message.seen_at) return;
    this.knock.log(
      `[Guide] Marking as seen (Guide key: ${t.key}, Step ref:${n.ref})`
    );
    const r = this.setStepMessageAttrs(t.key, n.ref, {
      seen_at: (/* @__PURE__ */ new Date()).toISOString()
    });
    if (!r) return;
    const i = {
      ...this.buildEngagementEventBaseParams(t, r),
      content: r.content,
      data: this.targetParams.data,
      tenant: this.targetParams.tenant
    };
    return this.knock.user.markGuideStepAs(
      "seen",
      i
    ), r;
  }
  async markAsInteracted(t, n, r) {
    this.knock.log(
      `[Guide] Marking as interacted (Guide key: ${t.key}; Step ref:${n.ref})`
    );
    const i = (/* @__PURE__ */ new Date()).toISOString(), s = this.setStepMessageAttrs(t.key, n.ref, {
      read_at: i,
      interacted_at: i
    });
    if (!s) return;
    const l = {
      ...this.buildEngagementEventBaseParams(t, s),
      metadata: r
    };
    return this.knock.user.markGuideStepAs("interacted", l), s;
  }
  async markAsArchived(t, n) {
    if (n.message.archived_at) return;
    this.knock.log(
      `[Guide] Marking as archived (Guide key: ${t.key}, Step ref:${n.ref})`
    );
    const r = this.setStepMessageAttrs(t.key, n.ref, {
      archived_at: (/* @__PURE__ */ new Date()).toISOString()
    });
    if (!r) return;
    const i = this.buildEngagementEventBaseParams(t, r);
    return this.knock.user.markGuideStepAs(
      "archived",
      {
        ...i,
        unthrottled: t.bypass_global_group_limit
      }
    ), r;
  }
  //
  // Helpers
  //
  localCopy(t) {
    const n = this, r = {
      ...t,
      // Get the next unarchived step.
      getStep() {
        return n.store.state.debug.forcedGuideKey === this.key ? this.steps[0] : this.steps.find((i) => !i.message.archived_at);
      }
    };
    return r.getStep = r.getStep.bind(r), r.steps = t.steps.map(({ message: i, ...s }) => {
      const l = {
        ...s,
        message: { ...i },
        markAsSeen() {
          if (!this.message.seen_at)
            return n.markAsSeen(r, this);
        },
        markAsInteracted({ metadata: u } = {}) {
          return n.markAsInteracted(r, this, u);
        },
        markAsArchived() {
          if (!this.message.archived_at)
            return n.markAsArchived(r, this);
        }
      };
      return l.markAsSeen = l.markAsSeen.bind(l), l.markAsInteracted = l.markAsInteracted.bind(l), l.markAsArchived = l.markAsArchived.bind(l), l;
    }), r.activation_url_patterns = t.activation_url_patterns.map((i) => ({
      ...i,
      pattern: new iy({ pathname: i.pathname })
    })), r;
  }
  buildQueryParams(t = {}) {
    const n = {
      ...this.targetParams,
      ...t
    };
    this.store.state.debug.forcedGuideKey && (n.force_all_guides = !0);
    let r = Object.fromEntries(
      Object.entries(n).filter(
        ([i, s]) => s != null
      )
    );
    return r = r.data ? { ...r, data: JSON.stringify(r.data) } : r, r;
  }
  formatQueryKey(t) {
    const n = Object.keys(t).sort().map(
      (i) => `${encodeURIComponent(i)}=${encodeURIComponent(t[i])}`
    ).join("&"), r = ig(this.knock.userId);
    return n ? `${r}?${n}` : r;
  }
  setStepMessageAttrs(t, n, r) {
    let i;
    return r.archived_at && this.clearGroupStage(), this.store.setState((s) => {
      let l = s.guides[t];
      if (!l) return s;
      const u = l.steps.map((f) => (f.ref !== n || (f.message = { ...f.message, ...r }, i = f), f));
      l = i ? { ...l, steps: u } : l;
      const d = { ...s.guides, [l.key]: l }, h = r.archived_at && !l.bypass_global_group_limit ? {
        ...s.guideGroupDisplayLogs,
        [ng]: r.archived_at
      } : s.guideGroupDisplayLogs;
      return { ...s, guides: d, guideGroupDisplayLogs: h };
    }), i;
  }
  buildEngagementEventBaseParams(t, n) {
    return {
      channel_id: t.channel_id,
      guide_key: t.key,
      guide_id: t.id,
      guide_step_ref: n.ref
    };
  }
  addOrReplaceGuide({ data: t }) {
    this.patchClosedGroupStage();
    const n = this.localCopy(t.guide);
    this.store.setState((r) => {
      const i = { ...r.guides, [n.key]: n };
      return { ...r, guides: i };
    });
  }
  removeGuide({ data: t }) {
    this.patchClosedGroupStage(), this.store.setState((n) => {
      const { [t.guide.key]: r, ...i } = n.guides;
      return { ...n, guides: i };
    });
  }
  addOrReplaceGuideGroup({
    data: t
  }) {
    this.patchClosedGroupStage(), this.store.setState((n) => {
      const r = [t.guide_group], i = t.guide_group.display_sequence_unthrottled || [], s = t.guide_group.display_sequence_throttled || [];
      let l = n.guides;
      return l = i.reduce((u, d) => {
        if (!u[d]) return u;
        const h = { ...u[d], bypass_global_group_limit: !0 };
        return { ...u, [d]: h };
      }, l), l = s.reduce((u, d) => {
        if (!u[d]) return u;
        const h = { ...u[d], bypass_global_group_limit: !1 };
        return { ...u, [d]: h };
      }, l), { ...n, guides: l, guideGroups: r };
    });
  }
  updatePreviewGuide({ data: t }) {
    const n = this.localCopy(t.guide);
    this.store.setState((r) => {
      const i = { ...r.previewGuides, [n.key]: n };
      return { ...r, previewGuides: i };
    });
  }
  // Returns whether debug params have changed. For guide key, we only check
  // presence since the exact value has no impact on fetch/subscribe
  checkDebugStateChanged(t, n) {
    return !!t.forcedGuideKey != !!n.forcedGuideKey || t.previewSessionId !== n.previewSessionId;
  }
  listenForLocationChangesFromWindow() {
    const t = os();
    if (t != null && t.history) {
      t.addEventListener("popstate", this.handleLocationChange), t.addEventListener("hashchange", this.handleLocationChange);
      const n = t.history.pushState, r = t.history.replaceState;
      t.history.pushState = new Proxy(n, {
        apply: (i, s, l) => {
          Reflect.apply(i, s, l), setTimeout(() => {
            this.handleLocationChange();
          }, 0);
        }
      }), t.history.replaceState = new Proxy(r, {
        apply: (i, s, l) => {
          Reflect.apply(i, s, l), setTimeout(() => {
            this.handleLocationChange();
          }, 0);
        }
      }), this.pushStateFn = n, this.replaceStateFn = r;
    } else
      this.knock.log(
        "[Guide] Unable to access the `window.history` object to detect location changes"
      );
  }
  removeLocationChangeEventListeners() {
    const t = os();
    t != null && t.history && (t.removeEventListener("popstate", this.handleLocationChange), t.removeEventListener("hashchange", this.handleLocationChange), this.pushStateFn && (t.history.pushState = this.pushStateFn, this.pushStateFn = void 0), this.replaceStateFn && (t.history.replaceState = this.replaceStateFn, this.replaceStateFn = void 0));
  }
};
var VN = Object.defineProperty, _N = (e, t, n) => t in e ? VN(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, IN = (e, t, n) => _N(e, t + "", n);
const _E = "default";
let LN = class {
  constructor(t) {
    IN(this, "instance"), this.instance = t;
  }
  async get() {
    this.instance.failIfNotAuthenticated();
    const t = await this.instance.client().makeRequest({
      method: "GET",
      url: `/v1/users/${this.instance.userId}`
    });
    return this.handleResponse(t);
  }
  async identify(t = {}) {
    this.instance.failIfNotAuthenticated();
    const n = await this.instance.client().makeRequest({
      method: "PUT",
      url: `/v1/users/${this.instance.userId}`,
      data: t
    });
    return this.handleResponse(n);
  }
  async getAllPreferences() {
    this.instance.failIfNotAuthenticated();
    const t = await this.instance.client().makeRequest({
      method: "GET",
      url: `/v1/users/${this.instance.userId}/preferences`
    });
    return this.handleResponse(t);
  }
  async getPreferences(t = {}) {
    this.instance.failIfNotAuthenticated();
    const n = t.preferenceSet || _E, r = await this.instance.client().makeRequest({
      method: "GET",
      url: `/v1/users/${this.instance.userId}/preferences/${n}`,
      params: { tenant: t.tenant }
    });
    return this.handleResponse(r);
  }
  async setPreferences(t, n = {}) {
    this.instance.failIfNotAuthenticated();
    const r = n.preferenceSet || _E, i = await this.instance.client().makeRequest({
      method: "PUT",
      url: `/v1/users/${this.instance.userId}/preferences/${r}`,
      data: t
    });
    return this.handleResponse(i);
  }
  async getChannelData(t) {
    this.instance.failIfNotAuthenticated();
    const n = await this.instance.client().makeRequest({
      method: "GET",
      url: `/v1/users/${this.instance.userId}/channel_data/${t.channelId}`
    });
    return this.handleResponse(n);
  }
  async setChannelData({
    channelId: t,
    channelData: n
  }) {
    this.instance.failIfNotAuthenticated();
    const r = await this.instance.client().makeRequest({
      method: "PUT",
      url: `/v1/users/${this.instance.userId}/channel_data/${t}`,
      data: { data: n }
    });
    return this.handleResponse(r);
  }
  async getGuides(t, n) {
    const r = await this.instance.client().makeRequest({
      method: "GET",
      url: `${ig(this.instance.userId)}/${t}`,
      params: n
    });
    return this.handleResponse(r);
  }
  async markGuideStepAs(t, n) {
    const r = await this.instance.client().makeRequest({
      method: "PUT",
      url: `${ig(this.instance.userId)}/messages/${t}`,
      data: n
    });
    return this.handleResponse(r);
  }
  handleResponse(t) {
    if (t.statusCode === "error")
      throw new Error(t.error || t.body);
    return t.body;
  }
};
var PN = Object.defineProperty, MN = (e, t, n) => t in e ? PN(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, qt = (e, t, n) => MN(e, typeof t != "symbol" ? t + "" : t, n);
const ON = "https://api.knock.app";
let BN = class {
  constructor(t, n = {}) {
    if (qt(this, "host"), qt(this, "apiClient", null), qt(this, "userId"), qt(this, "userToken"), qt(this, "logLevel"), qt(this, "branch"), qt(this, "tokenExpirationTimer", null), qt(this, "feeds", new OO(this)), qt(this, "objects", new Z3(this)), qt(this, "preferences", new tN(this)), qt(this, "slack", new oN(this)), qt(this, "msTeams", new G3(this)), qt(this, "user", new LN(this)), qt(this, "messages", new W3(this)), this.apiKey = t, this.host = n.host || ON, this.logLevel = n.logLevel, this.branch = n.branch || void 0, this.log("Initialized Knock instance"), this.apiKey && this.apiKey.startsWith("sk_"))
      throw new Error(
        "[Knock] You are using your secret API key on the client. Please use the public key."
      );
  }
  client() {
    return this.apiClient || (this.apiClient = this.createApiClient()), this.apiClient;
  }
  authenticate(t, n, r) {
    let i = !1;
    const s = this.apiClient, l = this.getUserId(t), u = (r == null ? void 0 : r.identificationStrategy) || "inline";
    if (s && (this.userId !== l || this.userToken !== n) && (this.log("userId or userToken changed; reinitializing connections"), this.feeds.teardownInstances(), this.teardown(), i = !0), this.userId = l, this.userToken = n, this.log(`Authenticated with userId ${l}`), this.userToken && (r == null ? void 0 : r.onUserTokenExpiring) instanceof Function && this.maybeScheduleUserTokenExpiration(
      r.onUserTokenExpiring,
      r.timeBeforeExpirationInMs
    ), i && (this.apiClient = this.createApiClient(), this.feeds.reinitializeInstances(), this.log("Reinitialized real-time connections")), u === "skip") {
      this.log("Skipping inline user identification");
      return;
    }
    if (u === "inline" && typeof t == "object" && t != null && t.id) {
      this.log(`Identifying user ${t.id} inline`);
      const { id: d, ...h } = t;
      this.user.identify(h).catch((f) => {
        const m = f instanceof Error ? f.message : "Unknown error";
        this.log(
          `Error identifying user ${t.id} inline:
${m}`
        );
      });
    }
  }
  failIfNotAuthenticated() {
    if (!this.isAuthenticated())
      throw new Error("Not authenticated. Please call `authenticate` first.");
  }
  /*
    Returns whether or this Knock instance is authenticated. Passing `true` will check the presence
    of the userToken as well.
  */
  isAuthenticated(t = !1) {
    return t ? !!(this.userId && this.userToken) : !!this.userId;
  }
  // Used to teardown any connected instances
  teardown() {
    var t;
    this.tokenExpirationTimer && clearTimeout(this.tokenExpirationTimer), (t = this.apiClient) != null && t.socket && this.apiClient.socket.isConnected() && this.apiClient.socket.disconnect();
  }
  log(t, n = !1) {
    (this.logLevel === "debug" || n) && console.log(`[Knock] ${t}`);
  }
  /**
   * Initiates an API client
   */
  createApiClient() {
    return new D3({
      apiKey: this.apiKey,
      host: this.host,
      userToken: this.userToken,
      branch: this.branch
    });
  }
  async maybeScheduleUserTokenExpiration(t, n = 3e4) {
    if (!this.userToken) return;
    const r = DO(this.userToken), i = (r.exp ?? 0) * 1e3, s = Date.now();
    if (i && i > s) {
      const l = i - n - s;
      this.tokenExpirationTimer = setTimeout(async () => {
        const u = await t(this.userToken, r);
        typeof u == "string" && this.authenticate(this.userId, u, {
          onUserTokenExpiring: t,
          timeBeforeExpirationInMs: n
        });
      }, l);
    }
  }
  /**
   * Returns the user id from the given userIdOrUserWithProperties
   * @param userIdOrUserWithProperties - The user id or user object
   * @returns The user id
   * @throws {Error} If the user object does not contain an `id` property
   */
  getUserId(t) {
    if (typeof t == "string" || !t)
      return t;
    if (t != null && t.id)
      return t.id;
  }
};
var Yp, IE;
function NN() {
  return IE || (IE = 1, Yp = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, i, s;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (i = r; i-- !== 0; )
          if (!e(t[i], n[i])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (s = Object.keys(t), r = s.length, r !== Object.keys(n).length) return !1;
      for (i = r; i-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(n, s[i])) return !1;
      for (i = r; i-- !== 0; ) {
        var l = s[i];
        if (!e(t[l], n[l])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), Yp;
}
var DN = NN();
const jN = /* @__PURE__ */ ru(DN);
function og(e) {
  const t = C.useRef(void 0);
  return C.useMemo(() => {
    const n = t.current;
    return n && jN(e, n) ? n : (t.current = e, e);
  }, [e]);
}
const FN = 365.2425, UN = 6048e5, WN = 864e5, oy = 6e4, sy = 36e5, hR = 3600, zN = 60, ay = hR * 24, HN = ay * 7, pR = ay * FN, mR = pR / 12, KN = mR * 3, LE = Symbol.for("constructDateFrom");
function ly(e, t) {
  return typeof e == "function" ? e(t) : e && typeof e == "object" && LE in e ? e[LE](t) : e instanceof Date ? new e.constructor(t) : new Date(t);
}
function wi(e, t) {
  return ly(e, e);
}
let GN = {};
function YN() {
  return GN;
}
function PE(e, t) {
  var u, d;
  const n = YN(), r = n.weekStartsOn ?? ((d = (u = n.locale) == null ? void 0 : u.options) == null ? void 0 : d.weekStartsOn) ?? 0, i = wi(e), s = i.getDay(), l = (s < r ? 7 : 0) + s - r;
  return i.setDate(i.getDate() - l), i.setHours(0, 0, 0, 0), i;
}
function Td(e) {
  const t = wi(e), n = new Date(
    Date.UTC(
      t.getFullYear(),
      t.getMonth(),
      t.getDate(),
      t.getHours(),
      t.getMinutes(),
      t.getSeconds(),
      t.getMilliseconds()
    )
  );
  return n.setUTCFullYear(t.getFullYear()), +e - +n;
}
function xo(e, ...t) {
  const n = ly.bind(
    null,
    e || t.find((r) => typeof r == "object")
  );
  return t.map(n);
}
function ME(e, t) {
  const n = wi(e);
  return n.setHours(0, 0, 0, 0), n;
}
function qp(e, t, n) {
  const [r, i] = xo(
    n == null ? void 0 : n.in,
    e,
    t
  ), s = ME(r), l = ME(i), u = +s - Td(s), d = +l - Td(l);
  return Math.round((u - d) / WN);
}
function OE(e, t, n) {
  const [r, i] = xo(
    n == null ? void 0 : n.in,
    e,
    t
  ), s = r.getFullYear() - i.getFullYear(), l = r.getMonth() - i.getMonth();
  return s * 12 + l;
}
function BE(e, t) {
  const n = wi(e);
  return Math.trunc(n.getMonth() / 3) + 1;
}
function Xp(e, t, n) {
  const [r, i] = xo(
    n == null ? void 0 : n.in,
    e,
    t
  ), s = r.getFullYear() - i.getFullYear(), l = BE(r) - BE(i);
  return s * 4 + l;
}
function NE(e, t, n) {
  const [r, i] = xo(
    n == null ? void 0 : n.in,
    e,
    t
  ), s = PE(r), l = PE(i), u = +s - Td(s), d = +l - Td(l);
  return Math.round((u - d) / UN);
}
function Zp(e, t, n) {
  const [r, i] = xo(
    n == null ? void 0 : n.in,
    e,
    t
  );
  return r.getFullYear() - i.getFullYear();
}
function uy(e) {
  return (t) => {
    const r = (e ? Math[e] : Math.trunc)(t);
    return r === 0 ? 0 : r;
  };
}
function DE(e, t, n) {
  const [r, i] = xo(
    n == null ? void 0 : n.in,
    e,
    t
  ), s = (+r - +i) / sy;
  return uy(n == null ? void 0 : n.roundingMethod)(s);
}
function gR(e, t) {
  return +wi(e) - +wi(t);
}
function jE(e, t, n) {
  const r = gR(e, t) / oy;
  return uy(n == null ? void 0 : n.roundingMethod)(r);
}
function Qp(e, t, n) {
  const r = gR(e, t) / 1e3;
  return uy(n == null ? void 0 : n.roundingMethod)(r);
}
function qN(e, t, n) {
  let r = 0, i;
  const [s, l] = xo(
    n == null ? void 0 : n.in,
    e,
    t
  );
  if (n != null && n.unit)
    i = n == null ? void 0 : n.unit, i === "second" ? r = Qp(s, l) : i === "minute" ? r = jE(s, l) : i === "hour" ? r = DE(s, l) : i === "day" ? r = qp(s, l) : i === "week" ? r = NE(s, l) : i === "month" ? r = OE(s, l) : i === "quarter" ? r = Xp(s, l) : i === "year" && (r = Zp(s, l));
  else {
    const d = Qp(s, l);
    Math.abs(d) < zN ? (r = Qp(s, l), i = "second") : Math.abs(d) < hR ? (r = jE(s, l), i = "minute") : Math.abs(d) < ay && Math.abs(qp(s, l)) < 1 ? (r = DE(s, l), i = "hour") : Math.abs(d) < HN && (r = qp(s, l)) && Math.abs(r) < 7 ? i = "day" : Math.abs(d) < mR ? (r = NE(s, l), i = "week") : Math.abs(d) < KN ? (r = OE(s, l), i = "month") : Math.abs(d) < pR && Xp(s, l) < 4 ? (r = Xp(s, l), i = "quarter") : (r = Zp(s, l), i = "year");
  }
  return new Intl.RelativeTimeFormat(n == null ? void 0 : n.locale, {
    numeric: "auto",
    ...n
  }).format(r, i);
}
function XN(e, t) {
  const n = () => ly(t == null ? void 0 : t.in, NaN), i = eD(e);
  let s;
  if (i.date) {
    const h = tD(i.date, 2);
    s = nD(h.restDateString, h.year);
  }
  if (!s || isNaN(+s)) return n();
  const l = +s;
  let u = 0, d;
  if (i.time && (u = rD(i.time), isNaN(u)))
    return n();
  if (i.timezone) {
    if (d = iD(i.timezone), isNaN(d)) return n();
  } else {
    const h = new Date(l + u), f = wi(0);
    return f.setFullYear(
      h.getUTCFullYear(),
      h.getUTCMonth(),
      h.getUTCDate()
    ), f.setHours(
      h.getUTCHours(),
      h.getUTCMinutes(),
      h.getUTCSeconds(),
      h.getUTCMilliseconds()
    ), f;
  }
  return wi(l + u + d);
}
const Fc = {
  dateTimeDelimiter: /[T ]/,
  timeZoneDelimiter: /[Z ]/i,
  timezone: /([Z+-].*)$/
}, ZN = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/, QN = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/, JN = /^([+-])(\d{2})(?::?(\d{2}))?$/;
function eD(e) {
  const t = {}, n = e.split(Fc.dateTimeDelimiter);
  let r;
  if (n.length > 2)
    return t;
  if (/:/.test(n[0]) ? r = n[0] : (t.date = n[0], r = n[1], Fc.timeZoneDelimiter.test(t.date) && (t.date = e.split(Fc.timeZoneDelimiter)[0], r = e.substr(
    t.date.length,
    e.length
  ))), r) {
    const i = Fc.timezone.exec(r);
    i ? (t.time = r.replace(i[1], ""), t.timezone = i[1]) : t.time = r;
  }
  return t;
}
function tD(e, t) {
  const n = new RegExp(
    "^(?:(\\d{4}|[+-]\\d{" + (4 + t) + "})|(\\d{2}|[+-]\\d{" + (2 + t) + "})$)"
  ), r = e.match(n);
  if (!r) return { year: NaN, restDateString: "" };
  const i = r[1] ? parseInt(r[1]) : null, s = r[2] ? parseInt(r[2]) : null;
  return {
    year: s === null ? i : s * 100,
    restDateString: e.slice((r[1] || r[2]).length)
  };
}
function nD(e, t) {
  if (t === null) return /* @__PURE__ */ new Date(NaN);
  const n = e.match(ZN);
  if (!n) return /* @__PURE__ */ new Date(NaN);
  const r = !!n[4], i = hl(n[1]), s = hl(n[2]) - 1, l = hl(n[3]), u = hl(n[4]), d = hl(n[5]) - 1;
  if (r)
    return uD(t, u, d) ? oD(t, u, d) : /* @__PURE__ */ new Date(NaN);
  {
    const h = /* @__PURE__ */ new Date(0);
    return !aD(t, s, l) || !lD(t, i) ? /* @__PURE__ */ new Date(NaN) : (h.setUTCFullYear(t, s, Math.max(i, l)), h);
  }
}
function hl(e) {
  return e ? parseInt(e) : 1;
}
function rD(e) {
  const t = e.match(QN);
  if (!t) return NaN;
  const n = Jp(t[1]), r = Jp(t[2]), i = Jp(t[3]);
  return cD(n, r, i) ? n * sy + r * oy + i * 1e3 : NaN;
}
function Jp(e) {
  return e && parseFloat(e.replace(",", ".")) || 0;
}
function iD(e) {
  if (e === "Z") return 0;
  const t = e.match(JN);
  if (!t) return 0;
  const n = t[1] === "+" ? -1 : 1, r = parseInt(t[2]), i = t[3] && parseInt(t[3]) || 0;
  return dD(r, i) ? n * (r * sy + i * oy) : NaN;
}
function oD(e, t, n) {
  const r = /* @__PURE__ */ new Date(0);
  r.setUTCFullYear(e, 0, 4);
  const i = r.getUTCDay() || 7, s = (t - 1) * 7 + n + 1 - i;
  return r.setUTCDate(r.getUTCDate() + s), r;
}
const sD = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function vR(e) {
  return e % 400 === 0 || e % 4 === 0 && e % 100 !== 0;
}
function aD(e, t, n) {
  return t >= 0 && t <= 11 && n >= 1 && n <= (sD[t] || (vR(e) ? 29 : 28));
}
function lD(e, t) {
  return t >= 1 && t <= (vR(e) ? 366 : 365);
}
function uD(e, t, n) {
  return t >= 1 && t <= 53 && n >= 0 && n <= 6;
}
function cD(e, t, n) {
  return e === 24 ? t === 0 && n === 0 : n >= 0 && n < 60 && t >= 0 && t < 60 && e >= 0 && e < 25;
}
function dD(e, t) {
  return t >= 0 && t <= 59;
}
function FE(e, t, n, r = {}) {
  e.authenticate(t, n, {
    onUserTokenExpiring: r == null ? void 0 : r.onUserTokenExpiring,
    timeBeforeExpirationInMs: r == null ? void 0 : r.timeBeforeExpirationInMs,
    identificationStrategy: r == null ? void 0 : r.identificationStrategy
  });
}
function fD(e, t, n, r = {}) {
  const i = j.useRef(void 0), s = og(r), l = og(t);
  return j.useMemo(() => {
    const u = typeof l == "string" ? l : l == null ? void 0 : l.id, d = i.current;
    if (d && d.isAuthenticated() && (d.userId !== u || d.userToken !== n))
      return FE(d, l, n, s), d;
    d && d.teardown();
    const h = new BN(e, {
      host: s.host,
      logLevel: s.logLevel,
      branch: s.branch
    });
    return FE(h, l, n, s), i.current = h, h;
  }, [e, l, n, s]);
}
const yR = C.createContext(null), hD = ({
  apiKey: e,
  host: t,
  logLevel: n,
  userToken: r,
  onUserTokenExpiring: i,
  timeBeforeExpirationInMs: s,
  children: l,
  i18n: u,
  identificationStrategy: d,
  branch: h,
  ...f
}) => {
  const m = (f == null ? void 0 : f.user) || (f == null ? void 0 : f.userId), g = C.useMemo(() => ({
    host: t,
    onUserTokenExpiring: i,
    timeBeforeExpirationInMs: s,
    logLevel: n,
    identificationStrategy: d,
    branch: h
  }), [t, i, s, n, d, h]), w = fD(e ?? "", m, r, g);
  return /* @__PURE__ */ C.createElement(yR.Provider, { value: {
    knock: w
  } }, /* @__PURE__ */ C.createElement(nO, { i18n: u }, l));
}, pD = () => {
  const e = C.useContext(yR);
  if (!e)
    throw new Error("useKnockClient must be used within a KnockProvider");
  return e.knock;
};
var fd = /* @__PURE__ */ ((e) => (e.All = "all", e.Read = "read", e.Unseen = "unseen", e.Unread = "unread", e))(fd || {});
function mD(e) {
  return e > 9 ? "9+" : e;
}
function gD(e, t = {}) {
  try {
    const n = XN(e);
    return qN(n, /* @__PURE__ */ new Date(), {
      locale: t.locale
    });
  } catch {
    return e;
  }
}
function UE(e, t) {
  return e !== void 0 ? e : t;
}
var em = { exports: {} }, tm = {}, nm = { exports: {} }, rm = {};
/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var WE;
function vD() {
  if (WE) return rm;
  WE = 1;
  var e = iu();
  function t(m, g) {
    return m === g && (m !== 0 || 1 / m === 1 / g) || m !== m && g !== g;
  }
  var n = typeof Object.is == "function" ? Object.is : t, r = e.useState, i = e.useEffect, s = e.useLayoutEffect, l = e.useDebugValue;
  function u(m, g) {
    var w = g(), E = r({ inst: { value: w, getSnapshot: g } }), b = E[0].inst, A = E[1];
    return s(
      function() {
        b.value = w, b.getSnapshot = g, d(b) && A({ inst: b });
      },
      [m, w, g]
    ), i(
      function() {
        return d(b) && A({ inst: b }), m(function() {
          d(b) && A({ inst: b });
        });
      },
      [m]
    ), l(w), w;
  }
  function d(m) {
    var g = m.getSnapshot;
    m = m.value;
    try {
      var w = g();
      return !n(m, w);
    } catch {
      return !0;
    }
  }
  function h(m, g) {
    return g();
  }
  var f = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? h : u;
  return rm.useSyncExternalStore = e.useSyncExternalStore !== void 0 ? e.useSyncExternalStore : f, rm;
}
var zE;
function yD() {
  return zE || (zE = 1, nm.exports = vD()), nm.exports;
}
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var HE;
function wD() {
  if (HE) return tm;
  HE = 1;
  var e = iu(), t = yD();
  function n(h, f) {
    return h === f && (h !== 0 || 1 / h === 1 / f) || h !== h && f !== f;
  }
  var r = typeof Object.is == "function" ? Object.is : n, i = t.useSyncExternalStore, s = e.useRef, l = e.useEffect, u = e.useMemo, d = e.useDebugValue;
  return tm.useSyncExternalStoreWithSelector = function(h, f, m, g, w) {
    var E = s(null);
    if (E.current === null) {
      var b = { hasValue: !1, value: null };
      E.current = b;
    } else b = E.current;
    E = u(
      function() {
        function x(O) {
          if (!R) {
            if (R = !0, _ = O, O = g(O), w !== void 0 && b.hasValue) {
              var D = b.value;
              if (w(D, O))
                return L = D;
            }
            return L = O;
          }
          if (D = L, r(_, O)) return D;
          var B = g(O);
          return w !== void 0 && w(D, B) ? (_ = O, D) : (_ = O, L = B);
        }
        var R = !1, _, L, V = m === void 0 ? null : m;
        return [
          function() {
            return x(f());
          },
          V === null ? void 0 : function() {
            return x(V());
          }
        ];
      },
      [f, m, g, w]
    );
    var A = i(h, E[0], E[1]);
    return l(
      function() {
        b.hasValue = !0, b.value = A;
      },
      [A]
    ), d(A), A;
  }, tm;
}
var KE;
function bD() {
  return KE || (KE = 1, em.exports = wD()), em.exports;
}
var CD = bD();
function ED(e, t = (n) => n) {
  return CD.useSyncExternalStoreWithSelector(
    e.subscribe,
    () => e.state,
    () => e.state,
    t,
    AD
  );
}
function AD(e, t) {
  if (Object.is(e, t))
    return !0;
  if (typeof e != "object" || e === null || typeof t != "object" || t === null)
    return !1;
  if (e instanceof Map && t instanceof Map) {
    if (e.size !== t.size) return !1;
    for (const [r, i] of e)
      if (!t.has(r) || !Object.is(i, t.get(r))) return !1;
    return !0;
  }
  if (e instanceof Set && t instanceof Set) {
    if (e.size !== t.size) return !1;
    for (const r of e)
      if (!t.has(r)) return !1;
    return !0;
  }
  if (e instanceof Date && t instanceof Date)
    return e.getTime() === t.getTime();
  const n = GE(e);
  if (n.length !== GE(t).length)
    return !1;
  for (let r = 0; r < n.length; r++)
    if (!Object.prototype.hasOwnProperty.call(t, n[r]) || !Object.is(e[n[r]], t[n[r]]))
      return !1;
  return !0;
}
function GE(e) {
  return Object.keys(e).concat(
    Object.getOwnPropertySymbols(e)
  );
}
const xD = C.createContext(void 0), uu = () => {
  const e = C.useContext(xD);
  if (!e)
    throw new Error("useKnockFeed must be used within a KnockFeedProvider");
  return e;
}, wR = C.createContext(void 0), SD = ({
  channelId: e,
  readyToTarget: t,
  listenForUpdates: n = !0,
  colorMode: r = "light",
  targetParams: i = {},
  trackLocationFromWindow: s = !0,
  // Default to 0 which works well for react apps as this "yields" to react for
  // one render cyle first and close the group stage.
  orderResolutionDuration: l = 0,
  throttleCheckInterval: u,
  children: d
}) => {
  let h;
  try {
    h = pD();
  } catch {
    throw new Error("KnockGuideProvider must be used within a KnockProvider");
  }
  const f = og(i), m = C.useMemo(() => new $N(h, e, f, {
    trackLocationFromWindow: s,
    orderResolutionDuration: l,
    throttleCheckInterval: u
  }), [h, e, f, s, l, u]);
  return C.useEffect(() => (t && (m.fetch(), n && m.subscribe()), () => m.cleanup()), [t, n, m]), /* @__PURE__ */ C.createElement(wR.Provider, { value: {
    client: m,
    colorMode: r
  } }, d);
}, kD = () => {
  const e = C.useContext(wR);
  if (!e)
    throw new Error("useGuide must be used within a KnockGuideProvider");
  return e;
}, RD = (e) => {
  const t = kD();
  if (!e.key && !e.type)
    throw new Error("useGuide must be given at least one filter: { key?: string; type?: string; }");
  const {
    client: n,
    colorMode: r
  } = t, i = ED(n.store, (l) => n.selectGuide(l, e)), s = i && i.getStep();
  return {
    client: n,
    colorMode: r,
    guide: i,
    step: s
  };
};
function bR() {
  const {
    translations: e,
    locale: t
  } = C.useContext(nk);
  return {
    locale: t,
    t: (n) => e[n] || jv.en.translations[n]
  };
}
C.createContext(null);
C.createContext(null);
function TD(e) {
  return e === "fast" ? 600 : e === "slow" ? 900 : 750;
}
const $D = ({
  color: e = "rgba(0,0,0,0.4)",
  speed: t = "medium",
  gap: n = 4,
  thickness: r = 4,
  size: i = "1em",
  ...s
}) => /* @__PURE__ */ j.createElement("svg", { height: i, width: i, ...s, style: {
  animationDuration: `${TD(t)}ms`
}, className: "__react-svg-spinner_circle", role: "img", "aria-labelledby": "title desc", viewBox: "0 0 32 32" }, /* @__PURE__ */ j.createElement("title", { id: "title" }, "Circle loading spinner"), /* @__PURE__ */ j.createElement("desc", { id: "desc" }, 'Image of a partial circle indicating "loading."'), /* @__PURE__ */ j.createElement("style", { dangerouslySetInnerHTML: {
  __html: `
      .__react-svg-spinner_circle{
          transition-property: transform;
          animation-name: __react-svg-spinner_infinite-spin;
          animation-iteration-count: infinite;
          animation-timing-function: linear;
      }
      @keyframes __react-svg-spinner_infinite-spin {
          from {transform: rotate(0deg)}
          to {transform: rotate(360deg)}
      }
    `
} }), /* @__PURE__ */ j.createElement("circle", { role: "presentation", cx: 16, cy: 16, r: 14 - r / 2, stroke: e, fill: "none", strokeWidth: r, strokeDasharray: Math.PI * 2 * (11 - n), strokeLinecap: "round" })), VD = ({
  hasLabel: e
}) => /* @__PURE__ */ j.createElement("div", { className: `rnf-button-spinner rnf-button-spinner--${e ? "with-label" : "without-label"}` }, /* @__PURE__ */ j.createElement($D, null)), _D = ({
  variant: e = "primary",
  loadingText: t,
  isLoading: n = !1,
  isDisabled: r = !1,
  isFullWidth: i = !1,
  onClick: s,
  children: l
}) => {
  const {
    colorMode: u
  } = uu(), d = ["rnf-button", `rnf-button--${e}`, i ? "rnf-button--full-width" : "", n ? "rnf-button--is-loading" : "", `rnf-button--${u}`].join(" "), h = t || /* @__PURE__ */ j.createElement("span", { className: "rnf-button__button-text-hidden" }, l);
  return /* @__PURE__ */ j.createElement("button", { onClick: s, className: d, disabled: n || r, type: "button" }, n && /* @__PURE__ */ j.createElement(VD, { hasLabel: !!t }), n ? h : l);
}, ID = ({
  children: e
}) => /* @__PURE__ */ j.createElement("div", { className: "rnf-button-group" }, e), LD = ({
  width: e = 24,
  height: t = 24,
  "aria-hidden": n
}) => /* @__PURE__ */ j.createElement("svg", { width: e, viewBox: "0 0 24 24", fill: "none", height: t, "aria-hidden": n }, /* @__PURE__ */ j.createElement("path", { d: "M20.0474 16.4728C18.8436 14.9996 17.9938 14.2496 17.9938 10.1879C17.9938 6.46832 16.0944 5.14317 14.5311 4.49957C14.3235 4.41426 14.128 4.21832 14.0647 4.00504C13.7905 3.07176 13.0217 2.24957 11.9999 2.24957C10.978 2.24957 10.2088 3.07223 9.93736 4.00598C9.87408 4.2216 9.67861 4.41426 9.47096 4.49957C7.9058 5.1441 6.0083 6.46457 6.0083 10.1879C6.00596 14.2496 5.15611 14.9996 3.95237 16.4728C3.45362 17.0832 3.89049 17.9996 4.76283 17.9996H19.2416C20.1092 17.9996 20.5433 17.0803 20.0474 16.4728Z", stroke: "currentColor", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" }), /* @__PURE__ */ j.createElement("path", { d: "M14.9999 17.9988V18.7488C14.9999 19.5445 14.6838 20.3075 14.1212 20.8701C13.5586 21.4327 12.7955 21.7488 11.9999 21.7488C11.2042 21.7488 10.4412 21.4327 9.87856 20.8701C9.31595 20.3075 8.99988 19.5445 8.99988 18.7488V17.9988", stroke: "currentColor", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" })), PD = ({
  width: e = 14,
  height: t = 14,
  "aria-hidden": n
}) => /* @__PURE__ */ j.createElement("svg", { width: e, height: t, viewBox: "0 0 14 14", fill: "none", xmlns: "http://www.w3.org/2000/svg", "aria-hidden": n }, /* @__PURE__ */ j.createElement("path", { d: "M7.00012 0.499939C3.41606 0.499939 0.500122 3.41588 0.500122 6.99994C0.500122 10.584 3.41606 13.4999 7.00012 13.4999C10.5842 13.4999 13.5001 10.584 13.5001 6.99994C13.5001 3.41588 10.5842 0.499939 7.00012 0.499939ZM9.35356 8.6465C9.40194 8.69247 9.44063 8.74766 9.46735 8.80881C9.49407 8.86997 9.50828 8.93585 9.50913 9.00259C9.50999 9.06932 9.49747 9.13555 9.47233 9.19737C9.44718 9.25919 9.40992 9.31535 9.36273 9.36254C9.31553 9.40973 9.25937 9.447 9.19755 9.47214C9.13573 9.49729 9.0695 9.5098 9.00277 9.50895C8.93604 9.50809 8.87015 9.49389 8.809 9.46717C8.74784 9.44045 8.69265 9.40176 8.64668 9.35337L7.00012 7.70712L5.35356 9.35337C5.25903 9.44318 5.13315 9.49251 5.00277 9.49084C4.87239 9.48918 4.74782 9.43664 4.65562 9.34444C4.56342 9.25224 4.51088 9.12767 4.50921 8.99729C4.50755 8.86691 4.55687 8.74103 4.64668 8.6465L6.29293 6.99994L4.64668 5.35338C4.55687 5.25884 4.50755 5.13297 4.50921 5.00259C4.51088 4.87221 4.56342 4.74764 4.65562 4.65544C4.74782 4.56324 4.87239 4.5107 5.00277 4.50903C5.13315 4.50736 5.25903 4.55669 5.35356 4.6465L7.00012 6.29275L8.64668 4.6465C8.74121 4.55669 8.86709 4.50736 8.99747 4.50903C9.12785 4.5107 9.25242 4.56324 9.34462 4.65544C9.43682 4.74764 9.48936 4.87221 9.49103 5.00259C9.4927 5.13297 9.44337 5.25884 9.35356 5.35338L7.70731 6.99994L9.35356 8.6465Z", fill: "currentColor" }));
var im, YE;
function MD() {
  if (YE) return im;
  YE = 1;
  var e = "Expected a function", t = NaN, n = "[object Symbol]", r = /^\s+|\s+$/g, i = /^[-+]0x[0-9a-f]+$/i, s = /^0b[01]+$/i, l = /^0o[0-7]+$/i, u = parseInt, d = typeof Oc == "object" && Oc && Oc.Object === Object && Oc, h = typeof self == "object" && self && self.Object === Object && self, f = d || h || Function("return this")(), m = Object.prototype, g = m.toString, w = Math.max, E = Math.min, b = function() {
    return f.Date.now();
  };
  function A(V, O, D) {
    var B, H, J, ce, fe, de, he = 0, le = !1, Y = !1, te = !0;
    if (typeof V != "function")
      throw new TypeError(e);
    O = L(O) || 0, x(D) && (le = !!D.leading, Y = "maxWait" in D, J = Y ? w(L(D.maxWait) || 0, O) : J, te = "trailing" in D ? !!D.trailing : te);
    function S(q) {
      var re = B, ve = H;
      return B = H = void 0, he = q, ce = V.apply(ve, re), ce;
    }
    function T(q) {
      return he = q, fe = setTimeout(M, O), le ? S(q) : ce;
    }
    function P(q) {
      var re = q - de, ve = q - he, Ce = O - re;
      return Y ? E(Ce, J - ve) : Ce;
    }
    function $(q) {
      var re = q - de, ve = q - he;
      return de === void 0 || re >= O || re < 0 || Y && ve >= J;
    }
    function M() {
      var q = b();
      if ($(q))
        return W(q);
      fe = setTimeout(M, P(q));
    }
    function W(q) {
      return fe = void 0, te && B ? S(q) : (B = H = void 0, ce);
    }
    function G() {
      fe !== void 0 && clearTimeout(fe), he = 0, B = de = H = fe = void 0;
    }
    function ee() {
      return fe === void 0 ? ce : W(b());
    }
    function Q() {
      var q = b(), re = $(q);
      if (B = arguments, H = this, de = q, re) {
        if (fe === void 0)
          return T(de);
        if (Y)
          return fe = setTimeout(M, O), S(de);
      }
      return fe === void 0 && (fe = setTimeout(M, O)), ce;
    }
    return Q.cancel = G, Q.flush = ee, Q;
  }
  function x(V) {
    var O = typeof V;
    return !!V && (O == "object" || O == "function");
  }
  function R(V) {
    return !!V && typeof V == "object";
  }
  function _(V) {
    return typeof V == "symbol" || R(V) && g.call(V) == n;
  }
  function L(V) {
    if (typeof V == "number")
      return V;
    if (_(V))
      return t;
    if (x(V)) {
      var O = typeof V.valueOf == "function" ? V.valueOf() : V;
      V = x(O) ? O + "" : O;
    }
    if (typeof V != "string")
      return V === 0 ? V : +V;
    V = V.replace(r, "");
    var D = s.test(V);
    return D || l.test(V) ? u(V.slice(2), D ? 2 : 8) : i.test(V) ? t : +V;
  }
  return im = A, im;
}
MD();
var Jt = "top", Vn = "bottom", _n = "right", en = "left", cy = "auto", cu = [Jt, Vn, _n, en], Ls = "start", Nl = "end", OD = "clippingParents", CR = "viewport", pl = "popper", BD = "reference", qE = /* @__PURE__ */ cu.reduce(function(e, t) {
  return e.concat([t + "-" + Ls, t + "-" + Nl]);
}, []), ER = /* @__PURE__ */ [].concat(cu, [cy]).reduce(function(e, t) {
  return e.concat([t, t + "-" + Ls, t + "-" + Nl]);
}, []), ND = "beforeRead", DD = "read", jD = "afterRead", FD = "beforeMain", UD = "main", WD = "afterMain", zD = "beforeWrite", HD = "write", KD = "afterWrite", GD = [ND, DD, jD, FD, UD, WD, zD, HD, KD];
function hr(e) {
  return e ? (e.nodeName || "").toLowerCase() : null;
}
function hn(e) {
  if (e == null)
    return window;
  if (e.toString() !== "[object Window]") {
    var t = e.ownerDocument;
    return t && t.defaultView || window;
  }
  return e;
}
function go(e) {
  var t = hn(e).Element;
  return e instanceof t || e instanceof Element;
}
function Tn(e) {
  var t = hn(e).HTMLElement;
  return e instanceof t || e instanceof HTMLElement;
}
function dy(e) {
  if (typeof ShadowRoot > "u")
    return !1;
  var t = hn(e).ShadowRoot;
  return e instanceof t || e instanceof ShadowRoot;
}
function YD(e) {
  var t = e.state;
  Object.keys(t.elements).forEach(function(n) {
    var r = t.styles[n] || {}, i = t.attributes[n] || {}, s = t.elements[n];
    !Tn(s) || !hr(s) || (Object.assign(s.style, r), Object.keys(i).forEach(function(l) {
      var u = i[l];
      u === !1 ? s.removeAttribute(l) : s.setAttribute(l, u === !0 ? "" : u);
    }));
  });
}
function qD(e) {
  var t = e.state, n = {
    popper: {
      position: t.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  return Object.assign(t.elements.popper.style, n.popper), t.styles = n, t.elements.arrow && Object.assign(t.elements.arrow.style, n.arrow), function() {
    Object.keys(t.elements).forEach(function(r) {
      var i = t.elements[r], s = t.attributes[r] || {}, l = Object.keys(t.styles.hasOwnProperty(r) ? t.styles[r] : n[r]), u = l.reduce(function(d, h) {
        return d[h] = "", d;
      }, {});
      !Tn(i) || !hr(i) || (Object.assign(i.style, u), Object.keys(s).forEach(function(d) {
        i.removeAttribute(d);
      }));
    });
  };
}
const XD = {
  name: "applyStyles",
  enabled: !0,
  phase: "write",
  fn: YD,
  effect: qD,
  requires: ["computeStyles"]
};
function dr(e) {
  return e.split("-")[0];
}
var oo = Math.max, $d = Math.min, Ps = Math.round;
function sg() {
  var e = navigator.userAgentData;
  return e != null && e.brands && Array.isArray(e.brands) ? e.brands.map(function(t) {
    return t.brand + "/" + t.version;
  }).join(" ") : navigator.userAgent;
}
function AR() {
  return !/^((?!chrome|android).)*safari/i.test(sg());
}
function Ms(e, t, n) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  var r = e.getBoundingClientRect(), i = 1, s = 1;
  t && Tn(e) && (i = e.offsetWidth > 0 && Ps(r.width) / e.offsetWidth || 1, s = e.offsetHeight > 0 && Ps(r.height) / e.offsetHeight || 1);
  var l = go(e) ? hn(e) : window, u = l.visualViewport, d = !AR() && n, h = (r.left + (d && u ? u.offsetLeft : 0)) / i, f = (r.top + (d && u ? u.offsetTop : 0)) / s, m = r.width / i, g = r.height / s;
  return {
    width: m,
    height: g,
    top: f,
    right: h + m,
    bottom: f + g,
    left: h,
    x: h,
    y: f
  };
}
function fy(e) {
  var t = Ms(e), n = e.offsetWidth, r = e.offsetHeight;
  return Math.abs(t.width - n) <= 1 && (n = t.width), Math.abs(t.height - r) <= 1 && (r = t.height), {
    x: e.offsetLeft,
    y: e.offsetTop,
    width: n,
    height: r
  };
}
function xR(e, t) {
  var n = t.getRootNode && t.getRootNode();
  if (e.contains(t))
    return !0;
  if (n && dy(n)) {
    var r = t;
    do {
      if (r && e.isSameNode(r))
        return !0;
      r = r.parentNode || r.host;
    } while (r);
  }
  return !1;
}
function Pr(e) {
  return hn(e).getComputedStyle(e);
}
function ZD(e) {
  return ["table", "td", "th"].indexOf(hr(e)) >= 0;
}
function Ai(e) {
  return ((go(e) ? e.ownerDocument : (
    // $FlowFixMe[prop-missing]
    e.document
  )) || window.document).documentElement;
}
function hf(e) {
  return hr(e) === "html" ? e : (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    e.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    e.parentNode || // DOM Element detected
    (dy(e) ? e.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    Ai(e)
  );
}
function XE(e) {
  return !Tn(e) || // https://github.com/popperjs/popper-core/issues/837
  Pr(e).position === "fixed" ? null : e.offsetParent;
}
function QD(e) {
  var t = /firefox/i.test(sg()), n = /Trident/i.test(sg());
  if (n && Tn(e)) {
    var r = Pr(e);
    if (r.position === "fixed")
      return null;
  }
  var i = hf(e);
  for (dy(i) && (i = i.host); Tn(i) && ["html", "body"].indexOf(hr(i)) < 0; ) {
    var s = Pr(i);
    if (s.transform !== "none" || s.perspective !== "none" || s.contain === "paint" || ["transform", "perspective"].indexOf(s.willChange) !== -1 || t && s.willChange === "filter" || t && s.filter && s.filter !== "none")
      return i;
    i = i.parentNode;
  }
  return null;
}
function du(e) {
  for (var t = hn(e), n = XE(e); n && ZD(n) && Pr(n).position === "static"; )
    n = XE(n);
  return n && (hr(n) === "html" || hr(n) === "body" && Pr(n).position === "static") ? t : n || QD(e) || t;
}
function hy(e) {
  return ["top", "bottom"].indexOf(e) >= 0 ? "x" : "y";
}
function Sl(e, t, n) {
  return oo(e, $d(t, n));
}
function JD(e, t, n) {
  var r = Sl(e, t, n);
  return r > n ? n : r;
}
function SR() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function kR(e) {
  return Object.assign({}, SR(), e);
}
function RR(e, t) {
  return t.reduce(function(n, r) {
    return n[r] = e, n;
  }, {});
}
var ej = function(t, n) {
  return t = typeof t == "function" ? t(Object.assign({}, n.rects, {
    placement: n.placement
  })) : t, kR(typeof t != "number" ? t : RR(t, cu));
};
function tj(e) {
  var t, n = e.state, r = e.name, i = e.options, s = n.elements.arrow, l = n.modifiersData.popperOffsets, u = dr(n.placement), d = hy(u), h = [en, _n].indexOf(u) >= 0, f = h ? "height" : "width";
  if (!(!s || !l)) {
    var m = ej(i.padding, n), g = fy(s), w = d === "y" ? Jt : en, E = d === "y" ? Vn : _n, b = n.rects.reference[f] + n.rects.reference[d] - l[d] - n.rects.popper[f], A = l[d] - n.rects.reference[d], x = du(s), R = x ? d === "y" ? x.clientHeight || 0 : x.clientWidth || 0 : 0, _ = b / 2 - A / 2, L = m[w], V = R - g[f] - m[E], O = R / 2 - g[f] / 2 + _, D = Sl(L, O, V), B = d;
    n.modifiersData[r] = (t = {}, t[B] = D, t.centerOffset = D - O, t);
  }
}
function nj(e) {
  var t = e.state, n = e.options, r = n.element, i = r === void 0 ? "[data-popper-arrow]" : r;
  i != null && (typeof i == "string" && (i = t.elements.popper.querySelector(i), !i) || xR(t.elements.popper, i) && (t.elements.arrow = i));
}
const rj = {
  name: "arrow",
  enabled: !0,
  phase: "main",
  fn: tj,
  effect: nj,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function Os(e) {
  return e.split("-")[1];
}
var ij = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function oj(e, t) {
  var n = e.x, r = e.y, i = t.devicePixelRatio || 1;
  return {
    x: Ps(n * i) / i || 0,
    y: Ps(r * i) / i || 0
  };
}
function ZE(e) {
  var t, n = e.popper, r = e.popperRect, i = e.placement, s = e.variation, l = e.offsets, u = e.position, d = e.gpuAcceleration, h = e.adaptive, f = e.roundOffsets, m = e.isFixed, g = l.x, w = g === void 0 ? 0 : g, E = l.y, b = E === void 0 ? 0 : E, A = typeof f == "function" ? f({
    x: w,
    y: b
  }) : {
    x: w,
    y: b
  };
  w = A.x, b = A.y;
  var x = l.hasOwnProperty("x"), R = l.hasOwnProperty("y"), _ = en, L = Jt, V = window;
  if (h) {
    var O = du(n), D = "clientHeight", B = "clientWidth";
    if (O === hn(n) && (O = Ai(n), Pr(O).position !== "static" && u === "absolute" && (D = "scrollHeight", B = "scrollWidth")), O = O, i === Jt || (i === en || i === _n) && s === Nl) {
      L = Vn;
      var H = m && O === V && V.visualViewport ? V.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        O[D]
      );
      b -= H - r.height, b *= d ? 1 : -1;
    }
    if (i === en || (i === Jt || i === Vn) && s === Nl) {
      _ = _n;
      var J = m && O === V && V.visualViewport ? V.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        O[B]
      );
      w -= J - r.width, w *= d ? 1 : -1;
    }
  }
  var ce = Object.assign({
    position: u
  }, h && ij), fe = f === !0 ? oj({
    x: w,
    y: b
  }, hn(n)) : {
    x: w,
    y: b
  };
  if (w = fe.x, b = fe.y, d) {
    var de;
    return Object.assign({}, ce, (de = {}, de[L] = R ? "0" : "", de[_] = x ? "0" : "", de.transform = (V.devicePixelRatio || 1) <= 1 ? "translate(" + w + "px, " + b + "px)" : "translate3d(" + w + "px, " + b + "px, 0)", de));
  }
  return Object.assign({}, ce, (t = {}, t[L] = R ? b + "px" : "", t[_] = x ? w + "px" : "", t.transform = "", t));
}
function sj(e) {
  var t = e.state, n = e.options, r = n.gpuAcceleration, i = r === void 0 ? !0 : r, s = n.adaptive, l = s === void 0 ? !0 : s, u = n.roundOffsets, d = u === void 0 ? !0 : u, h = {
    placement: dr(t.placement),
    variation: Os(t.placement),
    popper: t.elements.popper,
    popperRect: t.rects.popper,
    gpuAcceleration: i,
    isFixed: t.options.strategy === "fixed"
  };
  t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, ZE(Object.assign({}, h, {
    offsets: t.modifiersData.popperOffsets,
    position: t.options.strategy,
    adaptive: l,
    roundOffsets: d
  })))), t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, ZE(Object.assign({}, h, {
    offsets: t.modifiersData.arrow,
    position: "absolute",
    adaptive: !1,
    roundOffsets: d
  })))), t.attributes.popper = Object.assign({}, t.attributes.popper, {
    "data-popper-placement": t.placement
  });
}
const aj = {
  name: "computeStyles",
  enabled: !0,
  phase: "beforeWrite",
  fn: sj,
  data: {}
};
var Uc = {
  passive: !0
};
function lj(e) {
  var t = e.state, n = e.instance, r = e.options, i = r.scroll, s = i === void 0 ? !0 : i, l = r.resize, u = l === void 0 ? !0 : l, d = hn(t.elements.popper), h = [].concat(t.scrollParents.reference, t.scrollParents.popper);
  return s && h.forEach(function(f) {
    f.addEventListener("scroll", n.update, Uc);
  }), u && d.addEventListener("resize", n.update, Uc), function() {
    s && h.forEach(function(f) {
      f.removeEventListener("scroll", n.update, Uc);
    }), u && d.removeEventListener("resize", n.update, Uc);
  };
}
const uj = {
  name: "eventListeners",
  enabled: !0,
  phase: "write",
  fn: function() {
  },
  effect: lj,
  data: {}
};
var cj = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function hd(e) {
  return e.replace(/left|right|bottom|top/g, function(t) {
    return cj[t];
  });
}
var dj = {
  start: "end",
  end: "start"
};
function QE(e) {
  return e.replace(/start|end/g, function(t) {
    return dj[t];
  });
}
function py(e) {
  var t = hn(e), n = t.pageXOffset, r = t.pageYOffset;
  return {
    scrollLeft: n,
    scrollTop: r
  };
}
function my(e) {
  return Ms(Ai(e)).left + py(e).scrollLeft;
}
function fj(e, t) {
  var n = hn(e), r = Ai(e), i = n.visualViewport, s = r.clientWidth, l = r.clientHeight, u = 0, d = 0;
  if (i) {
    s = i.width, l = i.height;
    var h = AR();
    (h || !h && t === "fixed") && (u = i.offsetLeft, d = i.offsetTop);
  }
  return {
    width: s,
    height: l,
    x: u + my(e),
    y: d
  };
}
function hj(e) {
  var t, n = Ai(e), r = py(e), i = (t = e.ownerDocument) == null ? void 0 : t.body, s = oo(n.scrollWidth, n.clientWidth, i ? i.scrollWidth : 0, i ? i.clientWidth : 0), l = oo(n.scrollHeight, n.clientHeight, i ? i.scrollHeight : 0, i ? i.clientHeight : 0), u = -r.scrollLeft + my(e), d = -r.scrollTop;
  return Pr(i || n).direction === "rtl" && (u += oo(n.clientWidth, i ? i.clientWidth : 0) - s), {
    width: s,
    height: l,
    x: u,
    y: d
  };
}
function gy(e) {
  var t = Pr(e), n = t.overflow, r = t.overflowX, i = t.overflowY;
  return /auto|scroll|overlay|hidden/.test(n + i + r);
}
function TR(e) {
  return ["html", "body", "#document"].indexOf(hr(e)) >= 0 ? e.ownerDocument.body : Tn(e) && gy(e) ? e : TR(hf(e));
}
function kl(e, t) {
  var n;
  t === void 0 && (t = []);
  var r = TR(e), i = r === ((n = e.ownerDocument) == null ? void 0 : n.body), s = hn(r), l = i ? [s].concat(s.visualViewport || [], gy(r) ? r : []) : r, u = t.concat(l);
  return i ? u : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    u.concat(kl(hf(l)))
  );
}
function ag(e) {
  return Object.assign({}, e, {
    left: e.x,
    top: e.y,
    right: e.x + e.width,
    bottom: e.y + e.height
  });
}
function pj(e, t) {
  var n = Ms(e, !1, t === "fixed");
  return n.top = n.top + e.clientTop, n.left = n.left + e.clientLeft, n.bottom = n.top + e.clientHeight, n.right = n.left + e.clientWidth, n.width = e.clientWidth, n.height = e.clientHeight, n.x = n.left, n.y = n.top, n;
}
function JE(e, t, n) {
  return t === CR ? ag(fj(e, n)) : go(t) ? pj(t, n) : ag(hj(Ai(e)));
}
function mj(e) {
  var t = kl(hf(e)), n = ["absolute", "fixed"].indexOf(Pr(e).position) >= 0, r = n && Tn(e) ? du(e) : e;
  return go(r) ? t.filter(function(i) {
    return go(i) && xR(i, r) && hr(i) !== "body";
  }) : [];
}
function gj(e, t, n, r) {
  var i = t === "clippingParents" ? mj(e) : [].concat(t), s = [].concat(i, [n]), l = s[0], u = s.reduce(function(d, h) {
    var f = JE(e, h, r);
    return d.top = oo(f.top, d.top), d.right = $d(f.right, d.right), d.bottom = $d(f.bottom, d.bottom), d.left = oo(f.left, d.left), d;
  }, JE(e, l, r));
  return u.width = u.right - u.left, u.height = u.bottom - u.top, u.x = u.left, u.y = u.top, u;
}
function $R(e) {
  var t = e.reference, n = e.element, r = e.placement, i = r ? dr(r) : null, s = r ? Os(r) : null, l = t.x + t.width / 2 - n.width / 2, u = t.y + t.height / 2 - n.height / 2, d;
  switch (i) {
    case Jt:
      d = {
        x: l,
        y: t.y - n.height
      };
      break;
    case Vn:
      d = {
        x: l,
        y: t.y + t.height
      };
      break;
    case _n:
      d = {
        x: t.x + t.width,
        y: u
      };
      break;
    case en:
      d = {
        x: t.x - n.width,
        y: u
      };
      break;
    default:
      d = {
        x: t.x,
        y: t.y
      };
  }
  var h = i ? hy(i) : null;
  if (h != null) {
    var f = h === "y" ? "height" : "width";
    switch (s) {
      case Ls:
        d[h] = d[h] - (t[f] / 2 - n[f] / 2);
        break;
      case Nl:
        d[h] = d[h] + (t[f] / 2 - n[f] / 2);
        break;
    }
  }
  return d;
}
function Dl(e, t) {
  t === void 0 && (t = {});
  var n = t, r = n.placement, i = r === void 0 ? e.placement : r, s = n.strategy, l = s === void 0 ? e.strategy : s, u = n.boundary, d = u === void 0 ? OD : u, h = n.rootBoundary, f = h === void 0 ? CR : h, m = n.elementContext, g = m === void 0 ? pl : m, w = n.altBoundary, E = w === void 0 ? !1 : w, b = n.padding, A = b === void 0 ? 0 : b, x = kR(typeof A != "number" ? A : RR(A, cu)), R = g === pl ? BD : pl, _ = e.rects.popper, L = e.elements[E ? R : g], V = gj(go(L) ? L : L.contextElement || Ai(e.elements.popper), d, f, l), O = Ms(e.elements.reference), D = $R({
    reference: O,
    element: _,
    placement: i
  }), B = ag(Object.assign({}, _, D)), H = g === pl ? B : O, J = {
    top: V.top - H.top + x.top,
    bottom: H.bottom - V.bottom + x.bottom,
    left: V.left - H.left + x.left,
    right: H.right - V.right + x.right
  }, ce = e.modifiersData.offset;
  if (g === pl && ce) {
    var fe = ce[i];
    Object.keys(J).forEach(function(de) {
      var he = [_n, Vn].indexOf(de) >= 0 ? 1 : -1, le = [Jt, Vn].indexOf(de) >= 0 ? "y" : "x";
      J[de] += fe[le] * he;
    });
  }
  return J;
}
function vj(e, t) {
  t === void 0 && (t = {});
  var n = t, r = n.placement, i = n.boundary, s = n.rootBoundary, l = n.padding, u = n.flipVariations, d = n.allowedAutoPlacements, h = d === void 0 ? ER : d, f = Os(r), m = f ? u ? qE : qE.filter(function(E) {
    return Os(E) === f;
  }) : cu, g = m.filter(function(E) {
    return h.indexOf(E) >= 0;
  });
  g.length === 0 && (g = m);
  var w = g.reduce(function(E, b) {
    return E[b] = Dl(e, {
      placement: b,
      boundary: i,
      rootBoundary: s,
      padding: l
    })[dr(b)], E;
  }, {});
  return Object.keys(w).sort(function(E, b) {
    return w[E] - w[b];
  });
}
function yj(e) {
  if (dr(e) === cy)
    return [];
  var t = hd(e);
  return [QE(e), t, QE(t)];
}
function wj(e) {
  var t = e.state, n = e.options, r = e.name;
  if (!t.modifiersData[r]._skip) {
    for (var i = n.mainAxis, s = i === void 0 ? !0 : i, l = n.altAxis, u = l === void 0 ? !0 : l, d = n.fallbackPlacements, h = n.padding, f = n.boundary, m = n.rootBoundary, g = n.altBoundary, w = n.flipVariations, E = w === void 0 ? !0 : w, b = n.allowedAutoPlacements, A = t.options.placement, x = dr(A), R = x === A, _ = d || (R || !E ? [hd(A)] : yj(A)), L = [A].concat(_).reduce(function(G, ee) {
      return G.concat(dr(ee) === cy ? vj(t, {
        placement: ee,
        boundary: f,
        rootBoundary: m,
        padding: h,
        flipVariations: E,
        allowedAutoPlacements: b
      }) : ee);
    }, []), V = t.rects.reference, O = t.rects.popper, D = /* @__PURE__ */ new Map(), B = !0, H = L[0], J = 0; J < L.length; J++) {
      var ce = L[J], fe = dr(ce), de = Os(ce) === Ls, he = [Jt, Vn].indexOf(fe) >= 0, le = he ? "width" : "height", Y = Dl(t, {
        placement: ce,
        boundary: f,
        rootBoundary: m,
        altBoundary: g,
        padding: h
      }), te = he ? de ? _n : en : de ? Vn : Jt;
      V[le] > O[le] && (te = hd(te));
      var S = hd(te), T = [];
      if (s && T.push(Y[fe] <= 0), u && T.push(Y[te] <= 0, Y[S] <= 0), T.every(function(G) {
        return G;
      })) {
        H = ce, B = !1;
        break;
      }
      D.set(ce, T);
    }
    if (B)
      for (var P = E ? 3 : 1, $ = function(ee) {
        var Q = L.find(function(q) {
          var re = D.get(q);
          if (re)
            return re.slice(0, ee).every(function(ve) {
              return ve;
            });
        });
        if (Q)
          return H = Q, "break";
      }, M = P; M > 0; M--) {
        var W = $(M);
        if (W === "break") break;
      }
    t.placement !== H && (t.modifiersData[r]._skip = !0, t.placement = H, t.reset = !0);
  }
}
const bj = {
  name: "flip",
  enabled: !0,
  phase: "main",
  fn: wj,
  requiresIfExists: ["offset"],
  data: {
    _skip: !1
  }
};
function eA(e, t, n) {
  return n === void 0 && (n = {
    x: 0,
    y: 0
  }), {
    top: e.top - t.height - n.y,
    right: e.right - t.width + n.x,
    bottom: e.bottom - t.height + n.y,
    left: e.left - t.width - n.x
  };
}
function tA(e) {
  return [Jt, _n, Vn, en].some(function(t) {
    return e[t] >= 0;
  });
}
function Cj(e) {
  var t = e.state, n = e.name, r = t.rects.reference, i = t.rects.popper, s = t.modifiersData.preventOverflow, l = Dl(t, {
    elementContext: "reference"
  }), u = Dl(t, {
    altBoundary: !0
  }), d = eA(l, r), h = eA(u, i, s), f = tA(d), m = tA(h);
  t.modifiersData[n] = {
    referenceClippingOffsets: d,
    popperEscapeOffsets: h,
    isReferenceHidden: f,
    hasPopperEscaped: m
  }, t.attributes.popper = Object.assign({}, t.attributes.popper, {
    "data-popper-reference-hidden": f,
    "data-popper-escaped": m
  });
}
const Ej = {
  name: "hide",
  enabled: !0,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: Cj
};
function Aj(e, t, n) {
  var r = dr(e), i = [en, Jt].indexOf(r) >= 0 ? -1 : 1, s = typeof n == "function" ? n(Object.assign({}, t, {
    placement: e
  })) : n, l = s[0], u = s[1];
  return l = l || 0, u = (u || 0) * i, [en, _n].indexOf(r) >= 0 ? {
    x: u,
    y: l
  } : {
    x: l,
    y: u
  };
}
function xj(e) {
  var t = e.state, n = e.options, r = e.name, i = n.offset, s = i === void 0 ? [0, 0] : i, l = ER.reduce(function(f, m) {
    return f[m] = Aj(m, t.rects, s), f;
  }, {}), u = l[t.placement], d = u.x, h = u.y;
  t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += d, t.modifiersData.popperOffsets.y += h), t.modifiersData[r] = l;
}
const Sj = {
  name: "offset",
  enabled: !0,
  phase: "main",
  requires: ["popperOffsets"],
  fn: xj
};
function kj(e) {
  var t = e.state, n = e.name;
  t.modifiersData[n] = $R({
    reference: t.rects.reference,
    element: t.rects.popper,
    placement: t.placement
  });
}
const Rj = {
  name: "popperOffsets",
  enabled: !0,
  phase: "read",
  fn: kj,
  data: {}
};
function Tj(e) {
  return e === "x" ? "y" : "x";
}
function $j(e) {
  var t = e.state, n = e.options, r = e.name, i = n.mainAxis, s = i === void 0 ? !0 : i, l = n.altAxis, u = l === void 0 ? !1 : l, d = n.boundary, h = n.rootBoundary, f = n.altBoundary, m = n.padding, g = n.tether, w = g === void 0 ? !0 : g, E = n.tetherOffset, b = E === void 0 ? 0 : E, A = Dl(t, {
    boundary: d,
    rootBoundary: h,
    padding: m,
    altBoundary: f
  }), x = dr(t.placement), R = Os(t.placement), _ = !R, L = hy(x), V = Tj(L), O = t.modifiersData.popperOffsets, D = t.rects.reference, B = t.rects.popper, H = typeof b == "function" ? b(Object.assign({}, t.rects, {
    placement: t.placement
  })) : b, J = typeof H == "number" ? {
    mainAxis: H,
    altAxis: H
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, H), ce = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null, fe = {
    x: 0,
    y: 0
  };
  if (O) {
    if (s) {
      var de, he = L === "y" ? Jt : en, le = L === "y" ? Vn : _n, Y = L === "y" ? "height" : "width", te = O[L], S = te + A[he], T = te - A[le], P = w ? -B[Y] / 2 : 0, $ = R === Ls ? D[Y] : B[Y], M = R === Ls ? -B[Y] : -D[Y], W = t.elements.arrow, G = w && W ? fy(W) : {
        width: 0,
        height: 0
      }, ee = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : SR(), Q = ee[he], q = ee[le], re = Sl(0, D[Y], G[Y]), ve = _ ? D[Y] / 2 - P - re - Q - J.mainAxis : $ - re - Q - J.mainAxis, Ce = _ ? -D[Y] / 2 + P + re + q + J.mainAxis : M + re + q + J.mainAxis, Ie = t.elements.arrow && du(t.elements.arrow), ze = Ie ? L === "y" ? Ie.clientTop || 0 : Ie.clientLeft || 0 : 0, He = (de = ce == null ? void 0 : ce[L]) != null ? de : 0, pn = te + ve - He - ze, Zn = te + Ce - He, tn = Sl(w ? $d(S, pn) : S, te, w ? oo(T, Zn) : T);
      O[L] = tn, fe[L] = tn - te;
    }
    if (u) {
      var mn, Tt = L === "x" ? Jt : en, Ye = L === "x" ? Vn : _n, nn = O[V], In = V === "y" ? "height" : "width", ko = nn + A[Tt], Aa = nn - A[Ye], Ro = [Jt, en].indexOf(x) !== -1, xa = (mn = ce == null ? void 0 : ce[V]) != null ? mn : 0, Sa = Ro ? ko : nn - D[In] - B[In] - xa + J.altAxis, To = Ro ? nn + D[In] + B[In] - xa - J.altAxis : Aa, xi = w && Ro ? JD(Sa, nn, To) : Sl(w ? Sa : ko, nn, w ? To : Aa);
      O[V] = xi, fe[V] = xi - nn;
    }
    t.modifiersData[r] = fe;
  }
}
const Vj = {
  name: "preventOverflow",
  enabled: !0,
  phase: "main",
  fn: $j,
  requiresIfExists: ["offset"]
};
function _j(e) {
  return {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  };
}
function Ij(e) {
  return e === hn(e) || !Tn(e) ? py(e) : _j(e);
}
function Lj(e) {
  var t = e.getBoundingClientRect(), n = Ps(t.width) / e.offsetWidth || 1, r = Ps(t.height) / e.offsetHeight || 1;
  return n !== 1 || r !== 1;
}
function Pj(e, t, n) {
  n === void 0 && (n = !1);
  var r = Tn(t), i = Tn(t) && Lj(t), s = Ai(t), l = Ms(e, i, n), u = {
    scrollLeft: 0,
    scrollTop: 0
  }, d = {
    x: 0,
    y: 0
  };
  return (r || !r && !n) && ((hr(t) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
  gy(s)) && (u = Ij(t)), Tn(t) ? (d = Ms(t, !0), d.x += t.clientLeft, d.y += t.clientTop) : s && (d.x = my(s))), {
    x: l.left + u.scrollLeft - d.x,
    y: l.top + u.scrollTop - d.y,
    width: l.width,
    height: l.height
  };
}
function Mj(e) {
  var t = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), r = [];
  e.forEach(function(s) {
    t.set(s.name, s);
  });
  function i(s) {
    n.add(s.name);
    var l = [].concat(s.requires || [], s.requiresIfExists || []);
    l.forEach(function(u) {
      if (!n.has(u)) {
        var d = t.get(u);
        d && i(d);
      }
    }), r.push(s);
  }
  return e.forEach(function(s) {
    n.has(s.name) || i(s);
  }), r;
}
function Oj(e) {
  var t = Mj(e);
  return GD.reduce(function(n, r) {
    return n.concat(t.filter(function(i) {
      return i.phase === r;
    }));
  }, []);
}
function Bj(e) {
  var t;
  return function() {
    return t || (t = new Promise(function(n) {
      Promise.resolve().then(function() {
        t = void 0, n(e());
      });
    })), t;
  };
}
function Nj(e) {
  var t = e.reduce(function(n, r) {
    var i = n[r.name];
    return n[r.name] = i ? Object.assign({}, i, r, {
      options: Object.assign({}, i.options, r.options),
      data: Object.assign({}, i.data, r.data)
    }) : r, n;
  }, {});
  return Object.keys(t).map(function(n) {
    return t[n];
  });
}
var nA = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function rA() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return !t.some(function(r) {
    return !(r && typeof r.getBoundingClientRect == "function");
  });
}
function Dj(e) {
  e === void 0 && (e = {});
  var t = e, n = t.defaultModifiers, r = n === void 0 ? [] : n, i = t.defaultOptions, s = i === void 0 ? nA : i;
  return function(u, d, h) {
    h === void 0 && (h = s);
    var f = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, nA, s),
      modifiersData: {},
      elements: {
        reference: u,
        popper: d
      },
      attributes: {},
      styles: {}
    }, m = [], g = !1, w = {
      state: f,
      setOptions: function(x) {
        var R = typeof x == "function" ? x(f.options) : x;
        b(), f.options = Object.assign({}, s, f.options, R), f.scrollParents = {
          reference: go(u) ? kl(u) : u.contextElement ? kl(u.contextElement) : [],
          popper: kl(d)
        };
        var _ = Oj(Nj([].concat(r, f.options.modifiers)));
        return f.orderedModifiers = _.filter(function(L) {
          return L.enabled;
        }), E(), w.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function() {
        if (!g) {
          var x = f.elements, R = x.reference, _ = x.popper;
          if (rA(R, _)) {
            f.rects = {
              reference: Pj(R, du(_), f.options.strategy === "fixed"),
              popper: fy(_)
            }, f.reset = !1, f.placement = f.options.placement, f.orderedModifiers.forEach(function(J) {
              return f.modifiersData[J.name] = Object.assign({}, J.data);
            });
            for (var L = 0; L < f.orderedModifiers.length; L++) {
              if (f.reset === !0) {
                f.reset = !1, L = -1;
                continue;
              }
              var V = f.orderedModifiers[L], O = V.fn, D = V.options, B = D === void 0 ? {} : D, H = V.name;
              typeof O == "function" && (f = O({
                state: f,
                options: B,
                name: H,
                instance: w
              }) || f);
            }
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: Bj(function() {
        return new Promise(function(A) {
          w.forceUpdate(), A(f);
        });
      }),
      destroy: function() {
        b(), g = !0;
      }
    };
    if (!rA(u, d))
      return w;
    w.setOptions(h).then(function(A) {
      !g && h.onFirstUpdate && h.onFirstUpdate(A);
    });
    function E() {
      f.orderedModifiers.forEach(function(A) {
        var x = A.name, R = A.options, _ = R === void 0 ? {} : R, L = A.effect;
        if (typeof L == "function") {
          var V = L({
            state: f,
            name: x,
            instance: w,
            options: _
          }), O = function() {
          };
          m.push(V || O);
        }
      });
    }
    function b() {
      m.forEach(function(A) {
        return A();
      }), m = [];
    }
    return w;
  };
}
var jj = [uj, Rj, aj, XD, Sj, bj, Vj, rj, Ej], Fj = /* @__PURE__ */ Dj({
  defaultModifiers: jj
});
const Uj = ({
  item: e
}) => {
  const {
    colorMode: t,
    feedClient: n
  } = uu(), {
    t: r
  } = bR(), [i, s] = C.useState(!1), l = C.useRef(null), u = C.useRef(null), d = C.useCallback(
    (h) => {
      h.preventDefault(), h.stopPropagation(), n.markAsArchived(e);
    },
    // TODO: Check if we can remove this disable
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [e]
  );
  return C.useEffect(() => {
    if (l.current && u.current && i) {
      const h = Fj(l.current, u.current, {
        placement: "top-end",
        modifiers: [{
          name: "offset",
          options: {
            offset: [0, 8]
          }
        }]
      });
      return () => {
        h.destroy();
      };
    }
  }, [i]), /* @__PURE__ */ j.createElement("button", { ref: l, onClick: d, onMouseEnter: () => s(!0), onMouseLeave: () => s(!1), type: "button", "aria-label": r("archiveNotification"), className: `rnf-archive-notification-btn rnf-archive-notification-btn--${t}` }, /* @__PURE__ */ j.createElement(PD, { "aria-hidden": !0 }), i && /* @__PURE__ */ j.createElement("div", { ref: u, className: `rnf-tooltip rnf-tooltip--${t}` }, r("archiveNotification")));
}, Wj = ({
  name: e,
  src: t
}) => {
  function n(r) {
    const [i, s] = r.split(" ");
    return i && s ? `${i.charAt(0)}${s.charAt(0)}` : i ? i.charAt(0) : "";
  }
  return /* @__PURE__ */ j.createElement("div", { className: "rnf-avatar" }, t ? /* @__PURE__ */ j.createElement("img", { src: t, alt: e, className: "rnf-avatar__image" }) : /* @__PURE__ */ j.createElement("span", { className: "rnf-avatar__initials" }, n(e)));
};
function iA(e) {
  e && e !== "" && setTimeout(() => window.location.assign(e), 200);
}
j.forwardRef(({
  item: e,
  onItemClick: t,
  onButtonClick: n,
  avatar: r,
  children: i,
  archiveButton: s
}, l) => {
  var u;
  const {
    feedClient: d,
    colorMode: h
  } = uu(), {
    locale: f
  } = bR(), m = C.useMemo(() => e.blocks.reduce((R, _) => ({
    ...R,
    [_.name]: _
  }), {}), [e]), g = (u = m.action_url) == null ? void 0 : u.rendered, w = m.actions, E = j.useCallback(() => (d.markAsInteracted(e, {
    type: "cell_click",
    action: g
  }), t ? t(e) : iA(g)), [e, g, t, d]), b = j.useCallback((R, _) => (d.markAsInteracted(e, {
    type: "button_click",
    name: _.name,
    label: _.label,
    action: _.action
  }), n ? n(e, _) : iA(_.action)), [n, d, e]), A = j.useCallback((R) => {
    switch (R.key) {
      case "Enter": {
        R.stopPropagation(), E();
        break;
      }
    }
  }, [E]), x = e.actors[0];
  return (
    // eslint-disable-next-line jsx-a11y/no-static-element-interactions
    /* @__PURE__ */ j.createElement(
      "div",
      {
        ref: l,
        className: `rnf-notification-cell rnf-notification-cell--${h}`,
        onClick: E,
        onKeyDown: A,
        tabIndex: 0
      },
      /* @__PURE__ */ j.createElement("div", { className: "rnf-notification-cell__inner" }, !e.read_at && /* @__PURE__ */ j.createElement("div", { className: "rnf-notification-cell__unread-dot" }), UE(r, x && "name" in x && x.name && /* @__PURE__ */ j.createElement(Wj, { name: x.name, src: x.avatar })), /* @__PURE__ */ j.createElement("div", { className: "rnf-notification-cell__content-outer" }, m.body && /* @__PURE__ */ j.createElement("div", { className: "rnf-notification-cell__content", dangerouslySetInnerHTML: {
        __html: m.body.rendered
      } }), w && /* @__PURE__ */ j.createElement("div", { className: "rnf-notification-cell__button-group" }, /* @__PURE__ */ j.createElement(ID, null, w.buttons.map((R, _) => /* @__PURE__ */ j.createElement(_D, { variant: _ === 0 ? "primary" : "secondary", key: R.name, onClick: (L) => b(L, R) }, R.label)))), i && /* @__PURE__ */ j.createElement("div", { className: "rnf-notification-cell__child-content" }, i), /* @__PURE__ */ j.createElement("span", { className: "rnf-notification-cell__timestamp" }, gD(e.inserted_at, {
        locale: f
      }))), UE(s, /* @__PURE__ */ j.createElement(Uj, { item: e })))
    )
  );
});
fd.All, fd.Unread, fd.Read;
function zj(e, t) {
  switch (e) {
    case "all":
      return t.total_count;
    case "unread":
      return t.unread_count;
    case "unseen":
      return t.unseen_count;
  }
}
const Hj = ({
  badgeCountType: e = "unseen"
}) => {
  const {
    useFeedStore: t
  } = uu(), n = t((r) => zj(e, r.metadata));
  return n !== 0 ? /* @__PURE__ */ j.createElement("div", { className: "rnf-unseen-badge" }, /* @__PURE__ */ j.createElement("span", { className: "rnf-unseen-badge__count" }, mD(n))) : null;
};
j.forwardRef(({
  onClick: e,
  badgeCountType: t
}, n) => {
  const {
    colorMode: r
  } = uu();
  return /* @__PURE__ */ j.createElement("button", { className: `rnf-notification-icon-button rnf-notification-icon-button--${r}`, "aria-label": "Open notification feed", ref: n, onClick: e }, /* @__PURE__ */ j.createElement(LD, { "aria-hidden": !0 }), /* @__PURE__ */ j.createElement(Hj, { badgeCountType: t }));
});
function VR(e) {
  var t, n, r = "";
  if (typeof e == "string" || typeof e == "number") r += e;
  else if (typeof e == "object") if (Array.isArray(e)) {
    var i = e.length;
    for (t = 0; t < i; t++) e[t] && (n = VR(e[t])) && (r && (r += " "), r += n);
  } else for (n in e) e[n] && (r && (r += " "), r += n);
  return r;
}
function Se() {
  for (var e, t, n = 0, r = "", i = arguments.length; n < i; n++) (e = arguments[n]) && (t = VR(e)) && (r && (r += " "), r += t);
  return r;
}
const _R = (e) => {
  let t;
  try {
    t = new URL(e);
  } catch {
    return !1;
  }
  return t.protocol === "http:" || t.protocol === "https:";
}, vy = ({
  children: e,
  className: t,
  ...n
}) => /* @__PURE__ */ j.createElement("div", { className: Se("knock-guide-banner", t), ...n }, e);
vy.displayName = "BannerView.Root";
const yy = ({
  children: e,
  className: t,
  ...n
}) => /* @__PURE__ */ j.createElement("div", { className: Se("knock-guide-banner__message", t), ...n }, e);
yy.displayName = "BannerView.Content";
const wy = ({
  title: e,
  className: t,
  ...n
}) => /* @__PURE__ */ j.createElement("div", { className: Se("knock-guide-banner__title", t), ...n }, e);
wy.displayName = "BannerView.Title";
const by = ({
  body: e,
  className: t,
  ...n
}) => /* @__PURE__ */ j.createElement("div", { className: Se("knock-guide-banner__body", t), dangerouslySetInnerHTML: {
  __html: e
}, ...n });
by.displayName = "BannerView.Body";
const Cy = ({
  children: e,
  className: t,
  ...n
}) => /* @__PURE__ */ j.createElement("div", { className: Se("knock-guide-banner__actions", t), ...n }, e);
Cy.displayName = "BannerView.Actions";
const Ey = ({
  text: e,
  action: t,
  className: n,
  ...r
}) => /* @__PURE__ */ j.createElement("button", { className: Se("knock-guide-banner__action", n), ...r }, e);
Ey.displayName = "BannerView.PrimaryButton";
const Ay = ({
  text: e,
  action: t,
  className: n,
  ...r
}) => /* @__PURE__ */ j.createElement("button", { className: Se("knock-guide-banner__action knock-guide-banner__action--secondary", n), ...r }, e);
Ay.displayName = "BannerView.SecondaryButton";
const xy = ({
  className: e,
  ...t
}) => /* @__PURE__ */ j.createElement("button", { className: Se("knock-guide-banner__close", e), ...t }, /* @__PURE__ */ j.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "18", height: "18", fill: "none" }, /* @__PURE__ */ j.createElement("g", { fill: "#60646C", fillRule: "evenodd", clipRule: "evenodd" }, /* @__PURE__ */ j.createElement("path", { d: "M14.03 3.97a.75.75 0 0 1 0 1.06l-9 9a.75.75 0 0 1-1.06-1.06l9-9a.75.75 0 0 1 1.06 0Z" }), /* @__PURE__ */ j.createElement("path", { d: "M3.97 3.97a.75.75 0 0 1 1.06 0l9 9a.75.75 0 1 1-1.06 1.06l-9-9a.75.75 0 0 1 0-1.06Z" }))));
xy.displayName = "BannerView.DismissButton";
const IR = ({
  content: e,
  colorMode: t = "light",
  onDismiss: n,
  onButtonClick: r
}) => /* @__PURE__ */ j.createElement(vy, { "data-knock-color-mode": t }, /* @__PURE__ */ j.createElement(yy, null, /* @__PURE__ */ j.createElement(wy, { title: e.title }), /* @__PURE__ */ j.createElement(by, { body: e.body })), /* @__PURE__ */ j.createElement(Cy, null, e.secondary_button && /* @__PURE__ */ j.createElement(Ay, { text: e.secondary_button.text, action: e.secondary_button.action, onClick: (i) => {
  if (r) {
    const {
      text: s,
      action: l
    } = e.secondary_button;
    r(i, {
      name: "secondary_button",
      text: s,
      action: l
    });
  }
} }), e.primary_button && /* @__PURE__ */ j.createElement(Ey, { text: e.primary_button.text, action: e.primary_button.action, onClick: (i) => {
  if (r) {
    const {
      text: s,
      action: l
    } = e.primary_button;
    r(i, {
      name: "primary_button",
      text: s,
      action: l
    });
  }
} }), e.dismissible && /* @__PURE__ */ j.createElement(xy, { onClick: n })));
IR.displayName = "BannerView.Default";
const Kj = {};
Object.assign(Kj, {
  Default: IR,
  Root: vy,
  Content: yy,
  Title: wy,
  Body: by,
  Actions: Cy,
  PrimaryButton: Ey,
  SecondaryButton: Ay,
  DismissButton: xy
});
const Sy = ({
  children: e,
  className: t,
  ...n
}) => /* @__PURE__ */ j.createElement("div", { className: Se("knock-guide-card", t), ...n }, e);
Sy.displayName = "CardView.Root";
const ky = ({
  children: e,
  className: t,
  ...n
}) => /* @__PURE__ */ j.createElement("div", { className: Se("knock-guide-card__message", t), ...n }, e);
ky.displayName = "CardView.Content";
const LR = ({
  children: e,
  className: t,
  ...n
}) => /* @__PURE__ */ j.createElement("div", { className: Se("knock-guide-card__header", t), ...n }, e);
LR.displayName = "CardView.Header";
const PR = ({
  headline: e,
  className: t,
  ...n
}) => /* @__PURE__ */ j.createElement("div", { className: Se("knock-guide-card__headline", t), ...n }, e);
PR.displayName = "CardView.Headline";
const Ry = ({
  title: e,
  className: t,
  ...n
}) => /* @__PURE__ */ j.createElement("div", { className: Se("knock-guide-card__title", t), ...n }, e);
Ry.displayName = "CardView.Title";
const Ty = ({
  body: e,
  className: t,
  ...n
}) => /* @__PURE__ */ j.createElement("div", { className: Se("knock-guide-card__body", t), dangerouslySetInnerHTML: {
  __html: e
}, ...n });
Ty.displayName = "CardView.Body";
const $y = ({
  children: e,
  className: t,
  alt: n,
  ...r
}) => /* @__PURE__ */ j.createElement("img", { className: Se("knock-guide-card__img", t), alt: n || "", ...r }, e);
$y.displayName = "CardView.Img";
const Vy = ({
  children: e,
  className: t,
  ...n
}) => /* @__PURE__ */ j.createElement("div", { className: Se("knock-guide-card__actions", t), ...n }, e);
Vy.displayName = "CardView.Actions";
const _y = ({
  text: e,
  action: t,
  className: n,
  ...r
}) => /* @__PURE__ */ j.createElement("button", { className: Se("knock-guide-card__action", n), ...r }, e);
_y.displayName = "CardView.PrimaryButton";
const Iy = ({
  text: e,
  action: t,
  className: n,
  ...r
}) => /* @__PURE__ */ j.createElement("button", { className: Se("knock-guide-card__action knock-guide-card__action--secondary", n), ...r }, e);
Iy.displayName = "CardView.SecondaryButton";
const Ly = ({
  className: e,
  ...t
}) => /* @__PURE__ */ j.createElement("button", { className: Se("knock-guide-card__close", e), ...t }, /* @__PURE__ */ j.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "18", height: "18", fill: "none" }, /* @__PURE__ */ j.createElement("g", { fill: "#60646C", fillRule: "evenodd", clipRule: "evenodd" }, /* @__PURE__ */ j.createElement("path", { d: "M14.03 3.97a.75.75 0 0 1 0 1.06l-9 9a.75.75 0 0 1-1.06-1.06l9-9a.75.75 0 0 1 1.06 0Z" }), /* @__PURE__ */ j.createElement("path", { d: "M3.97 3.97a.75.75 0 0 1 1.06 0l9 9a.75.75 0 1 1-1.06 1.06l-9-9a.75.75 0 0 1 0-1.06Z" }))));
Ly.displayName = "CardView.DismissButton";
const MR = ({
  content: e,
  colorMode: t = "light",
  onDismiss: n,
  onButtonClick: r,
  onImageClick: i
}) => /* @__PURE__ */ j.createElement(Sy, { "data-knock-color-mode": t }, /* @__PURE__ */ j.createElement(ky, null, /* @__PURE__ */ j.createElement(LR, null, /* @__PURE__ */ j.createElement(PR, { headline: e.headline }), e.dismissible && /* @__PURE__ */ j.createElement(Ly, { onClick: n })), /* @__PURE__ */ j.createElement(Ry, { title: e.title }), /* @__PURE__ */ j.createElement(Ty, { body: e.body })), e.image && /* @__PURE__ */ j.createElement("a", { href: _R(e.image.action) ? e.image.action : void 0, target: "_blank" }, /* @__PURE__ */ j.createElement($y, { src: e.image.url, alt: e.image.alt, onClick: (s) => {
  i && i(s, e.image);
} })), (e.primary_button || e.secondary_button) && /* @__PURE__ */ j.createElement(Vy, null, e.primary_button && /* @__PURE__ */ j.createElement(_y, { text: e.primary_button.text, action: e.primary_button.action, onClick: (s) => {
  if (r) {
    const {
      text: l,
      action: u
    } = e.primary_button;
    r(s, {
      name: "primary_button",
      text: l,
      action: u
    });
  }
} }), e.secondary_button && /* @__PURE__ */ j.createElement(Iy, { text: e.secondary_button.text, action: e.secondary_button.action, onClick: (s) => {
  if (r) {
    const {
      text: l,
      action: u
    } = e.secondary_button;
    r(s, {
      name: "secondary_button",
      text: l,
      action: u
    });
  }
} })));
MR.displayName = "CardView.Default";
const Gj = {};
Object.assign(Gj, {
  Default: MR,
  Root: Sy,
  Content: ky,
  Title: Ry,
  Body: Ty,
  Img: $y,
  Actions: Vy,
  PrimaryButton: _y,
  SecondaryButton: Iy,
  DismissButton: Ly
});
const oA = Symbol.for("react.forward_ref"), sA = (e, t) => {
  const n = { ...t };
  for (const r in t) {
    const i = e[r], s = t[r];
    /^on[A-Z]/.test(r) ? i && s ? n[r] = (...l) => {
      s(...l), i(...l);
    } : i && (n[r] = i) : r === "style" ? n[r] = { ...i, ...s } : r === "className" && (n[r] = [i, s].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}, Yj = ({ children: e, ...t }, n) => e ? j.Children.toArray(e).map((r) => {
  if (j.isValidElement(r)) {
    const i = r, s = i.$$typeof, l = i.type.$$typeof, u = i.props, d = u.tgphRef;
    return s === oA || l === oA ? j.cloneElement(i, {
      ...sA(t, u),
      tgphRef: d || n,
      ref: d || n
    }) : j.cloneElement(i, {
      ...sA(t, u),
      tgphRef: d || n
    });
  }
  return r;
}) : null, Gs = j.forwardRef(
  ({ children: e, ...t }, n) => Yj({ children: e, ...t }, n)
), qj = ({
  value: e,
  determinateValue: t,
  minDurationMs: n = 1e3
}) => {
  const [r, i] = j.useState(e), s = j.useRef(null), l = j.useRef(null), u = () => {
    s.current && (clearTimeout(s.current), s.current = null);
  }, d = j.useCallback(() => {
    if (e === t)
      u(), i(t), l.current = Date.now();
    else if (l.current !== null) {
      const h = Date.now() - l.current, f = n - h;
      f > 0 ? (u(), s.current = setTimeout(() => {
        i(e), l.current = null;
      }, f)) : (i(e), l.current = null);
    } else
      i(e);
  }, [e, t, n]);
  return j.useEffect(() => (d(), u), [e, d]), r;
}, Xj = (e) => {
  const t = [];
  let n = "", r = 0;
  for (let i = 0; i < e.length; i++) {
    const s = e[i];
    s === "(" ? (r++, n += s) : s === ")" ? (r--, n += s) : s === " " && r === 0 ? n && (t.push(n), n = "") : n += s;
  }
  for (n && t.push(n); t.length < 4; )
    t.push("0");
  return [
    t[0] || "0",
    t[1] || "0",
    t[2] || "0",
    t[3] || "0"
  ];
}, Zj = ({
  currentValueOfCssVar: e = "0 0 0 0",
  value: t,
  direction: n
}) => {
  const [r, i, s, l] = Xj(e), u = {
    top: r,
    right: i,
    bottom: s,
    left: l
  };
  return n === "top" && (u.top = t), n === "right" && (u.right = t), n === "bottom" && (u.bottom = t), n === "left" && (u.left = t), n === "all" && (u.top = t, u.right = t, u.bottom = t, u.left = t), n === "x" && (u.left = t, u.right = t), n === "y" && (u.top = t, u.bottom = t), n === "side-top" && (u.top = t, u.right = t), n === "side-bottom" && (u.bottom = t, u.left = t), n === "side-left" && (u.top = t, u.left = t), n === "side-right" && (u.right = t, u.bottom = t), Object.values(u).join(" ");
}, Qj = (e) => {
  const { cssVars: t } = e;
  if (!(e != null && e.props) || Object.keys(e.props).length === 0)
    return { styleProp: {}, otherProps: {}, interactive: !1 };
  const { style: n = {}, ...r } = e.props;
  let i = n;
  const s = {};
  let l = !1;
  return Object.keys(r).forEach((u) => {
    const d = u, h = d, f = t == null ? void 0 : t[h];
    if (!f) {
      Object.assign(s, { [d]: r[d] });
      return;
    }
    const m = r == null ? void 0 : r[d];
    if (!m) {
      Object.assign(i, { [d]: r[d] });
      return;
    }
    let g;
    if (typeof m == "string" && m.startsWith("-")) {
      const E = m.slice(1);
      g = `calc(-1 * ${f.value.replace(
        "VARIABLE",
        E
      )})`;
    } else
      g = f.value.replace(
        "VARIABLE",
        m
      );
    const w = f.cssVar;
    if (f.interactive && (l = !0), f.direction) {
      const E = i == null ? void 0 : i[w], b = Zj({
        currentValueOfCssVar: E,
        value: g,
        direction: f.direction
      });
      i = {
        ...i,
        [w]: b
      };
      return;
    }
    i = {
      ...i,
      [w]: g
    };
  }), { styleProp: i, otherProps: s, interactive: l };
}, Wt = (e) => j.useMemo(() => Qj(e), [e]), Pe = {
  display: {
    cssVar: "--display",
    value: "VARIABLE"
  },
  backgroundColor: {
    cssVar: "--background-color",
    value: "var(--tgph-VARIABLE)"
  },
  hover_backgroundColor: {
    cssVar: "--hover_backgroundColor",
    value: "var(--tgph-VARIABLE)",
    interactive: !0
  },
  focus_backgroundColor: {
    cssVar: "--focus_backgroundColor",
    value: "var(--tgph-VARIABLE)",
    interactive: !0
  },
  active_backgroundColor: {
    cssVar: "--active_backgroundColor",
    interactive: !0,
    value: "var(--tgph-VARIABLE)"
  },
  focus_within_backgroundColor: {
    cssVar: "--focus_within_backgroundColor",
    interactive: !0,
    value: "var(--tgph-VARIABLE)"
  },
  borderStyle: {
    cssVar: "--border-style",
    value: "var(--tgph-border-style-VARIABLE)"
  },
  padding: {
    cssVar: "--padding",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "all"
  },
  paddingX: {
    cssVar: "--padding",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "x"
  },
  paddingY: {
    cssVar: "--padding",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "y"
  },
  paddingTop: {
    cssVar: "--padding",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "top"
  },
  paddingBottom: {
    cssVar: "--padding",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "bottom"
  },
  paddingLeft: {
    cssVar: "--padding",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "left"
  },
  paddingRight: {
    cssVar: "--padding",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "right"
  },
  margin: {
    cssVar: "--margin",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "all"
  },
  marginX: {
    cssVar: "--margin",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "x"
  },
  marginY: {
    cssVar: "--margin",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "y"
  },
  marginTop: {
    cssVar: "--margin",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "top"
  },
  marginBottom: {
    cssVar: "--margin",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "bottom"
  },
  marginLeft: {
    cssVar: "--margin",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "left"
  },
  marginRight: {
    cssVar: "--margin",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "right"
  },
  borderColor: {
    cssVar: "--border-color",
    value: "var(--tgph-VARIABLE)"
  },
  hover_borderColor: {
    cssVar: "--hover_borderColor",
    value: "var(--tgph-VARIABLE)",
    interactive: !0
  },
  focus_borderColor: {
    cssVar: "--focus_borderColor",
    value: "var(--tgph-VARIABLE)",
    interactive: !0
  },
  focus_within_borderColor: {
    cssVar: "--focus_within_borderColor",
    interactive: !0,
    value: "var(--tgph-VARIABLE)"
  },
  active_borderColor: {
    cssVar: "--active_borderColor",
    interactive: !0,
    value: "var(--tgph-VARIABLE)"
  },
  borderTopColor: {
    cssVar: "--border-color",
    value: "var(--tgph-VARIABLE)",
    direction: "top"
  },
  borderBottomColor: {
    cssVar: "--border-color",
    value: "var(--tgph-VARIABLE)",
    direction: "bottom"
  },
  borderLeftColor: {
    cssVar: "--border-color",
    value: "var(--tgph-VARIABLE)",
    direction: "left"
  },
  borderRightColor: {
    cssVar: "--border-color",
    value: "var(--tgph-VARIABLE)",
    direction: "right"
  },
  borderWidth: {
    cssVar: "--border-width",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  borderTopWidth: {
    cssVar: "--border-width",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "top"
  },
  borderBottomWidth: {
    cssVar: "--border-width",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "bottom"
  },
  borderLeftWidth: {
    cssVar: "--border-width",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "left"
  },
  borderRightWidth: {
    cssVar: "--border-width",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "right"
  },
  borderRadius: {
    cssVar: "--border-radius",
    value: "var(--tgph-rounded-VARIABLE)"
  },
  borderTopLeftRadius: {
    cssVar: "--border-radius",
    value: "var(--tgph-rounded-VARIABLE)",
    direction: "top"
  },
  borderTopRightRadius: {
    cssVar: "--border-radius",
    value: "var(--tgph-rounded-VARIABLE)",
    direction: "right"
  },
  borderBottomLeftRadius: {
    cssVar: "--border-radius",
    value: "var(--tgph-rounded-VARIABLE)",
    direction: "left"
  },
  borderBottomRightRadius: {
    cssVar: "--border-radius",
    value: "var(--tgph-rounded-VARIABLE)",
    direction: "bottom"
  },
  borderTopRadius: {
    cssVar: "--border-radius",
    value: "var(--tgph-rounded-VARIABLE)",
    direction: "side-top"
  },
  borderBottomRadius: {
    cssVar: "--border-radius",
    value: "var(--tgph-rounded-VARIABLE)",
    direction: "side-bottom"
  },
  borderLeftRadius: {
    cssVar: "--border-radius",
    value: "var(--tgph-rounded-VARIABLE)",
    direction: "side-left"
  },
  borderRightRadius: {
    cssVar: "--border-radius",
    value: "var(--tgph-rounded-VARIABLE)",
    direction: "side-right"
  },
  boxShadow: {
    cssVar: "--box-shadow",
    value: "var(--tgph-shadow-VARIABLE)"
  },
  width: {
    cssVar: "--width",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  height: {
    cssVar: "--height",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  minWidth: {
    cssVar: "--min-width",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  minHeight: {
    cssVar: "--min-height",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  maxWidth: {
    cssVar: "--max-width",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  maxHeight: {
    cssVar: "--max-height",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  zIndex: {
    cssVar: "--z-index",
    value: "var(--tgph-zIndex-VARIABLE)"
  },
  position: {
    cssVar: "--position",
    value: "VARIABLE"
  },
  top: {
    cssVar: "--top",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  left: {
    cssVar: "--left",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  right: {
    cssVar: "--right",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  bottom: {
    cssVar: "--bottom",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  overflow: {
    cssVar: "--overflow",
    value: "VARIABLE"
  },
  overflowX: {
    cssVar: "--overflow-x",
    value: "VARIABLE"
  },
  overflowY: {
    cssVar: "--overflow-y",
    value: "VARIABLE"
  },
  alignSelf: {
    cssVar: "--align-self",
    value: "VARIABLE"
  }
}, Jj = {
  border: Pe.borderWidth,
  borderX: Pe.borderLeftWidth,
  borderY: Pe.borderTopWidth,
  bg: Pe.backgroundColor,
  p: Pe.padding,
  m: Pe.margin,
  px: Pe.paddingX,
  py: Pe.paddingY,
  pt: Pe.paddingTop,
  pb: Pe.paddingBottom,
  pl: Pe.paddingLeft,
  pr: Pe.paddingRight,
  mx: Pe.marginX,
  my: Pe.marginY,
  mt: Pe.marginTop,
  mb: Pe.marginBottom,
  ml: Pe.marginLeft,
  mr: Pe.marginRight,
  shadow: Pe.boxShadow,
  w: Pe.width,
  h: Pe.height,
  minW: Pe.minWidth,
  minH: Pe.minHeight,
  maxW: Pe.maxWidth,
  maxH: Pe.maxHeight,
  rounded: Pe.borderRadius,
  roundedTopLeft: Pe.borderTopLeftRadius,
  roundedTopRight: Pe.borderTopRightRadius,
  roundedBottomLeft: Pe.borderBottomLeftRadius,
  roundedBottomRight: Pe.borderBottomRightRadius,
  roundedTop: Pe.borderTopRadius,
  roundedBottom: Pe.borderBottomRadius,
  roundedLeft: Pe.borderLeftRadius,
  roundedRight: Pe.borderRightRadius,
  borderTop: Pe.borderTopWidth,
  borderBottom: Pe.borderBottomWidth,
  borderLeft: Pe.borderLeftWidth,
  borderRight: Pe.borderRightWidth
}, eF = {
  ...Pe,
  ...Jj
}, tF = ({
  as: e,
  className: t,
  tgphRef: n,
  children: r,
  ...i
}) => {
  const s = e || "div", { styleProp: l, otherProps: u, interactive: d } = Wt({
    props: i,
    cssVars: eF
  });
  return /* @__PURE__ */ I.jsx(
    s,
    {
      className: Se(
        "tgph-box",
        d && "tgph-box--interactive",
        t
      ),
      style: l,
      ...u,
      ref: n,
      children: r
    }
  );
}, nF = {
  color: {
    cssVar: "--color",
    value: "var(--tgph-VARIABLE)"
  },
  fontSize: {
    cssVar: "--font-size",
    value: "var(--tgph-text-VARIABLE)"
  },
  weight: {
    cssVar: "--weight",
    value: "var(--tgph-weight-VARIABLE)"
  },
  leading: {
    cssVar: "--leading",
    value: "var(--tgph-leading-VARIABLE)"
  },
  tracking: {
    cssVar: "--tracking",
    value: "var(--tgph-tracking-VARIABLE)"
  },
  align: {
    cssVar: "--text-align",
    value: "VARIABLE"
  },
  family: {
    cssVar: "--font-family",
    value: "var(--tgph-family-VARIABLE)"
  },
  textOverflow: {
    cssVar: "--text-overflow",
    value: "VARIABLE"
  }
}, rF = nF, iF = {
  default: "gray-12",
  gray: "gray-11",
  red: "red-11",
  beige: "beige-11",
  blue: "blue-11",
  green: "green-11",
  yellow: "yellow-11",
  purple: "purple-11",
  accent: "accent-11",
  white: "white",
  black: "black",
  disabled: "gray-9"
}, qn = ({
  as: e,
  size: t = "2",
  weight: n = "regular",
  align: r = "left",
  color: i,
  className: s,
  // Remove this from props to avoid passing to DOM element
  internal_optionalAs: l,
  ...u
}) => {
  if (!e) throw new Error("as prop is required");
  const { styleProp: d, otherProps: h } = Wt({
    props: {
      color: iF[i],
      fontSize: t,
      tracking: t,
      leading: t,
      weight: n,
      align: r,
      ...u
    },
    cssVars: rF
  });
  return /* @__PURE__ */ I.jsx(
    tF,
    {
      as: e,
      className: Se("tgph-text", s),
      display: "inline",
      style: d,
      ...h
    }
  );
};
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const oF = (e) => e.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), sF = (e) => e.replace(
  /^([A-Z])|[\s-_]+(\w)/g,
  (t, n, r) => r ? r.toUpperCase() : n.toLowerCase()
), aA = (e) => {
  const t = sF(e);
  return t.charAt(0).toUpperCase() + t.slice(1);
}, OR = (...e) => e.filter((t, n, r) => !!t && t.trim() !== "" && r.indexOf(t) === n).join(" ").trim(), aF = (e) => {
  for (const t in e)
    if (t.startsWith("aria-") || t === "role" || t === "title")
      return !0;
};
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
var lF = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round"
};
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const uF = C.forwardRef(
  ({
    color: e = "currentColor",
    size: t = 24,
    strokeWidth: n = 2,
    absoluteStrokeWidth: r,
    className: i = "",
    children: s,
    iconNode: l,
    ...u
  }, d) => C.createElement(
    "svg",
    {
      ref: d,
      ...lF,
      width: t,
      height: t,
      stroke: e,
      strokeWidth: r ? Number(n) * 24 / Number(t) : n,
      className: OR("lucide", i),
      ...!s && !aF(u) && { "aria-hidden": "true" },
      ...u
    },
    [
      ...l.map(([h, f]) => C.createElement(h, f)),
      ...Array.isArray(s) ? s : [s]
    ]
  )
);
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const cF = (e, t) => {
  const n = C.forwardRef(
    ({ className: r, ...i }, s) => C.createElement(uF, {
      ref: s,
      iconNode: t,
      className: OR(
        `lucide-${oF(aA(e))}`,
        `lucide-${e}`,
        r
      ),
      ...i
    })
  );
  return n.displayName = aA(e), n;
};
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const dF = [["path", { d: "M21 12a9 9 0 1 1-6.219-8.56", key: "13zald" }]], fF = cF("loader-circle", dF), lA = {
  0: "var(--tgph-spacing-3)",
  1: "var(--tgph-spacing-3_5)",
  2: "var(--tgph-spacing-4)",
  3: "1.125rem",
  4: "var(--tgph-spacing-5)",
  5: "var(--tgph-spacing-6)",
  6: "var(--tgph-spacing-7)",
  7: "var(--tgph-spacing-8)",
  8: "var(--tgph-spacing-10)",
  9: "var(--tgph-spacing-12)"
}, hF = {
  primary: {
    default: "var(--tgph-gray-12)",
    gray: "var(--tgph-gray-11)",
    accent: "var(--tgph-accent-11)",
    beige: "var(--tgph-beige-11)",
    blue: "var(--tgph-blue-11)",
    green: "var(--tgph-green-11)",
    yellow: "var(--tgph-yellow-11)",
    purple: "var(--tgph-purple-11)",
    red: "var(--tgph-red-11)",
    white: "var(--tgph-white)",
    disabled: "var(--tgph-gray-9)",
    black: "var(--tgph-black)"
  },
  secondary: {
    default: "var(--tgph-gray-11)",
    gray: "var(--tgph-gray-10)",
    accent: "var(--tgph-accent-10)",
    beige: "var(--tgph-beige-10)",
    blue: "var(--tgph-blue-10)",
    green: "var(--tgph-green-10)",
    yellow: "var(--tgph-yellow-10)",
    purple: "var(--tgph-purple-10)",
    red: "var(--tgph-red-10)",
    white: "var(--tgph-white)",
    disabled: "var(--tgph-gray-8)",
    black: "var(--tgph-black)"
  }
}, BR = ({
  as: e,
  size: t = "2",
  color: n = "default",
  variant: r = "primary",
  animation: i = "none",
  icon: s,
  alt: l,
  className: u,
  style: d,
  ...h
}) => {
  const f = s;
  return f || console.error("@telegraph/icon: icon prop is required"), !l && !h["aria-hidden"] && console.error("@telegraph/icon: alt prop is required"), /* @__PURE__ */ I.jsx(
    qn,
    {
      as: e || "span",
      className: Se("tgph-icon", u),
      "data-button-icon": !0,
      "data-tgph-icon-animation": i,
      style: {
        // We choose to override these values vs passing them in as props because
        // the icon's sizes aren't all exact telegraph tokens and the colors
        // of the icon are different than the text color. Because of how the Text
        // component is setup this is a valid way to inject these values in for these
        // few cases.
        "--height": lA[t],
        "--width": lA[t],
        "--color": hF[r][n],
        ...d
      },
      ...h,
      children: f && /* @__PURE__ */ I.jsx(
        f,
        {
          role: "img",
          "aria-label": l,
          width: "100%",
          height: "100%",
          display: "block"
        }
      )
    }
  );
}, pF = ({
  color: e = "gray",
  icon: t = fF,
  animation: n = "spin",
  alt: r = "Loading...",
  ...i
}) => /* @__PURE__ */ I.jsx(
  BR,
  {
    color: e,
    icon: t,
    animation: n,
    alt: r,
    role: "status",
    "aria-live": "polite",
    ...i
  }
), Me = {
  display: {
    cssVar: "--display",
    value: "VARIABLE"
  },
  backgroundColor: {
    cssVar: "--background-color",
    value: "var(--tgph-VARIABLE)"
  },
  hover_backgroundColor: {
    cssVar: "--hover_backgroundColor",
    value: "var(--tgph-VARIABLE)",
    interactive: !0
  },
  focus_backgroundColor: {
    cssVar: "--focus_backgroundColor",
    value: "var(--tgph-VARIABLE)",
    interactive: !0
  },
  active_backgroundColor: {
    cssVar: "--active_backgroundColor",
    interactive: !0,
    value: "var(--tgph-VARIABLE)"
  },
  focus_within_backgroundColor: {
    cssVar: "--focus_within_backgroundColor",
    interactive: !0,
    value: "var(--tgph-VARIABLE)"
  },
  borderStyle: {
    cssVar: "--border-style",
    value: "var(--tgph-border-style-VARIABLE)"
  },
  padding: {
    cssVar: "--padding",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "all"
  },
  paddingX: {
    cssVar: "--padding",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "x"
  },
  paddingY: {
    cssVar: "--padding",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "y"
  },
  paddingTop: {
    cssVar: "--padding",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "top"
  },
  paddingBottom: {
    cssVar: "--padding",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "bottom"
  },
  paddingLeft: {
    cssVar: "--padding",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "left"
  },
  paddingRight: {
    cssVar: "--padding",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "right"
  },
  margin: {
    cssVar: "--margin",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "all"
  },
  marginX: {
    cssVar: "--margin",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "x"
  },
  marginY: {
    cssVar: "--margin",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "y"
  },
  marginTop: {
    cssVar: "--margin",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "top"
  },
  marginBottom: {
    cssVar: "--margin",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "bottom"
  },
  marginLeft: {
    cssVar: "--margin",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "left"
  },
  marginRight: {
    cssVar: "--margin",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "right"
  },
  borderColor: {
    cssVar: "--border-color",
    value: "var(--tgph-VARIABLE)"
  },
  hover_borderColor: {
    cssVar: "--hover_borderColor",
    value: "var(--tgph-VARIABLE)",
    interactive: !0
  },
  focus_borderColor: {
    cssVar: "--focus_borderColor",
    value: "var(--tgph-VARIABLE)",
    interactive: !0
  },
  focus_within_borderColor: {
    cssVar: "--focus_within_borderColor",
    interactive: !0,
    value: "var(--tgph-VARIABLE)"
  },
  active_borderColor: {
    cssVar: "--active_borderColor",
    interactive: !0,
    value: "var(--tgph-VARIABLE)"
  },
  borderTopColor: {
    cssVar: "--border-color",
    value: "var(--tgph-VARIABLE)",
    direction: "top"
  },
  borderBottomColor: {
    cssVar: "--border-color",
    value: "var(--tgph-VARIABLE)",
    direction: "bottom"
  },
  borderLeftColor: {
    cssVar: "--border-color",
    value: "var(--tgph-VARIABLE)",
    direction: "left"
  },
  borderRightColor: {
    cssVar: "--border-color",
    value: "var(--tgph-VARIABLE)",
    direction: "right"
  },
  borderWidth: {
    cssVar: "--border-width",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  borderTopWidth: {
    cssVar: "--border-width",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "top"
  },
  borderBottomWidth: {
    cssVar: "--border-width",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "bottom"
  },
  borderLeftWidth: {
    cssVar: "--border-width",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "left"
  },
  borderRightWidth: {
    cssVar: "--border-width",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "right"
  },
  borderRadius: {
    cssVar: "--border-radius",
    value: "var(--tgph-rounded-VARIABLE)"
  },
  borderTopLeftRadius: {
    cssVar: "--border-radius",
    value: "var(--tgph-rounded-VARIABLE)",
    direction: "top"
  },
  borderTopRightRadius: {
    cssVar: "--border-radius",
    value: "var(--tgph-rounded-VARIABLE)",
    direction: "right"
  },
  borderBottomLeftRadius: {
    cssVar: "--border-radius",
    value: "var(--tgph-rounded-VARIABLE)",
    direction: "left"
  },
  borderBottomRightRadius: {
    cssVar: "--border-radius",
    value: "var(--tgph-rounded-VARIABLE)",
    direction: "bottom"
  },
  borderTopRadius: {
    cssVar: "--border-radius",
    value: "var(--tgph-rounded-VARIABLE)",
    direction: "side-top"
  },
  borderBottomRadius: {
    cssVar: "--border-radius",
    value: "var(--tgph-rounded-VARIABLE)",
    direction: "side-bottom"
  },
  borderLeftRadius: {
    cssVar: "--border-radius",
    value: "var(--tgph-rounded-VARIABLE)",
    direction: "side-left"
  },
  borderRightRadius: {
    cssVar: "--border-radius",
    value: "var(--tgph-rounded-VARIABLE)",
    direction: "side-right"
  },
  boxShadow: {
    cssVar: "--box-shadow",
    value: "var(--tgph-shadow-VARIABLE)"
  },
  width: {
    cssVar: "--width",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  height: {
    cssVar: "--height",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  minWidth: {
    cssVar: "--min-width",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  minHeight: {
    cssVar: "--min-height",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  maxWidth: {
    cssVar: "--max-width",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  maxHeight: {
    cssVar: "--max-height",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  zIndex: {
    cssVar: "--z-index",
    value: "var(--tgph-zIndex-VARIABLE)"
  },
  position: {
    cssVar: "--position",
    value: "VARIABLE"
  },
  top: {
    cssVar: "--top",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  left: {
    cssVar: "--left",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  right: {
    cssVar: "--right",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  bottom: {
    cssVar: "--bottom",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  overflow: {
    cssVar: "--overflow",
    value: "VARIABLE"
  },
  overflowX: {
    cssVar: "--overflow-x",
    value: "VARIABLE"
  },
  overflowY: {
    cssVar: "--overflow-y",
    value: "VARIABLE"
  },
  alignSelf: {
    cssVar: "--align-self",
    value: "VARIABLE"
  }
}, mF = {
  border: Me.borderWidth,
  borderX: Me.borderLeftWidth,
  borderY: Me.borderTopWidth,
  bg: Me.backgroundColor,
  p: Me.padding,
  m: Me.margin,
  px: Me.paddingX,
  py: Me.paddingY,
  pt: Me.paddingTop,
  pb: Me.paddingBottom,
  pl: Me.paddingLeft,
  pr: Me.paddingRight,
  mx: Me.marginX,
  my: Me.marginY,
  mt: Me.marginTop,
  mb: Me.marginBottom,
  ml: Me.marginLeft,
  mr: Me.marginRight,
  shadow: Me.boxShadow,
  w: Me.width,
  h: Me.height,
  minW: Me.minWidth,
  minH: Me.minHeight,
  maxW: Me.maxWidth,
  maxH: Me.maxHeight,
  rounded: Me.borderRadius,
  roundedTopLeft: Me.borderTopLeftRadius,
  roundedTopRight: Me.borderTopRightRadius,
  roundedBottomLeft: Me.borderBottomLeftRadius,
  roundedBottomRight: Me.borderBottomRightRadius,
  roundedTop: Me.borderTopRadius,
  roundedBottom: Me.borderBottomRadius,
  roundedLeft: Me.borderLeftRadius,
  roundedRight: Me.borderRightRadius,
  borderTop: Me.borderTopWidth,
  borderBottom: Me.borderBottomWidth,
  borderLeft: Me.borderLeftWidth,
  borderRight: Me.borderRightWidth
}, gF = {
  ...Me,
  ...mF
}, vF = ({
  as: e,
  className: t,
  tgphRef: n,
  children: r,
  ...i
}) => {
  const s = e || "div", { styleProp: l, otherProps: u, interactive: d } = Wt({
    props: i,
    cssVars: gF
  });
  return /* @__PURE__ */ I.jsx(
    s,
    {
      className: Se(
        "tgph-box",
        d && "tgph-box--interactive",
        t
      ),
      style: l,
      ...u,
      ref: n,
      children: r
    }
  );
}, yF = {
  flexDirection: {
    cssVar: "--direction",
    value: "VARIABLE"
  },
  flexWrap: {
    cssVar: "--wrap",
    value: "VARIABLE"
  },
  justifyContent: {
    cssVar: "--justify",
    value: "VARIABLE"
  },
  alignItems: {
    cssVar: "--align",
    value: "VARIABLE"
  },
  gap: {
    cssVar: "--gap",
    value: "var(--tgph-spacing-VARIABLE)"
  }
}, wF = {
  direction: {
    cssVar: "--direction",
    value: "VARIABLE"
  },
  align: {
    cssVar: "--align",
    value: "VARIABLE"
  },
  justify: {
    cssVar: "--justify",
    value: "VARIABLE"
  },
  wrap: {
    cssVar: "--wrap",
    value: "VARIABLE"
  }
}, bF = {
  ...yF,
  ...wF
}, CF = ({
  className: e,
  ...t
}) => {
  const { styleProp: n, otherProps: r } = Wt({
    props: t,
    cssVars: bF
  });
  return /* @__PURE__ */ I.jsx(
    vF,
    {
      className: Se("tgph-stack", e),
      style: n,
      ...r
    }
  );
}, EF = {
  default_buttonShadowColor: {
    cssVar: "--box-shadow",
    value: "inset 0 0 0 1px var(--tgph-VARIABLE)"
  },
  hover_buttonShadowColor: {
    cssVar: "--tgph-button-hover-shadow",
    value: "inset 0 0 0 1px var(--tgph-VARIABLE)"
  },
  focus_buttonShadowColor: {
    cssVar: "--tgph-button-focus-shadow",
    value: "inset 0 0 0 1px var(--tgph-VARIABLE)"
  },
  active_buttonShadowColor: {
    cssVar: "--tgph-button-active-shadow",
    value: "inset 0 0 0 1px var(--tgph-VARIABLE)"
  },
  hover_textColor: {
    cssVar: "--tgph-button-hover-text-color",
    value: "var(--tgph-VARIABLE)"
  }
}, AF = {
  solid: {
    default: {
      backgroundColor: "gray-12",
      hover_backgroundColor: "gray-11",
      focus_backgroundColor: "gray-10",
      active_backgroundColor: "gray-10",
      hover_textColor: "white"
    },
    accent: {
      backgroundColor: "accent-9",
      hover_backgroundColor: "accent-10",
      focus_backgroundColor: "accent-11",
      active_backgroundColor: "accent-11",
      hover_textColor: "white"
    },
    red: {
      backgroundColor: "red-9",
      hover_backgroundColor: "red-10",
      focus_backgroundColor: "red-11",
      active_backgroundColor: "red-11",
      hover_textColor: "white"
    },
    gray: {
      backgroundColor: "gray-9",
      hover_backgroundColor: "gray-10",
      focus_backgroundColor: "gray-11",
      active_backgroundColor: "gray-11",
      hover_textColor: "white"
    },
    green: {
      backgroundColor: "green-9",
      hover_backgroundColor: "green-10",
      focus_backgroundColor: "green-11",
      active_backgroundColor: "green-11",
      hover_textColor: "white"
    },
    blue: {
      backgroundColor: "blue-9",
      hover_backgroundColor: "blue-10",
      focus_backgroundColor: "blue-11",
      active_backgroundColor: "blue-11",
      hover_textColor: "white"
    },
    yellow: {
      backgroundColor: "yellow-9",
      hover_backgroundColor: "yellow-10",
      focus_backgroundColor: "yellow-11",
      active_backgroundColor: "yellow-11",
      hover_textColor: "white"
    },
    purple: {
      backgroundColor: "purple-9",
      hover_backgroundColor: "purple-10",
      focus_backgroundColor: "purple-11",
      active_backgroundColor: "purple-11",
      hover_textColor: "white"
    }
  },
  soft: {
    default: {
      backgroundColor: "gray-3",
      hover_backgroundColor: "gray-4",
      focus_backgroundColor: "gray-5",
      active_backgroundColor: "gray-5",
      hover_textColor: "gray-12"
    },
    gray: {
      backgroundColor: "gray-3",
      hover_backgroundColor: "gray-4",
      focus_backgroundColor: "gray-5",
      active_backgroundColor: "gray-5",
      hover_textColor: "gray-12"
    },
    red: {
      backgroundColor: "red-3",
      hover_backgroundColor: "red-4",
      focus_backgroundColor: "red-5",
      active_backgroundColor: "red-5",
      hover_textColor: "red-11"
    },
    accent: {
      backgroundColor: "accent-3",
      hover_backgroundColor: "accent-4",
      focus_backgroundColor: "accent-5",
      active_backgroundColor: "accent-5",
      hover_textColor: "accent-11"
    },
    green: {
      backgroundColor: "green-3",
      hover_backgroundColor: "green-4",
      focus_backgroundColor: "green-5",
      active_backgroundColor: "green-5",
      hover_textColor: "green-11"
    },
    blue: {
      backgroundColor: "blue-3",
      hover_backgroundColor: "blue-4",
      focus_backgroundColor: "blue-5",
      active_backgroundColor: "blue-5",
      hover_textColor: "blue-11"
    },
    yellow: {
      backgroundColor: "yellow-3",
      hover_backgroundColor: "yellow-4",
      focus_backgroundColor: "yellow-5",
      active_backgroundColor: "yellow-5",
      hover_textColor: "yellow-11"
    },
    purple: {
      backgroundColor: "purple-3",
      hover_backgroundColor: "purple-4",
      focus_backgroundColor: "purple-5",
      active_backgroundColor: "purple-5",
      hover_textColor: "purple-11"
    }
  },
  outline: {
    default: {
      backgroundColor: "surface-1",
      hover_backgroundColor: "gray-2",
      default_buttonShadowColor: "gray-6",
      hover_buttonShadowColor: "gray-7",
      focus_buttonShadowColor: "gray-8",
      active_buttonShadowColor: "gray-8",
      hover_textColor: "gray-12"
    },
    gray: {
      backgroundColor: "surface-1",
      hover_backgroundColor: "gray-2",
      default_buttonShadowColor: "gray-6",
      hover_buttonShadowColor: "gray-7",
      focus_buttonShadowColor: "gray-8",
      active_buttonShadowColor: "gray-8",
      hover_textColor: "gray-12"
    },
    red: {
      backgroundColor: "surface-1",
      hover_backgroundColor: "red-2",
      default_buttonShadowColor: "red-6",
      hover_buttonShadowColor: "red-7",
      focus_buttonShadowColor: "red-8",
      active_buttonShadowColor: "red-8",
      hover_textColor: "red-11"
    },
    accent: {
      backgroundColor: "surface-1",
      hover_backgroundColor: "accent-2",
      default_buttonShadowColor: "accent-6",
      hover_buttonShadowColor: "accent-7",
      focus_buttonShadowColor: "accent-8",
      active_buttonShadowColor: "accent-8",
      hover_textColor: "accent-11"
    },
    green: {
      backgroundColor: "surface-1",
      hover_backgroundColor: "green-2",
      default_buttonShadowColor: "green-6",
      hover_buttonShadowColor: "green-7",
      focus_buttonShadowColor: "green-8",
      active_buttonShadowColor: "green-8",
      hover_textColor: "green-11"
    },
    blue: {
      backgroundColor: "surface-1",
      hover_backgroundColor: "blue-2",
      default_buttonShadowColor: "blue-6",
      hover_buttonShadowColor: "blue-7",
      focus_buttonShadowColor: "blue-8",
      active_buttonShadowColor: "blue-8",
      hover_textColor: "blue-11"
    },
    yellow: {
      backgroundColor: "surface-1",
      hover_backgroundColor: "yellow-2",
      default_buttonShadowColor: "yellow-6",
      hover_buttonShadowColor: "yellow-7",
      focus_buttonShadowColor: "yellow-8",
      active_buttonShadowColor: "yellow-8",
      hover_textColor: "yellow-11"
    },
    purple: {
      backgroundColor: "surface-1",
      hover_backgroundColor: "purple-2",
      default_buttonShadowColor: "purple-6",
      hover_buttonShadowColor: "purple-7",
      focus_buttonShadowColor: "purple-8",
      active_buttonShadowColor: "purple-8",
      hover_textColor: "purple-11"
    }
  },
  ghost: {
    default: {
      backgroundColor: "transparent",
      hover_backgroundColor: "gray-3",
      focus_backgroundColor: "gray-4",
      active_backgroundColor: "gray-4",
      hover_textColor: "gray-12"
    },
    gray: {
      backgroundColor: "transparent",
      hover_backgroundColor: "gray-3",
      focus_backgroundColor: "gray-4",
      active_backgroundColor: "gray-4",
      hover_textColor: "gray-12"
    },
    red: {
      backgroundColor: "transparent",
      hover_backgroundColor: "red-3",
      focus_backgroundColor: "red-4",
      active_backgroundColor: "red-4",
      hover_textColor: "red-11"
    },
    accent: {
      backgroundColor: "transparent",
      hover_backgroundColor: "accent-3",
      focus_backgroundColor: "accent-4",
      active_backgroundColor: "accent-4",
      hover_textColor: "accent-11"
    },
    green: {
      backgroundColor: "transparent",
      hover_backgroundColor: "green-3",
      focus_backgroundColor: "green-4",
      active_backgroundColor: "green-4",
      hover_textColor: "green-11"
    },
    blue: {
      backgroundColor: "transparent",
      hover_backgroundColor: "blue-3",
      focus_backgroundColor: "blue-4",
      active_backgroundColor: "blue-4",
      hover_textColor: "blue-11"
    },
    yellow: {
      backgroundColor: "transparent",
      hover_backgroundColor: "yellow-3",
      focus_backgroundColor: "yellow-4",
      active_backgroundColor: "yellow-4",
      hover_textColor: "yellow-11"
    },
    purple: {
      backgroundColor: "transparent",
      hover_backgroundColor: "purple-3",
      focus_backgroundColor: "purple-4",
      active_backgroundColor: "purple-4",
      hover_textColor: "purple-11"
    }
  }
}, xF = {
  default: {
    0: {
      w: "auto",
      h: "5",
      gap: "0_5",
      px: "1",
      rounded: "2"
    },
    1: {
      w: "auto",
      h: "6",
      gap: "1",
      px: "1_5",
      rounded: "2"
    },
    2: {
      w: "auto",
      h: "8",
      gap: "1_5",
      px: "2",
      rounded: "2"
    },
    3: {
      w: "auto",
      h: "10",
      gap: "2",
      px: "3",
      rounded: "3"
    }
  },
  "icon-only": {
    0: {
      w: "5",
      h: "5",
      gap: "0",
      px: "0",
      rounded: "2"
    },
    1: {
      w: "6",
      h: "6",
      gap: "0",
      px: "0",
      rounded: "2"
    },
    2: {
      w: "8",
      h: "8",
      gap: "0",
      px: "0",
      rounded: "2"
    },
    3: {
      w: "10",
      h: "10",
      gap: "0",
      px: "0",
      rounded: "3"
    }
  }
}, SF = {
  0: "0",
  1: "1",
  2: "2",
  3: "3"
}, kF = {
  solid: {
    default: "white",
    gray: "white",
    red: "white",
    accent: "white",
    green: "white",
    blue: "white",
    yellow: "white",
    purple: "white",
    disabled: "disabled"
  },
  soft: {
    default: "default",
    gray: "gray",
    red: "red",
    accent: "accent",
    green: "green",
    blue: "blue",
    yellow: "yellow",
    purple: "purple",
    disabled: "disabled"
  },
  outline: {
    default: "default",
    gray: "gray",
    red: "red",
    accent: "accent",
    green: "green",
    blue: "blue",
    yellow: "yellow",
    purple: "purple",
    disabled: "disabled"
  },
  ghost: {
    default: "default",
    gray: "gray",
    red: "red",
    accent: "accent",
    green: "green",
    blue: "blue",
    yellow: "yellow",
    purple: "purple",
    disabled: "disabled"
  }
}, NR = {
  0: "0",
  1: "1",
  2: "2",
  3: "3"
}, DR = {
  solid: {
    default: "white",
    gray: "white",
    red: "white",
    accent: "white",
    green: "white",
    blue: "white",
    yellow: "white",
    purple: "white",
    disabled: "disabled"
  },
  soft: {
    default: "default",
    accent: "accent",
    gray: "gray",
    red: "red",
    green: "green",
    blue: "blue",
    yellow: "yellow",
    purple: "purple",
    disabled: "disabled"
  },
  outline: {
    default: "default",
    accent: "accent",
    gray: "gray",
    red: "red",
    green: "green",
    blue: "blue",
    yellow: "yellow",
    purple: "purple",
    disabled: "disabled"
  },
  ghost: {
    default: "gray",
    accent: "accent",
    gray: "gray",
    red: "red",
    green: "green",
    blue: "blue",
    yellow: "yellow",
    purple: "purple",
    disabled: "disabled"
  }
}, jR = {
  default: "secondary",
  "icon-only": "primary"
}, Py = j.createContext({
  variant: "solid",
  size: "2",
  color: "default",
  state: "default",
  layout: "default",
  active: !1
}), RF = (e) => e.disabled ? "disabled" : e.state === "loading" ? "loading" : e.active ? "active" : e.state, FR = ({
  as: e,
  variant: t = "solid",
  size: n = "2",
  color: r = "default",
  state: i = "default",
  active: s = !1,
  type: l = "button",
  disabled: u,
  className: d,
  children: h,
  style: f,
  ...m
}) => {
  const g = RF({ state: i, disabled: u, active: s }), w = qj({
    value: g,
    determinateValue: "loading",
    minDurationMs: 1200
  }), { styleProp: E, otherProps: b } = Wt({
    props: {
      ...AF[t][r],
      style: f
    },
    cssVars: EF
  }), A = u || !e ? "button" : e, x = j.useMemo(() => {
    var R;
    const _ = j.Children.toArray(h);
    if ((_ == null ? void 0 : _.length) === 1 && j.isValidElement(_[0])) {
      const L = _[0];
      if ((R = L == null ? void 0 : L.props) != null && R.icon)
        return "icon-only";
    }
    return "default";
  }, [h]);
  return /* @__PURE__ */ I.jsx(
    Py.Provider,
    {
      value: { variant: t, size: n, color: r, state: w, layout: x, active: s },
      children: /* @__PURE__ */ I.jsxs(
        CF,
        {
          as: A,
          className: Se("tgph-button", d),
          display: "inline-flex",
          align: "center",
          justify: "center",
          ...xF[x][n],
          style: E,
          "data-tgph-button": !0,
          "data-tgph-button-layout": x,
          "data-tgph-button-state": w,
          "data-tgph-button-variant": t,
          "data-tgph-button-color": r,
          disabled: w === "disabled" || w === "loading",
          ...A === "button" && { type: l },
          ...b,
          ...m,
          children: [
            w === "loading" && /* @__PURE__ */ I.jsx(
              pF,
              {
                size: NR[n],
                color: DR[t][r],
                variant: jR[x],
                "data-tgph-button-loading-icon": !0
              }
            ),
            h
          ]
        }
      )
    }
  );
}, lg = ({
  size: e,
  color: t,
  variant: n,
  icon: r,
  alt: i,
  "aria-hidden": s,
  internal_iconType: l,
  ...u
}) => {
  const d = j.useContext(Py), h = {
    size: e ?? NR[d.size],
    color: t ?? DR[d.variant][d.state === "disabled" ? "disabled" : d.color],
    variant: n ?? jR[d.layout]
  }, f = i ? { alt: i } : { "aria-hidden": s };
  return d.state === "loading" && l === "leading" ? null : /* @__PURE__ */ I.jsx(
    BR,
    {
      icon: r,
      "data-button-icon": !0,
      "data-button-icon-color": h.color,
      ...f,
      ...h,
      ...u
    }
  );
}, UR = ({
  as: e,
  color: t,
  size: n,
  weight: r = "medium",
  style: i,
  ...s
}) => {
  const l = j.useContext(Py), u = t ?? kF[l.variant][l.state === "disabled" ? "disabled" : l.color];
  return /* @__PURE__ */ I.jsx(
    qn,
    {
      as: e || "span",
      color: u,
      size: n ?? SF[l.size],
      weight: r,
      internal_optionalAs: !0,
      "data-button-text": !0,
      "data-button-text-color": u,
      style: {
        textDecoration: "none",
        whiteSpace: "nowrap",
        ...i
      },
      ...s
    }
  );
}, WR = ({
  leadingIcon: e,
  trailingIcon: t,
  icon: n,
  children: r,
  ...i
}) => {
  const s = e || n;
  return /* @__PURE__ */ I.jsxs(FR, { ...i, children: [
    s && /* @__PURE__ */ I.jsx(lg, { ...s, internal_iconType: "leading" }),
    r && /* @__PURE__ */ I.jsx(UR, { children: r }),
    t && /* @__PURE__ */ I.jsx(lg, { ...t, internal_iconType: "trailing" })
  ] });
};
Object.assign(WR, {
  Root: FR,
  Icon: lg,
  Text: UR
});
const Ut = WR;
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const TF = (e) => e.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), $F = (e) => e.replace(
  /^([A-Z])|[\s-_]+(\w)/g,
  (t, n, r) => r ? r.toUpperCase() : n.toLowerCase()
), uA = (e) => {
  const t = $F(e);
  return t.charAt(0).toUpperCase() + t.slice(1);
}, zR = (...e) => e.filter((t, n, r) => !!t && t.trim() !== "" && r.indexOf(t) === n).join(" ").trim(), VF = (e) => {
  for (const t in e)
    if (t.startsWith("aria-") || t === "role" || t === "title")
      return !0;
};
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
var _F = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round"
};
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const IF = C.forwardRef(
  ({
    color: e = "currentColor",
    size: t = 24,
    strokeWidth: n = 2,
    absoluteStrokeWidth: r,
    className: i = "",
    children: s,
    iconNode: l,
    ...u
  }, d) => C.createElement(
    "svg",
    {
      ref: d,
      ..._F,
      width: t,
      height: t,
      stroke: e,
      strokeWidth: r ? Number(n) * 24 / Number(t) : n,
      className: zR("lucide", i),
      ...!s && !VF(u) && { "aria-hidden": "true" },
      ...u
    },
    [
      ...l.map(([h, f]) => C.createElement(h, f)),
      ...Array.isArray(s) ? s : [s]
    ]
  )
);
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const My = (e, t) => {
  const n = C.forwardRef(
    ({ className: r, ...i }, s) => C.createElement(IF, {
      ref: s,
      iconNode: t,
      className: zR(
        `lucide-${TF(uA(e))}`,
        `lucide-${e}`,
        r
      ),
      ...i
    })
  );
  return n.displayName = uA(e), n;
};
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const LF = [["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }]], PF = My("check", LF);
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const MF = [
  ["rect", { width: "14", height: "14", x: "8", y: "8", rx: "2", ry: "2", key: "17jyea" }],
  ["path", { d: "M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2", key: "zix9uf" }]
], OF = My("copy", MF);
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const BF = [
  ["path", { d: "M18 6 6 18", key: "1bl5f8" }],
  ["path", { d: "m6 6 12 12", key: "d8bk6v" }]
], HR = My("x", BF), cA = {
  0: "var(--tgph-spacing-3)",
  1: "var(--tgph-spacing-3_5)",
  2: "var(--tgph-spacing-4)",
  3: "1.125rem",
  4: "var(--tgph-spacing-5)",
  5: "var(--tgph-spacing-6)",
  6: "var(--tgph-spacing-7)",
  7: "var(--tgph-spacing-8)",
  8: "var(--tgph-spacing-10)",
  9: "var(--tgph-spacing-12)"
}, NF = {
  primary: {
    default: "var(--tgph-gray-12)",
    gray: "var(--tgph-gray-11)",
    accent: "var(--tgph-accent-11)",
    beige: "var(--tgph-beige-11)",
    blue: "var(--tgph-blue-11)",
    green: "var(--tgph-green-11)",
    yellow: "var(--tgph-yellow-11)",
    purple: "var(--tgph-purple-11)",
    red: "var(--tgph-red-11)",
    white: "var(--tgph-white)",
    disabled: "var(--tgph-gray-9)",
    black: "var(--tgph-black)"
  },
  secondary: {
    default: "var(--tgph-gray-11)",
    gray: "var(--tgph-gray-10)",
    accent: "var(--tgph-accent-10)",
    beige: "var(--tgph-beige-10)",
    blue: "var(--tgph-blue-10)",
    green: "var(--tgph-green-10)",
    yellow: "var(--tgph-yellow-10)",
    purple: "var(--tgph-purple-10)",
    red: "var(--tgph-red-10)",
    white: "var(--tgph-white)",
    disabled: "var(--tgph-gray-8)",
    black: "var(--tgph-black)"
  }
}, DF = ({
  as: e,
  size: t = "2",
  color: n = "default",
  variant: r = "primary",
  animation: i = "none",
  icon: s,
  alt: l,
  className: u,
  style: d,
  ...h
}) => {
  const f = s;
  return f || console.error("@telegraph/icon: icon prop is required"), !l && !h["aria-hidden"] && console.error("@telegraph/icon: alt prop is required"), /* @__PURE__ */ I.jsx(
    qn,
    {
      as: e || "span",
      className: Se("tgph-icon", u),
      "data-button-icon": !0,
      "data-tgph-icon-animation": i,
      style: {
        // We choose to override these values vs passing them in as props because
        // the icon's sizes aren't all exact telegraph tokens and the colors
        // of the icon are different than the text color. Because of how the Text
        // component is setup this is a valid way to inject these values in for these
        // few cases.
        "--height": cA[t],
        "--width": cA[t],
        "--color": NF[r][n],
        ...d
      },
      ...h,
      children: f && /* @__PURE__ */ I.jsx(
        f,
        {
          role: "img",
          "aria-label": l,
          width: "100%",
          height: "100%",
          display: "block"
        }
      )
    }
  );
}, Oe = {
  display: {
    cssVar: "--display",
    value: "VARIABLE"
  },
  backgroundColor: {
    cssVar: "--background-color",
    value: "var(--tgph-VARIABLE)"
  },
  hover_backgroundColor: {
    cssVar: "--hover_backgroundColor",
    value: "var(--tgph-VARIABLE)",
    interactive: !0
  },
  focus_backgroundColor: {
    cssVar: "--focus_backgroundColor",
    value: "var(--tgph-VARIABLE)",
    interactive: !0
  },
  active_backgroundColor: {
    cssVar: "--active_backgroundColor",
    interactive: !0,
    value: "var(--tgph-VARIABLE)"
  },
  focus_within_backgroundColor: {
    cssVar: "--focus_within_backgroundColor",
    interactive: !0,
    value: "var(--tgph-VARIABLE)"
  },
  borderStyle: {
    cssVar: "--border-style",
    value: "var(--tgph-border-style-VARIABLE)"
  },
  padding: {
    cssVar: "--padding",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "all"
  },
  paddingX: {
    cssVar: "--padding",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "x"
  },
  paddingY: {
    cssVar: "--padding",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "y"
  },
  paddingTop: {
    cssVar: "--padding",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "top"
  },
  paddingBottom: {
    cssVar: "--padding",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "bottom"
  },
  paddingLeft: {
    cssVar: "--padding",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "left"
  },
  paddingRight: {
    cssVar: "--padding",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "right"
  },
  margin: {
    cssVar: "--margin",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "all"
  },
  marginX: {
    cssVar: "--margin",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "x"
  },
  marginY: {
    cssVar: "--margin",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "y"
  },
  marginTop: {
    cssVar: "--margin",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "top"
  },
  marginBottom: {
    cssVar: "--margin",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "bottom"
  },
  marginLeft: {
    cssVar: "--margin",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "left"
  },
  marginRight: {
    cssVar: "--margin",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "right"
  },
  borderColor: {
    cssVar: "--border-color",
    value: "var(--tgph-VARIABLE)"
  },
  hover_borderColor: {
    cssVar: "--hover_borderColor",
    value: "var(--tgph-VARIABLE)",
    interactive: !0
  },
  focus_borderColor: {
    cssVar: "--focus_borderColor",
    value: "var(--tgph-VARIABLE)",
    interactive: !0
  },
  focus_within_borderColor: {
    cssVar: "--focus_within_borderColor",
    interactive: !0,
    value: "var(--tgph-VARIABLE)"
  },
  active_borderColor: {
    cssVar: "--active_borderColor",
    interactive: !0,
    value: "var(--tgph-VARIABLE)"
  },
  borderTopColor: {
    cssVar: "--border-color",
    value: "var(--tgph-VARIABLE)",
    direction: "top"
  },
  borderBottomColor: {
    cssVar: "--border-color",
    value: "var(--tgph-VARIABLE)",
    direction: "bottom"
  },
  borderLeftColor: {
    cssVar: "--border-color",
    value: "var(--tgph-VARIABLE)",
    direction: "left"
  },
  borderRightColor: {
    cssVar: "--border-color",
    value: "var(--tgph-VARIABLE)",
    direction: "right"
  },
  borderWidth: {
    cssVar: "--border-width",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  borderTopWidth: {
    cssVar: "--border-width",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "top"
  },
  borderBottomWidth: {
    cssVar: "--border-width",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "bottom"
  },
  borderLeftWidth: {
    cssVar: "--border-width",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "left"
  },
  borderRightWidth: {
    cssVar: "--border-width",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "right"
  },
  borderRadius: {
    cssVar: "--border-radius",
    value: "var(--tgph-rounded-VARIABLE)"
  },
  borderTopLeftRadius: {
    cssVar: "--border-radius",
    value: "var(--tgph-rounded-VARIABLE)",
    direction: "top"
  },
  borderTopRightRadius: {
    cssVar: "--border-radius",
    value: "var(--tgph-rounded-VARIABLE)",
    direction: "right"
  },
  borderBottomLeftRadius: {
    cssVar: "--border-radius",
    value: "var(--tgph-rounded-VARIABLE)",
    direction: "left"
  },
  borderBottomRightRadius: {
    cssVar: "--border-radius",
    value: "var(--tgph-rounded-VARIABLE)",
    direction: "bottom"
  },
  borderTopRadius: {
    cssVar: "--border-radius",
    value: "var(--tgph-rounded-VARIABLE)",
    direction: "side-top"
  },
  borderBottomRadius: {
    cssVar: "--border-radius",
    value: "var(--tgph-rounded-VARIABLE)",
    direction: "side-bottom"
  },
  borderLeftRadius: {
    cssVar: "--border-radius",
    value: "var(--tgph-rounded-VARIABLE)",
    direction: "side-left"
  },
  borderRightRadius: {
    cssVar: "--border-radius",
    value: "var(--tgph-rounded-VARIABLE)",
    direction: "side-right"
  },
  boxShadow: {
    cssVar: "--box-shadow",
    value: "var(--tgph-shadow-VARIABLE)"
  },
  width: {
    cssVar: "--width",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  height: {
    cssVar: "--height",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  minWidth: {
    cssVar: "--min-width",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  minHeight: {
    cssVar: "--min-height",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  maxWidth: {
    cssVar: "--max-width",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  maxHeight: {
    cssVar: "--max-height",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  zIndex: {
    cssVar: "--z-index",
    value: "var(--tgph-zIndex-VARIABLE)"
  },
  position: {
    cssVar: "--position",
    value: "VARIABLE"
  },
  top: {
    cssVar: "--top",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  left: {
    cssVar: "--left",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  right: {
    cssVar: "--right",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  bottom: {
    cssVar: "--bottom",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  overflow: {
    cssVar: "--overflow",
    value: "VARIABLE"
  },
  overflowX: {
    cssVar: "--overflow-x",
    value: "VARIABLE"
  },
  overflowY: {
    cssVar: "--overflow-y",
    value: "VARIABLE"
  },
  alignSelf: {
    cssVar: "--align-self",
    value: "VARIABLE"
  }
}, jF = {
  border: Oe.borderWidth,
  borderX: Oe.borderLeftWidth,
  borderY: Oe.borderTopWidth,
  bg: Oe.backgroundColor,
  p: Oe.padding,
  m: Oe.margin,
  px: Oe.paddingX,
  py: Oe.paddingY,
  pt: Oe.paddingTop,
  pb: Oe.paddingBottom,
  pl: Oe.paddingLeft,
  pr: Oe.paddingRight,
  mx: Oe.marginX,
  my: Oe.marginY,
  mt: Oe.marginTop,
  mb: Oe.marginBottom,
  ml: Oe.marginLeft,
  mr: Oe.marginRight,
  shadow: Oe.boxShadow,
  w: Oe.width,
  h: Oe.height,
  minW: Oe.minWidth,
  minH: Oe.minHeight,
  maxW: Oe.maxWidth,
  maxH: Oe.maxHeight,
  rounded: Oe.borderRadius,
  roundedTopLeft: Oe.borderTopLeftRadius,
  roundedTopRight: Oe.borderTopRightRadius,
  roundedBottomLeft: Oe.borderBottomLeftRadius,
  roundedBottomRight: Oe.borderBottomRightRadius,
  roundedTop: Oe.borderTopRadius,
  roundedBottom: Oe.borderBottomRadius,
  roundedLeft: Oe.borderLeftRadius,
  roundedRight: Oe.borderRightRadius,
  borderTop: Oe.borderTopWidth,
  borderBottom: Oe.borderBottomWidth,
  borderLeft: Oe.borderLeftWidth,
  borderRight: Oe.borderRightWidth
}, FF = {
  ...Oe,
  ...jF
}, UF = ({
  as: e,
  className: t,
  tgphRef: n,
  children: r,
  ...i
}) => {
  const s = e || "div", { styleProp: l, otherProps: u, interactive: d } = Wt({
    props: i,
    cssVars: FF
  });
  return /* @__PURE__ */ I.jsx(
    s,
    {
      className: Se(
        "tgph-box",
        d && "tgph-box--interactive",
        t
      ),
      style: l,
      ...u,
      ref: n,
      children: r
    }
  );
}, WF = {
  flexDirection: {
    cssVar: "--direction",
    value: "VARIABLE"
  },
  flexWrap: {
    cssVar: "--wrap",
    value: "VARIABLE"
  },
  justifyContent: {
    cssVar: "--justify",
    value: "VARIABLE"
  },
  alignItems: {
    cssVar: "--align",
    value: "VARIABLE"
  },
  gap: {
    cssVar: "--gap",
    value: "var(--tgph-spacing-VARIABLE)"
  }
}, zF = {
  direction: {
    cssVar: "--direction",
    value: "VARIABLE"
  },
  align: {
    cssVar: "--align",
    value: "VARIABLE"
  },
  justify: {
    cssVar: "--justify",
    value: "VARIABLE"
  },
  wrap: {
    cssVar: "--wrap",
    value: "VARIABLE"
  }
}, HF = {
  ...WF,
  ...zF
}, KF = ({
  className: e,
  ...t
}) => {
  const { styleProp: n, otherProps: r } = Wt({
    props: t,
    cssVars: HF
  });
  return /* @__PURE__ */ I.jsx(
    UF,
    {
      className: Se("tgph-stack", e),
      style: n,
      ...r
    }
  );
};
function Le(e, t, { checkForDefaultPrevented: n = !0 } = {}) {
  return function(i) {
    if (e == null || e(i), n === !1 || !i.defaultPrevented)
      return t == null ? void 0 : t(i);
  };
}
function dA(e, t) {
  if (typeof e == "function")
    return e(t);
  e != null && (e.current = t);
}
function pf(...e) {
  return (t) => {
    let n = !1;
    const r = e.map((i) => {
      const s = dA(i, t);
      return !n && typeof s == "function" && (n = !0), s;
    });
    if (n)
      return () => {
        for (let i = 0; i < r.length; i++) {
          const s = r[i];
          typeof s == "function" ? s() : dA(e[i], null);
        }
      };
  };
}
function wt(...e) {
  return C.useCallback(pf(...e), e);
}
function GF(e, t) {
  const n = C.createContext(t), r = (s) => {
    const { children: l, ...u } = s, d = C.useMemo(() => u, Object.values(u));
    return /* @__PURE__ */ I.jsx(n.Provider, { value: d, children: l });
  };
  r.displayName = e + "Provider";
  function i(s) {
    const l = C.useContext(n);
    if (l) return l;
    if (t !== void 0) return t;
    throw new Error(`\`${s}\` must be used within \`${e}\``);
  }
  return [r, i];
}
function Ys(e, t = []) {
  let n = [];
  function r(s, l) {
    const u = C.createContext(l), d = n.length;
    n = [...n, l];
    const h = (m) => {
      var x;
      const { scope: g, children: w, ...E } = m, b = ((x = g == null ? void 0 : g[e]) == null ? void 0 : x[d]) || u, A = C.useMemo(() => E, Object.values(E));
      return /* @__PURE__ */ I.jsx(b.Provider, { value: A, children: w });
    };
    h.displayName = s + "Provider";
    function f(m, g) {
      var b;
      const w = ((b = g == null ? void 0 : g[e]) == null ? void 0 : b[d]) || u, E = C.useContext(w);
      if (E) return E;
      if (l !== void 0) return l;
      throw new Error(`\`${m}\` must be used within \`${s}\``);
    }
    return [h, f];
  }
  const i = () => {
    const s = n.map((l) => C.createContext(l));
    return function(u) {
      const d = (u == null ? void 0 : u[e]) || s;
      return C.useMemo(
        () => ({ [`__scope${e}`]: { ...u, [e]: d } }),
        [u, d]
      );
    };
  };
  return i.scopeName = e, [r, YF(i, ...t)];
}
function YF(...e) {
  const t = e[0];
  if (e.length === 1) return t;
  const n = () => {
    const r = e.map((i) => ({
      useScope: i(),
      scopeName: i.scopeName
    }));
    return function(s) {
      const l = r.reduce((u, { useScope: d, scopeName: h }) => {
        const m = d(s)[`__scope${h}`];
        return { ...u, ...m };
      }, {});
      return C.useMemo(() => ({ [`__scope${t.scopeName}`]: l }), [l]);
    };
  };
  return n.scopeName = t.scopeName, n;
}
var om = { exports: {} }, Xt = {}, sm = { exports: {} }, am = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var fA;
function qF() {
  return fA || (fA = 1, (function(e) {
    function t(S, T) {
      var P = S.length;
      S.push(T);
      e: for (; 0 < P; ) {
        var $ = P - 1 >>> 1, M = S[$];
        if (0 < i(M, T)) S[$] = T, S[P] = M, P = $;
        else break e;
      }
    }
    function n(S) {
      return S.length === 0 ? null : S[0];
    }
    function r(S) {
      if (S.length === 0) return null;
      var T = S[0], P = S.pop();
      if (P !== T) {
        S[0] = P;
        e: for (var $ = 0, M = S.length, W = M >>> 1; $ < W; ) {
          var G = 2 * ($ + 1) - 1, ee = S[G], Q = G + 1, q = S[Q];
          if (0 > i(ee, P)) Q < M && 0 > i(q, ee) ? (S[$] = q, S[Q] = P, $ = Q) : (S[$] = ee, S[G] = P, $ = G);
          else if (Q < M && 0 > i(q, P)) S[$] = q, S[Q] = P, $ = Q;
          else break e;
        }
      }
      return T;
    }
    function i(S, T) {
      var P = S.sortIndex - T.sortIndex;
      return P !== 0 ? P : S.id - T.id;
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
      var s = performance;
      e.unstable_now = function() {
        return s.now();
      };
    } else {
      var l = Date, u = l.now();
      e.unstable_now = function() {
        return l.now() - u;
      };
    }
    var d = [], h = [], f = 1, m = null, g = 3, w = !1, E = !1, b = !1, A = typeof setTimeout == "function" ? setTimeout : null, x = typeof clearTimeout == "function" ? clearTimeout : null, R = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function _(S) {
      for (var T = n(h); T !== null; ) {
        if (T.callback === null) r(h);
        else if (T.startTime <= S) r(h), T.sortIndex = T.expirationTime, t(d, T);
        else break;
        T = n(h);
      }
    }
    function L(S) {
      if (b = !1, _(S), !E) if (n(d) !== null) E = !0, Y(V);
      else {
        var T = n(h);
        T !== null && te(L, T.startTime - S);
      }
    }
    function V(S, T) {
      E = !1, b && (b = !1, x(B), B = -1), w = !0;
      var P = g;
      try {
        for (_(T), m = n(d); m !== null && (!(m.expirationTime > T) || S && !ce()); ) {
          var $ = m.callback;
          if (typeof $ == "function") {
            m.callback = null, g = m.priorityLevel;
            var M = $(m.expirationTime <= T);
            T = e.unstable_now(), typeof M == "function" ? m.callback = M : m === n(d) && r(d), _(T);
          } else r(d);
          m = n(d);
        }
        if (m !== null) var W = !0;
        else {
          var G = n(h);
          G !== null && te(L, G.startTime - T), W = !1;
        }
        return W;
      } finally {
        m = null, g = P, w = !1;
      }
    }
    var O = !1, D = null, B = -1, H = 5, J = -1;
    function ce() {
      return !(e.unstable_now() - J < H);
    }
    function fe() {
      if (D !== null) {
        var S = e.unstable_now();
        J = S;
        var T = !0;
        try {
          T = D(!0, S);
        } finally {
          T ? de() : (O = !1, D = null);
        }
      } else O = !1;
    }
    var de;
    if (typeof R == "function") de = function() {
      R(fe);
    };
    else if (typeof MessageChannel < "u") {
      var he = new MessageChannel(), le = he.port2;
      he.port1.onmessage = fe, de = function() {
        le.postMessage(null);
      };
    } else de = function() {
      A(fe, 0);
    };
    function Y(S) {
      D = S, O || (O = !0, de());
    }
    function te(S, T) {
      B = A(function() {
        S(e.unstable_now());
      }, T);
    }
    e.unstable_IdlePriority = 5, e.unstable_ImmediatePriority = 1, e.unstable_LowPriority = 4, e.unstable_NormalPriority = 3, e.unstable_Profiling = null, e.unstable_UserBlockingPriority = 2, e.unstable_cancelCallback = function(S) {
      S.callback = null;
    }, e.unstable_continueExecution = function() {
      E || w || (E = !0, Y(V));
    }, e.unstable_forceFrameRate = function(S) {
      0 > S || 125 < S ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : H = 0 < S ? Math.floor(1e3 / S) : 5;
    }, e.unstable_getCurrentPriorityLevel = function() {
      return g;
    }, e.unstable_getFirstCallbackNode = function() {
      return n(d);
    }, e.unstable_next = function(S) {
      switch (g) {
        case 1:
        case 2:
        case 3:
          var T = 3;
          break;
        default:
          T = g;
      }
      var P = g;
      g = T;
      try {
        return S();
      } finally {
        g = P;
      }
    }, e.unstable_pauseExecution = function() {
    }, e.unstable_requestPaint = function() {
    }, e.unstable_runWithPriority = function(S, T) {
      switch (S) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          S = 3;
      }
      var P = g;
      g = S;
      try {
        return T();
      } finally {
        g = P;
      }
    }, e.unstable_scheduleCallback = function(S, T, P) {
      var $ = e.unstable_now();
      switch (typeof P == "object" && P !== null ? (P = P.delay, P = typeof P == "number" && 0 < P ? $ + P : $) : P = $, S) {
        case 1:
          var M = -1;
          break;
        case 2:
          M = 250;
          break;
        case 5:
          M = 1073741823;
          break;
        case 4:
          M = 1e4;
          break;
        default:
          M = 5e3;
      }
      return M = P + M, S = { id: f++, callback: T, priorityLevel: S, startTime: P, expirationTime: M, sortIndex: -1 }, P > $ ? (S.sortIndex = P, t(h, S), n(d) === null && S === n(h) && (b ? (x(B), B = -1) : b = !0, te(L, P - $))) : (S.sortIndex = M, t(d, S), E || w || (E = !0, Y(V))), S;
    }, e.unstable_shouldYield = ce, e.unstable_wrapCallback = function(S) {
      var T = g;
      return function() {
        var P = g;
        g = T;
        try {
          return S.apply(this, arguments);
        } finally {
          g = P;
        }
      };
    };
  })(am)), am;
}
var hA;
function XF() {
  return hA || (hA = 1, sm.exports = qF()), sm.exports;
}
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var pA;
function ZF() {
  if (pA) return Xt;
  pA = 1;
  var e = iu(), t = XF();
  function n(o) {
    for (var a = "https://reactjs.org/docs/error-decoder.html?invariant=" + o, c = 1; c < arguments.length; c++) a += "&args[]=" + encodeURIComponent(arguments[c]);
    return "Minified React error #" + o + "; visit " + a + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var r = /* @__PURE__ */ new Set(), i = {};
  function s(o, a) {
    l(o, a), l(o + "Capture", a);
  }
  function l(o, a) {
    for (i[o] = a, o = 0; o < a.length; o++) r.add(a[o]);
  }
  var u = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), d = Object.prototype.hasOwnProperty, h = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, f = {}, m = {};
  function g(o) {
    return d.call(m, o) ? !0 : d.call(f, o) ? !1 : h.test(o) ? m[o] = !0 : (f[o] = !0, !1);
  }
  function w(o, a, c, p) {
    if (c !== null && c.type === 0) return !1;
    switch (typeof a) {
      case "function":
      case "symbol":
        return !0;
      case "boolean":
        return p ? !1 : c !== null ? !c.acceptsBooleans : (o = o.toLowerCase().slice(0, 5), o !== "data-" && o !== "aria-");
      default:
        return !1;
    }
  }
  function E(o, a, c, p) {
    if (a === null || typeof a > "u" || w(o, a, c, p)) return !0;
    if (p) return !1;
    if (c !== null) switch (c.type) {
      case 3:
        return !a;
      case 4:
        return a === !1;
      case 5:
        return isNaN(a);
      case 6:
        return isNaN(a) || 1 > a;
    }
    return !1;
  }
  function b(o, a, c, p, v, y, k) {
    this.acceptsBooleans = a === 2 || a === 3 || a === 4, this.attributeName = p, this.attributeNamespace = v, this.mustUseProperty = c, this.propertyName = o, this.type = a, this.sanitizeURL = y, this.removeEmptyString = k;
  }
  var A = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(o) {
    A[o] = new b(o, 0, !1, o, null, !1, !1);
  }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(o) {
    var a = o[0];
    A[a] = new b(a, 1, !1, o[1], null, !1, !1);
  }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(o) {
    A[o] = new b(o, 2, !1, o.toLowerCase(), null, !1, !1);
  }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(o) {
    A[o] = new b(o, 2, !1, o, null, !1, !1);
  }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(o) {
    A[o] = new b(o, 3, !1, o.toLowerCase(), null, !1, !1);
  }), ["checked", "multiple", "muted", "selected"].forEach(function(o) {
    A[o] = new b(o, 3, !0, o, null, !1, !1);
  }), ["capture", "download"].forEach(function(o) {
    A[o] = new b(o, 4, !1, o, null, !1, !1);
  }), ["cols", "rows", "size", "span"].forEach(function(o) {
    A[o] = new b(o, 6, !1, o, null, !1, !1);
  }), ["rowSpan", "start"].forEach(function(o) {
    A[o] = new b(o, 5, !1, o.toLowerCase(), null, !1, !1);
  });
  var x = /[\-:]([a-z])/g;
  function R(o) {
    return o[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(o) {
    var a = o.replace(
      x,
      R
    );
    A[a] = new b(a, 1, !1, o, null, !1, !1);
  }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(o) {
    var a = o.replace(x, R);
    A[a] = new b(a, 1, !1, o, "http://www.w3.org/1999/xlink", !1, !1);
  }), ["xml:base", "xml:lang", "xml:space"].forEach(function(o) {
    var a = o.replace(x, R);
    A[a] = new b(a, 1, !1, o, "http://www.w3.org/XML/1998/namespace", !1, !1);
  }), ["tabIndex", "crossOrigin"].forEach(function(o) {
    A[o] = new b(o, 1, !1, o.toLowerCase(), null, !1, !1);
  }), A.xlinkHref = new b("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function(o) {
    A[o] = new b(o, 1, !1, o.toLowerCase(), null, !0, !0);
  });
  function _(o, a, c, p) {
    var v = A.hasOwnProperty(a) ? A[a] : null;
    (v !== null ? v.type !== 0 : p || !(2 < a.length) || a[0] !== "o" && a[0] !== "O" || a[1] !== "n" && a[1] !== "N") && (E(a, c, v, p) && (c = null), p || v === null ? g(a) && (c === null ? o.removeAttribute(a) : o.setAttribute(a, "" + c)) : v.mustUseProperty ? o[v.propertyName] = c === null ? v.type === 3 ? !1 : "" : c : (a = v.attributeName, p = v.attributeNamespace, c === null ? o.removeAttribute(a) : (v = v.type, c = v === 3 || v === 4 && c === !0 ? "" : "" + c, p ? o.setAttributeNS(p, a, c) : o.setAttribute(a, c))));
  }
  var L = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, V = Symbol.for("react.element"), O = Symbol.for("react.portal"), D = Symbol.for("react.fragment"), B = Symbol.for("react.strict_mode"), H = Symbol.for("react.profiler"), J = Symbol.for("react.provider"), ce = Symbol.for("react.context"), fe = Symbol.for("react.forward_ref"), de = Symbol.for("react.suspense"), he = Symbol.for("react.suspense_list"), le = Symbol.for("react.memo"), Y = Symbol.for("react.lazy"), te = Symbol.for("react.offscreen"), S = Symbol.iterator;
  function T(o) {
    return o === null || typeof o != "object" ? null : (o = S && o[S] || o["@@iterator"], typeof o == "function" ? o : null);
  }
  var P = Object.assign, $;
  function M(o) {
    if ($ === void 0) try {
      throw Error();
    } catch (c) {
      var a = c.stack.trim().match(/\n( *(at )?)/);
      $ = a && a[1] || "";
    }
    return `
` + $ + o;
  }
  var W = !1;
  function G(o, a) {
    if (!o || W) return "";
    W = !0;
    var c = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (a) if (a = function() {
        throw Error();
      }, Object.defineProperty(a.prototype, "props", { set: function() {
        throw Error();
      } }), typeof Reflect == "object" && Reflect.construct) {
        try {
          Reflect.construct(a, []);
        } catch (X) {
          var p = X;
        }
        Reflect.construct(o, [], a);
      } else {
        try {
          a.call();
        } catch (X) {
          p = X;
        }
        o.call(a.prototype);
      }
      else {
        try {
          throw Error();
        } catch (X) {
          p = X;
        }
        o();
      }
    } catch (X) {
      if (X && p && typeof X.stack == "string") {
        for (var v = X.stack.split(`
`), y = p.stack.split(`
`), k = v.length - 1, N = y.length - 1; 1 <= k && 0 <= N && v[k] !== y[N]; ) N--;
        for (; 1 <= k && 0 <= N; k--, N--) if (v[k] !== y[N]) {
          if (k !== 1 || N !== 1)
            do
              if (k--, N--, 0 > N || v[k] !== y[N]) {
                var F = `
` + v[k].replace(" at new ", " at ");
                return o.displayName && F.includes("<anonymous>") && (F = F.replace("<anonymous>", o.displayName)), F;
              }
            while (1 <= k && 0 <= N);
          break;
        }
      }
    } finally {
      W = !1, Error.prepareStackTrace = c;
    }
    return (o = o ? o.displayName || o.name : "") ? M(o) : "";
  }
  function ee(o) {
    switch (o.tag) {
      case 5:
        return M(o.type);
      case 16:
        return M("Lazy");
      case 13:
        return M("Suspense");
      case 19:
        return M("SuspenseList");
      case 0:
      case 2:
      case 15:
        return o = G(o.type, !1), o;
      case 11:
        return o = G(o.type.render, !1), o;
      case 1:
        return o = G(o.type, !0), o;
      default:
        return "";
    }
  }
  function Q(o) {
    if (o == null) return null;
    if (typeof o == "function") return o.displayName || o.name || null;
    if (typeof o == "string") return o;
    switch (o) {
      case D:
        return "Fragment";
      case O:
        return "Portal";
      case H:
        return "Profiler";
      case B:
        return "StrictMode";
      case de:
        return "Suspense";
      case he:
        return "SuspenseList";
    }
    if (typeof o == "object") switch (o.$$typeof) {
      case ce:
        return (o.displayName || "Context") + ".Consumer";
      case J:
        return (o._context.displayName || "Context") + ".Provider";
      case fe:
        var a = o.render;
        return o = o.displayName, o || (o = a.displayName || a.name || "", o = o !== "" ? "ForwardRef(" + o + ")" : "ForwardRef"), o;
      case le:
        return a = o.displayName || null, a !== null ? a : Q(o.type) || "Memo";
      case Y:
        a = o._payload, o = o._init;
        try {
          return Q(o(a));
        } catch {
        }
    }
    return null;
  }
  function q(o) {
    var a = o.type;
    switch (o.tag) {
      case 24:
        return "Cache";
      case 9:
        return (a.displayName || "Context") + ".Consumer";
      case 10:
        return (a._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return o = a.render, o = o.displayName || o.name || "", a.displayName || (o !== "" ? "ForwardRef(" + o + ")" : "ForwardRef");
      case 7:
        return "Fragment";
      case 5:
        return a;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return Q(a);
      case 8:
        return a === B ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof a == "function") return a.displayName || a.name || null;
        if (typeof a == "string") return a;
    }
    return null;
  }
  function re(o) {
    switch (typeof o) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return o;
      case "object":
        return o;
      default:
        return "";
    }
  }
  function ve(o) {
    var a = o.type;
    return (o = o.nodeName) && o.toLowerCase() === "input" && (a === "checkbox" || a === "radio");
  }
  function Ce(o) {
    var a = ve(o) ? "checked" : "value", c = Object.getOwnPropertyDescriptor(o.constructor.prototype, a), p = "" + o[a];
    if (!o.hasOwnProperty(a) && typeof c < "u" && typeof c.get == "function" && typeof c.set == "function") {
      var v = c.get, y = c.set;
      return Object.defineProperty(o, a, { configurable: !0, get: function() {
        return v.call(this);
      }, set: function(k) {
        p = "" + k, y.call(this, k);
      } }), Object.defineProperty(o, a, { enumerable: c.enumerable }), { getValue: function() {
        return p;
      }, setValue: function(k) {
        p = "" + k;
      }, stopTracking: function() {
        o._valueTracker = null, delete o[a];
      } };
    }
  }
  function Ie(o) {
    o._valueTracker || (o._valueTracker = Ce(o));
  }
  function ze(o) {
    if (!o) return !1;
    var a = o._valueTracker;
    if (!a) return !0;
    var c = a.getValue(), p = "";
    return o && (p = ve(o) ? o.checked ? "true" : "false" : o.value), o = p, o !== c ? (a.setValue(o), !0) : !1;
  }
  function He(o) {
    if (o = o || (typeof document < "u" ? document : void 0), typeof o > "u") return null;
    try {
      return o.activeElement || o.body;
    } catch {
      return o.body;
    }
  }
  function pn(o, a) {
    var c = a.checked;
    return P({}, a, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: c ?? o._wrapperState.initialChecked });
  }
  function Zn(o, a) {
    var c = a.defaultValue == null ? "" : a.defaultValue, p = a.checked != null ? a.checked : a.defaultChecked;
    c = re(a.value != null ? a.value : c), o._wrapperState = { initialChecked: p, initialValue: c, controlled: a.type === "checkbox" || a.type === "radio" ? a.checked != null : a.value != null };
  }
  function tn(o, a) {
    a = a.checked, a != null && _(o, "checked", a, !1);
  }
  function mn(o, a) {
    tn(o, a);
    var c = re(a.value), p = a.type;
    if (c != null) p === "number" ? (c === 0 && o.value === "" || o.value != c) && (o.value = "" + c) : o.value !== "" + c && (o.value = "" + c);
    else if (p === "submit" || p === "reset") {
      o.removeAttribute("value");
      return;
    }
    a.hasOwnProperty("value") ? Ye(o, a.type, c) : a.hasOwnProperty("defaultValue") && Ye(o, a.type, re(a.defaultValue)), a.checked == null && a.defaultChecked != null && (o.defaultChecked = !!a.defaultChecked);
  }
  function Tt(o, a, c) {
    if (a.hasOwnProperty("value") || a.hasOwnProperty("defaultValue")) {
      var p = a.type;
      if (!(p !== "submit" && p !== "reset" || a.value !== void 0 && a.value !== null)) return;
      a = "" + o._wrapperState.initialValue, c || a === o.value || (o.value = a), o.defaultValue = a;
    }
    c = o.name, c !== "" && (o.name = ""), o.defaultChecked = !!o._wrapperState.initialChecked, c !== "" && (o.name = c);
  }
  function Ye(o, a, c) {
    (a !== "number" || He(o.ownerDocument) !== o) && (c == null ? o.defaultValue = "" + o._wrapperState.initialValue : o.defaultValue !== "" + c && (o.defaultValue = "" + c));
  }
  var nn = Array.isArray;
  function In(o, a, c, p) {
    if (o = o.options, a) {
      a = {};
      for (var v = 0; v < c.length; v++) a["$" + c[v]] = !0;
      for (c = 0; c < o.length; c++) v = a.hasOwnProperty("$" + o[c].value), o[c].selected !== v && (o[c].selected = v), v && p && (o[c].defaultSelected = !0);
    } else {
      for (c = "" + re(c), a = null, v = 0; v < o.length; v++) {
        if (o[v].value === c) {
          o[v].selected = !0, p && (o[v].defaultSelected = !0);
          return;
        }
        a !== null || o[v].disabled || (a = o[v]);
      }
      a !== null && (a.selected = !0);
    }
  }
  function ko(o, a) {
    if (a.dangerouslySetInnerHTML != null) throw Error(n(91));
    return P({}, a, { value: void 0, defaultValue: void 0, children: "" + o._wrapperState.initialValue });
  }
  function Aa(o, a) {
    var c = a.value;
    if (c == null) {
      if (c = a.children, a = a.defaultValue, c != null) {
        if (a != null) throw Error(n(92));
        if (nn(c)) {
          if (1 < c.length) throw Error(n(93));
          c = c[0];
        }
        a = c;
      }
      a == null && (a = ""), c = a;
    }
    o._wrapperState = { initialValue: re(c) };
  }
  function Ro(o, a) {
    var c = re(a.value), p = re(a.defaultValue);
    c != null && (c = "" + c, c !== o.value && (o.value = c), a.defaultValue == null && o.defaultValue !== c && (o.defaultValue = c)), p != null && (o.defaultValue = "" + p);
  }
  function xa(o) {
    var a = o.textContent;
    a === o._wrapperState.initialValue && a !== "" && a !== null && (o.value = a);
  }
  function Sa(o) {
    switch (o) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function To(o, a) {
    return o == null || o === "http://www.w3.org/1999/xhtml" ? Sa(a) : o === "http://www.w3.org/2000/svg" && a === "foreignObject" ? "http://www.w3.org/1999/xhtml" : o;
  }
  var xi, db = (function(o) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(a, c, p, v) {
      MSApp.execUnsafeLocalFunction(function() {
        return o(a, c, p, v);
      });
    } : o;
  })(function(o, a) {
    if (o.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in o) o.innerHTML = a;
    else {
      for (xi = xi || document.createElement("div"), xi.innerHTML = "<svg>" + a.valueOf().toString() + "</svg>", a = xi.firstChild; o.firstChild; ) o.removeChild(o.firstChild);
      for (; a.firstChild; ) o.appendChild(a.firstChild);
    }
  });
  function ka(o, a) {
    if (a) {
      var c = o.firstChild;
      if (c && c === o.lastChild && c.nodeType === 3) {
        c.nodeValue = a;
        return;
      }
    }
    o.textContent = a;
  }
  var Ra = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  }, J2 = ["Webkit", "ms", "Moz", "O"];
  Object.keys(Ra).forEach(function(o) {
    J2.forEach(function(a) {
      a = a + o.charAt(0).toUpperCase() + o.substring(1), Ra[a] = Ra[o];
    });
  });
  function fb(o, a, c) {
    return a == null || typeof a == "boolean" || a === "" ? "" : c || typeof a != "number" || a === 0 || Ra.hasOwnProperty(o) && Ra[o] ? ("" + a).trim() : a + "px";
  }
  function hb(o, a) {
    o = o.style;
    for (var c in a) if (a.hasOwnProperty(c)) {
      var p = c.indexOf("--") === 0, v = fb(c, a[c], p);
      c === "float" && (c = "cssFloat"), p ? o.setProperty(c, v) : o[c] = v;
    }
  }
  var eP = P({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 });
  function Yf(o, a) {
    if (a) {
      if (eP[o] && (a.children != null || a.dangerouslySetInnerHTML != null)) throw Error(n(137, o));
      if (a.dangerouslySetInnerHTML != null) {
        if (a.children != null) throw Error(n(60));
        if (typeof a.dangerouslySetInnerHTML != "object" || !("__html" in a.dangerouslySetInnerHTML)) throw Error(n(61));
      }
      if (a.style != null && typeof a.style != "object") throw Error(n(62));
    }
  }
  function qf(o, a) {
    if (o.indexOf("-") === -1) return typeof a.is == "string";
    switch (o) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var Xf = null;
  function Zf(o) {
    return o = o.target || o.srcElement || window, o.correspondingUseElement && (o = o.correspondingUseElement), o.nodeType === 3 ? o.parentNode : o;
  }
  var Qf = null, $o = null, Vo = null;
  function pb(o) {
    if (o = qa(o)) {
      if (typeof Qf != "function") throw Error(n(280));
      var a = o.stateNode;
      a && (a = Zu(a), Qf(o.stateNode, o.type, a));
    }
  }
  function mb(o) {
    $o ? Vo ? Vo.push(o) : Vo = [o] : $o = o;
  }
  function gb() {
    if ($o) {
      var o = $o, a = Vo;
      if (Vo = $o = null, pb(o), a) for (o = 0; o < a.length; o++) pb(a[o]);
    }
  }
  function vb(o, a) {
    return o(a);
  }
  function yb() {
  }
  var Jf = !1;
  function wb(o, a, c) {
    if (Jf) return o(a, c);
    Jf = !0;
    try {
      return vb(o, a, c);
    } finally {
      Jf = !1, ($o !== null || Vo !== null) && (yb(), gb());
    }
  }
  function Ta(o, a) {
    var c = o.stateNode;
    if (c === null) return null;
    var p = Zu(c);
    if (p === null) return null;
    c = p[a];
    e: switch (a) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (p = !p.disabled) || (o = o.type, p = !(o === "button" || o === "input" || o === "select" || o === "textarea")), o = !p;
        break e;
      default:
        o = !1;
    }
    if (o) return null;
    if (c && typeof c != "function") throw Error(n(231, a, typeof c));
    return c;
  }
  var eh = !1;
  if (u) try {
    var $a = {};
    Object.defineProperty($a, "passive", { get: function() {
      eh = !0;
    } }), window.addEventListener("test", $a, $a), window.removeEventListener("test", $a, $a);
  } catch {
    eh = !1;
  }
  function tP(o, a, c, p, v, y, k, N, F) {
    var X = Array.prototype.slice.call(arguments, 3);
    try {
      a.apply(c, X);
    } catch (oe) {
      this.onError(oe);
    }
  }
  var Va = !1, $u = null, Vu = !1, th = null, nP = { onError: function(o) {
    Va = !0, $u = o;
  } };
  function rP(o, a, c, p, v, y, k, N, F) {
    Va = !1, $u = null, tP.apply(nP, arguments);
  }
  function iP(o, a, c, p, v, y, k, N, F) {
    if (rP.apply(this, arguments), Va) {
      if (Va) {
        var X = $u;
        Va = !1, $u = null;
      } else throw Error(n(198));
      Vu || (Vu = !0, th = X);
    }
  }
  function Si(o) {
    var a = o, c = o;
    if (o.alternate) for (; a.return; ) a = a.return;
    else {
      o = a;
      do
        a = o, (a.flags & 4098) !== 0 && (c = a.return), o = a.return;
      while (o);
    }
    return a.tag === 3 ? c : null;
  }
  function bb(o) {
    if (o.tag === 13) {
      var a = o.memoizedState;
      if (a === null && (o = o.alternate, o !== null && (a = o.memoizedState)), a !== null) return a.dehydrated;
    }
    return null;
  }
  function Cb(o) {
    if (Si(o) !== o) throw Error(n(188));
  }
  function oP(o) {
    var a = o.alternate;
    if (!a) {
      if (a = Si(o), a === null) throw Error(n(188));
      return a !== o ? null : o;
    }
    for (var c = o, p = a; ; ) {
      var v = c.return;
      if (v === null) break;
      var y = v.alternate;
      if (y === null) {
        if (p = v.return, p !== null) {
          c = p;
          continue;
        }
        break;
      }
      if (v.child === y.child) {
        for (y = v.child; y; ) {
          if (y === c) return Cb(v), o;
          if (y === p) return Cb(v), a;
          y = y.sibling;
        }
        throw Error(n(188));
      }
      if (c.return !== p.return) c = v, p = y;
      else {
        for (var k = !1, N = v.child; N; ) {
          if (N === c) {
            k = !0, c = v, p = y;
            break;
          }
          if (N === p) {
            k = !0, p = v, c = y;
            break;
          }
          N = N.sibling;
        }
        if (!k) {
          for (N = y.child; N; ) {
            if (N === c) {
              k = !0, c = y, p = v;
              break;
            }
            if (N === p) {
              k = !0, p = y, c = v;
              break;
            }
            N = N.sibling;
          }
          if (!k) throw Error(n(189));
        }
      }
      if (c.alternate !== p) throw Error(n(190));
    }
    if (c.tag !== 3) throw Error(n(188));
    return c.stateNode.current === c ? o : a;
  }
  function Eb(o) {
    return o = oP(o), o !== null ? Ab(o) : null;
  }
  function Ab(o) {
    if (o.tag === 5 || o.tag === 6) return o;
    for (o = o.child; o !== null; ) {
      var a = Ab(o);
      if (a !== null) return a;
      o = o.sibling;
    }
    return null;
  }
  var xb = t.unstable_scheduleCallback, Sb = t.unstable_cancelCallback, sP = t.unstable_shouldYield, aP = t.unstable_requestPaint, st = t.unstable_now, lP = t.unstable_getCurrentPriorityLevel, nh = t.unstable_ImmediatePriority, kb = t.unstable_UserBlockingPriority, _u = t.unstable_NormalPriority, uP = t.unstable_LowPriority, Rb = t.unstable_IdlePriority, Iu = null, Qn = null;
  function cP(o) {
    if (Qn && typeof Qn.onCommitFiberRoot == "function") try {
      Qn.onCommitFiberRoot(Iu, o, void 0, (o.current.flags & 128) === 128);
    } catch {
    }
  }
  var Ln = Math.clz32 ? Math.clz32 : hP, dP = Math.log, fP = Math.LN2;
  function hP(o) {
    return o >>>= 0, o === 0 ? 32 : 31 - (dP(o) / fP | 0) | 0;
  }
  var Lu = 64, Pu = 4194304;
  function _a(o) {
    switch (o & -o) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return o & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return o & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return o;
    }
  }
  function Mu(o, a) {
    var c = o.pendingLanes;
    if (c === 0) return 0;
    var p = 0, v = o.suspendedLanes, y = o.pingedLanes, k = c & 268435455;
    if (k !== 0) {
      var N = k & ~v;
      N !== 0 ? p = _a(N) : (y &= k, y !== 0 && (p = _a(y)));
    } else k = c & ~v, k !== 0 ? p = _a(k) : y !== 0 && (p = _a(y));
    if (p === 0) return 0;
    if (a !== 0 && a !== p && (a & v) === 0 && (v = p & -p, y = a & -a, v >= y || v === 16 && (y & 4194240) !== 0)) return a;
    if ((p & 4) !== 0 && (p |= c & 16), a = o.entangledLanes, a !== 0) for (o = o.entanglements, a &= p; 0 < a; ) c = 31 - Ln(a), v = 1 << c, p |= o[c], a &= ~v;
    return p;
  }
  function pP(o, a) {
    switch (o) {
      case 1:
      case 2:
      case 4:
        return a + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return a + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function mP(o, a) {
    for (var c = o.suspendedLanes, p = o.pingedLanes, v = o.expirationTimes, y = o.pendingLanes; 0 < y; ) {
      var k = 31 - Ln(y), N = 1 << k, F = v[k];
      F === -1 ? ((N & c) === 0 || (N & p) !== 0) && (v[k] = pP(N, a)) : F <= a && (o.expiredLanes |= N), y &= ~N;
    }
  }
  function rh(o) {
    return o = o.pendingLanes & -1073741825, o !== 0 ? o : o & 1073741824 ? 1073741824 : 0;
  }
  function Tb() {
    var o = Lu;
    return Lu <<= 1, (Lu & 4194240) === 0 && (Lu = 64), o;
  }
  function ih(o) {
    for (var a = [], c = 0; 31 > c; c++) a.push(o);
    return a;
  }
  function Ia(o, a, c) {
    o.pendingLanes |= a, a !== 536870912 && (o.suspendedLanes = 0, o.pingedLanes = 0), o = o.eventTimes, a = 31 - Ln(a), o[a] = c;
  }
  function gP(o, a) {
    var c = o.pendingLanes & ~a;
    o.pendingLanes = a, o.suspendedLanes = 0, o.pingedLanes = 0, o.expiredLanes &= a, o.mutableReadLanes &= a, o.entangledLanes &= a, a = o.entanglements;
    var p = o.eventTimes;
    for (o = o.expirationTimes; 0 < c; ) {
      var v = 31 - Ln(c), y = 1 << v;
      a[v] = 0, p[v] = -1, o[v] = -1, c &= ~y;
    }
  }
  function oh(o, a) {
    var c = o.entangledLanes |= a;
    for (o = o.entanglements; c; ) {
      var p = 31 - Ln(c), v = 1 << p;
      v & a | o[p] & a && (o[p] |= a), c &= ~v;
    }
  }
  var Ke = 0;
  function $b(o) {
    return o &= -o, 1 < o ? 4 < o ? (o & 268435455) !== 0 ? 16 : 536870912 : 4 : 1;
  }
  var Vb, sh, _b, Ib, Lb, ah = !1, Ou = [], Wr = null, zr = null, Hr = null, La = /* @__PURE__ */ new Map(), Pa = /* @__PURE__ */ new Map(), Kr = [], vP = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
  function Pb(o, a) {
    switch (o) {
      case "focusin":
      case "focusout":
        Wr = null;
        break;
      case "dragenter":
      case "dragleave":
        zr = null;
        break;
      case "mouseover":
      case "mouseout":
        Hr = null;
        break;
      case "pointerover":
      case "pointerout":
        La.delete(a.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        Pa.delete(a.pointerId);
    }
  }
  function Ma(o, a, c, p, v, y) {
    return o === null || o.nativeEvent !== y ? (o = { blockedOn: a, domEventName: c, eventSystemFlags: p, nativeEvent: y, targetContainers: [v] }, a !== null && (a = qa(a), a !== null && sh(a)), o) : (o.eventSystemFlags |= p, a = o.targetContainers, v !== null && a.indexOf(v) === -1 && a.push(v), o);
  }
  function yP(o, a, c, p, v) {
    switch (a) {
      case "focusin":
        return Wr = Ma(Wr, o, a, c, p, v), !0;
      case "dragenter":
        return zr = Ma(zr, o, a, c, p, v), !0;
      case "mouseover":
        return Hr = Ma(Hr, o, a, c, p, v), !0;
      case "pointerover":
        var y = v.pointerId;
        return La.set(y, Ma(La.get(y) || null, o, a, c, p, v)), !0;
      case "gotpointercapture":
        return y = v.pointerId, Pa.set(y, Ma(Pa.get(y) || null, o, a, c, p, v)), !0;
    }
    return !1;
  }
  function Mb(o) {
    var a = ki(o.target);
    if (a !== null) {
      var c = Si(a);
      if (c !== null) {
        if (a = c.tag, a === 13) {
          if (a = bb(c), a !== null) {
            o.blockedOn = a, Lb(o.priority, function() {
              _b(c);
            });
            return;
          }
        } else if (a === 3 && c.stateNode.current.memoizedState.isDehydrated) {
          o.blockedOn = c.tag === 3 ? c.stateNode.containerInfo : null;
          return;
        }
      }
    }
    o.blockedOn = null;
  }
  function Bu(o) {
    if (o.blockedOn !== null) return !1;
    for (var a = o.targetContainers; 0 < a.length; ) {
      var c = uh(o.domEventName, o.eventSystemFlags, a[0], o.nativeEvent);
      if (c === null) {
        c = o.nativeEvent;
        var p = new c.constructor(c.type, c);
        Xf = p, c.target.dispatchEvent(p), Xf = null;
      } else return a = qa(c), a !== null && sh(a), o.blockedOn = c, !1;
      a.shift();
    }
    return !0;
  }
  function Ob(o, a, c) {
    Bu(o) && c.delete(a);
  }
  function wP() {
    ah = !1, Wr !== null && Bu(Wr) && (Wr = null), zr !== null && Bu(zr) && (zr = null), Hr !== null && Bu(Hr) && (Hr = null), La.forEach(Ob), Pa.forEach(Ob);
  }
  function Oa(o, a) {
    o.blockedOn === a && (o.blockedOn = null, ah || (ah = !0, t.unstable_scheduleCallback(t.unstable_NormalPriority, wP)));
  }
  function Ba(o) {
    function a(v) {
      return Oa(v, o);
    }
    if (0 < Ou.length) {
      Oa(Ou[0], o);
      for (var c = 1; c < Ou.length; c++) {
        var p = Ou[c];
        p.blockedOn === o && (p.blockedOn = null);
      }
    }
    for (Wr !== null && Oa(Wr, o), zr !== null && Oa(zr, o), Hr !== null && Oa(Hr, o), La.forEach(a), Pa.forEach(a), c = 0; c < Kr.length; c++) p = Kr[c], p.blockedOn === o && (p.blockedOn = null);
    for (; 0 < Kr.length && (c = Kr[0], c.blockedOn === null); ) Mb(c), c.blockedOn === null && Kr.shift();
  }
  var _o = L.ReactCurrentBatchConfig, Nu = !0;
  function bP(o, a, c, p) {
    var v = Ke, y = _o.transition;
    _o.transition = null;
    try {
      Ke = 1, lh(o, a, c, p);
    } finally {
      Ke = v, _o.transition = y;
    }
  }
  function CP(o, a, c, p) {
    var v = Ke, y = _o.transition;
    _o.transition = null;
    try {
      Ke = 4, lh(o, a, c, p);
    } finally {
      Ke = v, _o.transition = y;
    }
  }
  function lh(o, a, c, p) {
    if (Nu) {
      var v = uh(o, a, c, p);
      if (v === null) kh(o, a, p, Du, c), Pb(o, p);
      else if (yP(v, o, a, c, p)) p.stopPropagation();
      else if (Pb(o, p), a & 4 && -1 < vP.indexOf(o)) {
        for (; v !== null; ) {
          var y = qa(v);
          if (y !== null && Vb(y), y = uh(o, a, c, p), y === null && kh(o, a, p, Du, c), y === v) break;
          v = y;
        }
        v !== null && p.stopPropagation();
      } else kh(o, a, p, null, c);
    }
  }
  var Du = null;
  function uh(o, a, c, p) {
    if (Du = null, o = Zf(p), o = ki(o), o !== null) if (a = Si(o), a === null) o = null;
    else if (c = a.tag, c === 13) {
      if (o = bb(a), o !== null) return o;
      o = null;
    } else if (c === 3) {
      if (a.stateNode.current.memoizedState.isDehydrated) return a.tag === 3 ? a.stateNode.containerInfo : null;
      o = null;
    } else a !== o && (o = null);
    return Du = o, null;
  }
  function Bb(o) {
    switch (o) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (lP()) {
          case nh:
            return 1;
          case kb:
            return 4;
          case _u:
          case uP:
            return 16;
          case Rb:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var Gr = null, ch = null, ju = null;
  function Nb() {
    if (ju) return ju;
    var o, a = ch, c = a.length, p, v = "value" in Gr ? Gr.value : Gr.textContent, y = v.length;
    for (o = 0; o < c && a[o] === v[o]; o++) ;
    var k = c - o;
    for (p = 1; p <= k && a[c - p] === v[y - p]; p++) ;
    return ju = v.slice(o, 1 < p ? 1 - p : void 0);
  }
  function Fu(o) {
    var a = o.keyCode;
    return "charCode" in o ? (o = o.charCode, o === 0 && a === 13 && (o = 13)) : o = a, o === 10 && (o = 13), 32 <= o || o === 13 ? o : 0;
  }
  function Uu() {
    return !0;
  }
  function Db() {
    return !1;
  }
  function rn(o) {
    function a(c, p, v, y, k) {
      this._reactName = c, this._targetInst = v, this.type = p, this.nativeEvent = y, this.target = k, this.currentTarget = null;
      for (var N in o) o.hasOwnProperty(N) && (c = o[N], this[N] = c ? c(y) : y[N]);
      return this.isDefaultPrevented = (y.defaultPrevented != null ? y.defaultPrevented : y.returnValue === !1) ? Uu : Db, this.isPropagationStopped = Db, this;
    }
    return P(a.prototype, { preventDefault: function() {
      this.defaultPrevented = !0;
      var c = this.nativeEvent;
      c && (c.preventDefault ? c.preventDefault() : typeof c.returnValue != "unknown" && (c.returnValue = !1), this.isDefaultPrevented = Uu);
    }, stopPropagation: function() {
      var c = this.nativeEvent;
      c && (c.stopPropagation ? c.stopPropagation() : typeof c.cancelBubble != "unknown" && (c.cancelBubble = !0), this.isPropagationStopped = Uu);
    }, persist: function() {
    }, isPersistent: Uu }), a;
  }
  var Io = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(o) {
    return o.timeStamp || Date.now();
  }, defaultPrevented: 0, isTrusted: 0 }, dh = rn(Io), Na = P({}, Io, { view: 0, detail: 0 }), EP = rn(Na), fh, hh, Da, Wu = P({}, Na, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: mh, button: 0, buttons: 0, relatedTarget: function(o) {
    return o.relatedTarget === void 0 ? o.fromElement === o.srcElement ? o.toElement : o.fromElement : o.relatedTarget;
  }, movementX: function(o) {
    return "movementX" in o ? o.movementX : (o !== Da && (Da && o.type === "mousemove" ? (fh = o.screenX - Da.screenX, hh = o.screenY - Da.screenY) : hh = fh = 0, Da = o), fh);
  }, movementY: function(o) {
    return "movementY" in o ? o.movementY : hh;
  } }), jb = rn(Wu), AP = P({}, Wu, { dataTransfer: 0 }), xP = rn(AP), SP = P({}, Na, { relatedTarget: 0 }), ph = rn(SP), kP = P({}, Io, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), RP = rn(kP), TP = P({}, Io, { clipboardData: function(o) {
    return "clipboardData" in o ? o.clipboardData : window.clipboardData;
  } }), $P = rn(TP), VP = P({}, Io, { data: 0 }), Fb = rn(VP), _P = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, IP = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, LP = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
  function PP(o) {
    var a = this.nativeEvent;
    return a.getModifierState ? a.getModifierState(o) : (o = LP[o]) ? !!a[o] : !1;
  }
  function mh() {
    return PP;
  }
  var MP = P({}, Na, { key: function(o) {
    if (o.key) {
      var a = _P[o.key] || o.key;
      if (a !== "Unidentified") return a;
    }
    return o.type === "keypress" ? (o = Fu(o), o === 13 ? "Enter" : String.fromCharCode(o)) : o.type === "keydown" || o.type === "keyup" ? IP[o.keyCode] || "Unidentified" : "";
  }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: mh, charCode: function(o) {
    return o.type === "keypress" ? Fu(o) : 0;
  }, keyCode: function(o) {
    return o.type === "keydown" || o.type === "keyup" ? o.keyCode : 0;
  }, which: function(o) {
    return o.type === "keypress" ? Fu(o) : o.type === "keydown" || o.type === "keyup" ? o.keyCode : 0;
  } }), OP = rn(MP), BP = P({}, Wu, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Ub = rn(BP), NP = P({}, Na, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: mh }), DP = rn(NP), jP = P({}, Io, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), FP = rn(jP), UP = P({}, Wu, {
    deltaX: function(o) {
      return "deltaX" in o ? o.deltaX : "wheelDeltaX" in o ? -o.wheelDeltaX : 0;
    },
    deltaY: function(o) {
      return "deltaY" in o ? o.deltaY : "wheelDeltaY" in o ? -o.wheelDeltaY : "wheelDelta" in o ? -o.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), WP = rn(UP), zP = [9, 13, 27, 32], gh = u && "CompositionEvent" in window, ja = null;
  u && "documentMode" in document && (ja = document.documentMode);
  var HP = u && "TextEvent" in window && !ja, Wb = u && (!gh || ja && 8 < ja && 11 >= ja), zb = " ", Hb = !1;
  function Kb(o, a) {
    switch (o) {
      case "keyup":
        return zP.indexOf(a.keyCode) !== -1;
      case "keydown":
        return a.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function Gb(o) {
    return o = o.detail, typeof o == "object" && "data" in o ? o.data : null;
  }
  var Lo = !1;
  function KP(o, a) {
    switch (o) {
      case "compositionend":
        return Gb(a);
      case "keypress":
        return a.which !== 32 ? null : (Hb = !0, zb);
      case "textInput":
        return o = a.data, o === zb && Hb ? null : o;
      default:
        return null;
    }
  }
  function GP(o, a) {
    if (Lo) return o === "compositionend" || !gh && Kb(o, a) ? (o = Nb(), ju = ch = Gr = null, Lo = !1, o) : null;
    switch (o) {
      case "paste":
        return null;
      case "keypress":
        if (!(a.ctrlKey || a.altKey || a.metaKey) || a.ctrlKey && a.altKey) {
          if (a.char && 1 < a.char.length) return a.char;
          if (a.which) return String.fromCharCode(a.which);
        }
        return null;
      case "compositionend":
        return Wb && a.locale !== "ko" ? null : a.data;
      default:
        return null;
    }
  }
  var YP = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 };
  function Yb(o) {
    var a = o && o.nodeName && o.nodeName.toLowerCase();
    return a === "input" ? !!YP[o.type] : a === "textarea";
  }
  function qb(o, a, c, p) {
    mb(p), a = Yu(a, "onChange"), 0 < a.length && (c = new dh("onChange", "change", null, c, p), o.push({ event: c, listeners: a }));
  }
  var Fa = null, Ua = null;
  function qP(o) {
    h1(o, 0);
  }
  function zu(o) {
    var a = No(o);
    if (ze(a)) return o;
  }
  function XP(o, a) {
    if (o === "change") return a;
  }
  var Xb = !1;
  if (u) {
    var vh;
    if (u) {
      var yh = "oninput" in document;
      if (!yh) {
        var Zb = document.createElement("div");
        Zb.setAttribute("oninput", "return;"), yh = typeof Zb.oninput == "function";
      }
      vh = yh;
    } else vh = !1;
    Xb = vh && (!document.documentMode || 9 < document.documentMode);
  }
  function Qb() {
    Fa && (Fa.detachEvent("onpropertychange", Jb), Ua = Fa = null);
  }
  function Jb(o) {
    if (o.propertyName === "value" && zu(Ua)) {
      var a = [];
      qb(a, Ua, o, Zf(o)), wb(qP, a);
    }
  }
  function ZP(o, a, c) {
    o === "focusin" ? (Qb(), Fa = a, Ua = c, Fa.attachEvent("onpropertychange", Jb)) : o === "focusout" && Qb();
  }
  function QP(o) {
    if (o === "selectionchange" || o === "keyup" || o === "keydown") return zu(Ua);
  }
  function JP(o, a) {
    if (o === "click") return zu(a);
  }
  function eM(o, a) {
    if (o === "input" || o === "change") return zu(a);
  }
  function tM(o, a) {
    return o === a && (o !== 0 || 1 / o === 1 / a) || o !== o && a !== a;
  }
  var Pn = typeof Object.is == "function" ? Object.is : tM;
  function Wa(o, a) {
    if (Pn(o, a)) return !0;
    if (typeof o != "object" || o === null || typeof a != "object" || a === null) return !1;
    var c = Object.keys(o), p = Object.keys(a);
    if (c.length !== p.length) return !1;
    for (p = 0; p < c.length; p++) {
      var v = c[p];
      if (!d.call(a, v) || !Pn(o[v], a[v])) return !1;
    }
    return !0;
  }
  function e1(o) {
    for (; o && o.firstChild; ) o = o.firstChild;
    return o;
  }
  function t1(o, a) {
    var c = e1(o);
    o = 0;
    for (var p; c; ) {
      if (c.nodeType === 3) {
        if (p = o + c.textContent.length, o <= a && p >= a) return { node: c, offset: a - o };
        o = p;
      }
      e: {
        for (; c; ) {
          if (c.nextSibling) {
            c = c.nextSibling;
            break e;
          }
          c = c.parentNode;
        }
        c = void 0;
      }
      c = e1(c);
    }
  }
  function n1(o, a) {
    return o && a ? o === a ? !0 : o && o.nodeType === 3 ? !1 : a && a.nodeType === 3 ? n1(o, a.parentNode) : "contains" in o ? o.contains(a) : o.compareDocumentPosition ? !!(o.compareDocumentPosition(a) & 16) : !1 : !1;
  }
  function r1() {
    for (var o = window, a = He(); a instanceof o.HTMLIFrameElement; ) {
      try {
        var c = typeof a.contentWindow.location.href == "string";
      } catch {
        c = !1;
      }
      if (c) o = a.contentWindow;
      else break;
      a = He(o.document);
    }
    return a;
  }
  function wh(o) {
    var a = o && o.nodeName && o.nodeName.toLowerCase();
    return a && (a === "input" && (o.type === "text" || o.type === "search" || o.type === "tel" || o.type === "url" || o.type === "password") || a === "textarea" || o.contentEditable === "true");
  }
  function nM(o) {
    var a = r1(), c = o.focusedElem, p = o.selectionRange;
    if (a !== c && c && c.ownerDocument && n1(c.ownerDocument.documentElement, c)) {
      if (p !== null && wh(c)) {
        if (a = p.start, o = p.end, o === void 0 && (o = a), "selectionStart" in c) c.selectionStart = a, c.selectionEnd = Math.min(o, c.value.length);
        else if (o = (a = c.ownerDocument || document) && a.defaultView || window, o.getSelection) {
          o = o.getSelection();
          var v = c.textContent.length, y = Math.min(p.start, v);
          p = p.end === void 0 ? y : Math.min(p.end, v), !o.extend && y > p && (v = p, p = y, y = v), v = t1(c, y);
          var k = t1(
            c,
            p
          );
          v && k && (o.rangeCount !== 1 || o.anchorNode !== v.node || o.anchorOffset !== v.offset || o.focusNode !== k.node || o.focusOffset !== k.offset) && (a = a.createRange(), a.setStart(v.node, v.offset), o.removeAllRanges(), y > p ? (o.addRange(a), o.extend(k.node, k.offset)) : (a.setEnd(k.node, k.offset), o.addRange(a)));
        }
      }
      for (a = [], o = c; o = o.parentNode; ) o.nodeType === 1 && a.push({ element: o, left: o.scrollLeft, top: o.scrollTop });
      for (typeof c.focus == "function" && c.focus(), c = 0; c < a.length; c++) o = a[c], o.element.scrollLeft = o.left, o.element.scrollTop = o.top;
    }
  }
  var rM = u && "documentMode" in document && 11 >= document.documentMode, Po = null, bh = null, za = null, Ch = !1;
  function i1(o, a, c) {
    var p = c.window === c ? c.document : c.nodeType === 9 ? c : c.ownerDocument;
    Ch || Po == null || Po !== He(p) || (p = Po, "selectionStart" in p && wh(p) ? p = { start: p.selectionStart, end: p.selectionEnd } : (p = (p.ownerDocument && p.ownerDocument.defaultView || window).getSelection(), p = { anchorNode: p.anchorNode, anchorOffset: p.anchorOffset, focusNode: p.focusNode, focusOffset: p.focusOffset }), za && Wa(za, p) || (za = p, p = Yu(bh, "onSelect"), 0 < p.length && (a = new dh("onSelect", "select", null, a, c), o.push({ event: a, listeners: p }), a.target = Po)));
  }
  function Hu(o, a) {
    var c = {};
    return c[o.toLowerCase()] = a.toLowerCase(), c["Webkit" + o] = "webkit" + a, c["Moz" + o] = "moz" + a, c;
  }
  var Mo = { animationend: Hu("Animation", "AnimationEnd"), animationiteration: Hu("Animation", "AnimationIteration"), animationstart: Hu("Animation", "AnimationStart"), transitionend: Hu("Transition", "TransitionEnd") }, Eh = {}, o1 = {};
  u && (o1 = document.createElement("div").style, "AnimationEvent" in window || (delete Mo.animationend.animation, delete Mo.animationiteration.animation, delete Mo.animationstart.animation), "TransitionEvent" in window || delete Mo.transitionend.transition);
  function Ku(o) {
    if (Eh[o]) return Eh[o];
    if (!Mo[o]) return o;
    var a = Mo[o], c;
    for (c in a) if (a.hasOwnProperty(c) && c in o1) return Eh[o] = a[c];
    return o;
  }
  var s1 = Ku("animationend"), a1 = Ku("animationiteration"), l1 = Ku("animationstart"), u1 = Ku("transitionend"), c1 = /* @__PURE__ */ new Map(), d1 = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
  function Yr(o, a) {
    c1.set(o, a), s(a, [o]);
  }
  for (var Ah = 0; Ah < d1.length; Ah++) {
    var xh = d1[Ah], iM = xh.toLowerCase(), oM = xh[0].toUpperCase() + xh.slice(1);
    Yr(iM, "on" + oM);
  }
  Yr(s1, "onAnimationEnd"), Yr(a1, "onAnimationIteration"), Yr(l1, "onAnimationStart"), Yr("dblclick", "onDoubleClick"), Yr("focusin", "onFocus"), Yr("focusout", "onBlur"), Yr(u1, "onTransitionEnd"), l("onMouseEnter", ["mouseout", "mouseover"]), l("onMouseLeave", ["mouseout", "mouseover"]), l("onPointerEnter", ["pointerout", "pointerover"]), l("onPointerLeave", ["pointerout", "pointerover"]), s("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), s("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), s("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), s("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), s("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), s("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  var Ha = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), sM = new Set("cancel close invalid load scroll toggle".split(" ").concat(Ha));
  function f1(o, a, c) {
    var p = o.type || "unknown-event";
    o.currentTarget = c, iP(p, a, void 0, o), o.currentTarget = null;
  }
  function h1(o, a) {
    a = (a & 4) !== 0;
    for (var c = 0; c < o.length; c++) {
      var p = o[c], v = p.event;
      p = p.listeners;
      e: {
        var y = void 0;
        if (a) for (var k = p.length - 1; 0 <= k; k--) {
          var N = p[k], F = N.instance, X = N.currentTarget;
          if (N = N.listener, F !== y && v.isPropagationStopped()) break e;
          f1(v, N, X), y = F;
        }
        else for (k = 0; k < p.length; k++) {
          if (N = p[k], F = N.instance, X = N.currentTarget, N = N.listener, F !== y && v.isPropagationStopped()) break e;
          f1(v, N, X), y = F;
        }
      }
    }
    if (Vu) throw o = th, Vu = !1, th = null, o;
  }
  function qe(o, a) {
    var c = a[Ih];
    c === void 0 && (c = a[Ih] = /* @__PURE__ */ new Set());
    var p = o + "__bubble";
    c.has(p) || (p1(a, o, 2, !1), c.add(p));
  }
  function Sh(o, a, c) {
    var p = 0;
    a && (p |= 4), p1(c, o, p, a);
  }
  var Gu = "_reactListening" + Math.random().toString(36).slice(2);
  function Ka(o) {
    if (!o[Gu]) {
      o[Gu] = !0, r.forEach(function(c) {
        c !== "selectionchange" && (sM.has(c) || Sh(c, !1, o), Sh(c, !0, o));
      });
      var a = o.nodeType === 9 ? o : o.ownerDocument;
      a === null || a[Gu] || (a[Gu] = !0, Sh("selectionchange", !1, a));
    }
  }
  function p1(o, a, c, p) {
    switch (Bb(a)) {
      case 1:
        var v = bP;
        break;
      case 4:
        v = CP;
        break;
      default:
        v = lh;
    }
    c = v.bind(null, a, c, o), v = void 0, !eh || a !== "touchstart" && a !== "touchmove" && a !== "wheel" || (v = !0), p ? v !== void 0 ? o.addEventListener(a, c, { capture: !0, passive: v }) : o.addEventListener(a, c, !0) : v !== void 0 ? o.addEventListener(a, c, { passive: v }) : o.addEventListener(a, c, !1);
  }
  function kh(o, a, c, p, v) {
    var y = p;
    if ((a & 1) === 0 && (a & 2) === 0 && p !== null) e: for (; ; ) {
      if (p === null) return;
      var k = p.tag;
      if (k === 3 || k === 4) {
        var N = p.stateNode.containerInfo;
        if (N === v || N.nodeType === 8 && N.parentNode === v) break;
        if (k === 4) for (k = p.return; k !== null; ) {
          var F = k.tag;
          if ((F === 3 || F === 4) && (F = k.stateNode.containerInfo, F === v || F.nodeType === 8 && F.parentNode === v)) return;
          k = k.return;
        }
        for (; N !== null; ) {
          if (k = ki(N), k === null) return;
          if (F = k.tag, F === 5 || F === 6) {
            p = y = k;
            continue e;
          }
          N = N.parentNode;
        }
      }
      p = p.return;
    }
    wb(function() {
      var X = y, oe = Zf(c), ae = [];
      e: {
        var ie = c1.get(o);
        if (ie !== void 0) {
          var me = dh, ye = o;
          switch (o) {
            case "keypress":
              if (Fu(c) === 0) break e;
            case "keydown":
            case "keyup":
              me = OP;
              break;
            case "focusin":
              ye = "focus", me = ph;
              break;
            case "focusout":
              ye = "blur", me = ph;
              break;
            case "beforeblur":
            case "afterblur":
              me = ph;
              break;
            case "click":
              if (c.button === 2) break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              me = jb;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              me = xP;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              me = DP;
              break;
            case s1:
            case a1:
            case l1:
              me = RP;
              break;
            case u1:
              me = FP;
              break;
            case "scroll":
              me = EP;
              break;
            case "wheel":
              me = WP;
              break;
            case "copy":
            case "cut":
            case "paste":
              me = $P;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              me = Ub;
          }
          var we = (a & 4) !== 0, at = !we && o === "scroll", z = we ? ie !== null ? ie + "Capture" : null : ie;
          we = [];
          for (var U = X, K; U !== null; ) {
            K = U;
            var ue = K.stateNode;
            if (K.tag === 5 && ue !== null && (K = ue, z !== null && (ue = Ta(U, z), ue != null && we.push(Ga(U, ue, K)))), at) break;
            U = U.return;
          }
          0 < we.length && (ie = new me(ie, ye, null, c, oe), ae.push({ event: ie, listeners: we }));
        }
      }
      if ((a & 7) === 0) {
        e: {
          if (ie = o === "mouseover" || o === "pointerover", me = o === "mouseout" || o === "pointerout", ie && c !== Xf && (ye = c.relatedTarget || c.fromElement) && (ki(ye) || ye[gr])) break e;
          if ((me || ie) && (ie = oe.window === oe ? oe : (ie = oe.ownerDocument) ? ie.defaultView || ie.parentWindow : window, me ? (ye = c.relatedTarget || c.toElement, me = X, ye = ye ? ki(ye) : null, ye !== null && (at = Si(ye), ye !== at || ye.tag !== 5 && ye.tag !== 6) && (ye = null)) : (me = null, ye = X), me !== ye)) {
            if (we = jb, ue = "onMouseLeave", z = "onMouseEnter", U = "mouse", (o === "pointerout" || o === "pointerover") && (we = Ub, ue = "onPointerLeave", z = "onPointerEnter", U = "pointer"), at = me == null ? ie : No(me), K = ye == null ? ie : No(ye), ie = new we(ue, U + "leave", me, c, oe), ie.target = at, ie.relatedTarget = K, ue = null, ki(oe) === X && (we = new we(z, U + "enter", ye, c, oe), we.target = K, we.relatedTarget = at, ue = we), at = ue, me && ye) t: {
              for (we = me, z = ye, U = 0, K = we; K; K = Oo(K)) U++;
              for (K = 0, ue = z; ue; ue = Oo(ue)) K++;
              for (; 0 < U - K; ) we = Oo(we), U--;
              for (; 0 < K - U; ) z = Oo(z), K--;
              for (; U--; ) {
                if (we === z || z !== null && we === z.alternate) break t;
                we = Oo(we), z = Oo(z);
              }
              we = null;
            }
            else we = null;
            me !== null && m1(ae, ie, me, we, !1), ye !== null && at !== null && m1(ae, at, ye, we, !0);
          }
        }
        e: {
          if (ie = X ? No(X) : window, me = ie.nodeName && ie.nodeName.toLowerCase(), me === "select" || me === "input" && ie.type === "file") var be = XP;
          else if (Yb(ie)) if (Xb) be = eM;
          else {
            be = QP;
            var Ee = ZP;
          }
          else (me = ie.nodeName) && me.toLowerCase() === "input" && (ie.type === "checkbox" || ie.type === "radio") && (be = JP);
          if (be && (be = be(o, X))) {
            qb(ae, be, c, oe);
            break e;
          }
          Ee && Ee(o, ie, X), o === "focusout" && (Ee = ie._wrapperState) && Ee.controlled && ie.type === "number" && Ye(ie, "number", ie.value);
        }
        switch (Ee = X ? No(X) : window, o) {
          case "focusin":
            (Yb(Ee) || Ee.contentEditable === "true") && (Po = Ee, bh = X, za = null);
            break;
          case "focusout":
            za = bh = Po = null;
            break;
          case "mousedown":
            Ch = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            Ch = !1, i1(ae, c, oe);
            break;
          case "selectionchange":
            if (rM) break;
          case "keydown":
          case "keyup":
            i1(ae, c, oe);
        }
        var Ae;
        if (gh) e: {
          switch (o) {
            case "compositionstart":
              var ke = "onCompositionStart";
              break e;
            case "compositionend":
              ke = "onCompositionEnd";
              break e;
            case "compositionupdate":
              ke = "onCompositionUpdate";
              break e;
          }
          ke = void 0;
        }
        else Lo ? Kb(o, c) && (ke = "onCompositionEnd") : o === "keydown" && c.keyCode === 229 && (ke = "onCompositionStart");
        ke && (Wb && c.locale !== "ko" && (Lo || ke !== "onCompositionStart" ? ke === "onCompositionEnd" && Lo && (Ae = Nb()) : (Gr = oe, ch = "value" in Gr ? Gr.value : Gr.textContent, Lo = !0)), Ee = Yu(X, ke), 0 < Ee.length && (ke = new Fb(ke, o, null, c, oe), ae.push({ event: ke, listeners: Ee }), Ae ? ke.data = Ae : (Ae = Gb(c), Ae !== null && (ke.data = Ae)))), (Ae = HP ? KP(o, c) : GP(o, c)) && (X = Yu(X, "onBeforeInput"), 0 < X.length && (oe = new Fb("onBeforeInput", "beforeinput", null, c, oe), ae.push({ event: oe, listeners: X }), oe.data = Ae));
      }
      h1(ae, a);
    });
  }
  function Ga(o, a, c) {
    return { instance: o, listener: a, currentTarget: c };
  }
  function Yu(o, a) {
    for (var c = a + "Capture", p = []; o !== null; ) {
      var v = o, y = v.stateNode;
      v.tag === 5 && y !== null && (v = y, y = Ta(o, c), y != null && p.unshift(Ga(o, y, v)), y = Ta(o, a), y != null && p.push(Ga(o, y, v))), o = o.return;
    }
    return p;
  }
  function Oo(o) {
    if (o === null) return null;
    do
      o = o.return;
    while (o && o.tag !== 5);
    return o || null;
  }
  function m1(o, a, c, p, v) {
    for (var y = a._reactName, k = []; c !== null && c !== p; ) {
      var N = c, F = N.alternate, X = N.stateNode;
      if (F !== null && F === p) break;
      N.tag === 5 && X !== null && (N = X, v ? (F = Ta(c, y), F != null && k.unshift(Ga(c, F, N))) : v || (F = Ta(c, y), F != null && k.push(Ga(c, F, N)))), c = c.return;
    }
    k.length !== 0 && o.push({ event: a, listeners: k });
  }
  var aM = /\r\n?/g, lM = /\u0000|\uFFFD/g;
  function g1(o) {
    return (typeof o == "string" ? o : "" + o).replace(aM, `
`).replace(lM, "");
  }
  function qu(o, a, c) {
    if (a = g1(a), g1(o) !== a && c) throw Error(n(425));
  }
  function Xu() {
  }
  var Rh = null, Th = null;
  function $h(o, a) {
    return o === "textarea" || o === "noscript" || typeof a.children == "string" || typeof a.children == "number" || typeof a.dangerouslySetInnerHTML == "object" && a.dangerouslySetInnerHTML !== null && a.dangerouslySetInnerHTML.__html != null;
  }
  var Vh = typeof setTimeout == "function" ? setTimeout : void 0, uM = typeof clearTimeout == "function" ? clearTimeout : void 0, v1 = typeof Promise == "function" ? Promise : void 0, cM = typeof queueMicrotask == "function" ? queueMicrotask : typeof v1 < "u" ? function(o) {
    return v1.resolve(null).then(o).catch(dM);
  } : Vh;
  function dM(o) {
    setTimeout(function() {
      throw o;
    });
  }
  function _h(o, a) {
    var c = a, p = 0;
    do {
      var v = c.nextSibling;
      if (o.removeChild(c), v && v.nodeType === 8) if (c = v.data, c === "/$") {
        if (p === 0) {
          o.removeChild(v), Ba(a);
          return;
        }
        p--;
      } else c !== "$" && c !== "$?" && c !== "$!" || p++;
      c = v;
    } while (c);
    Ba(a);
  }
  function qr(o) {
    for (; o != null; o = o.nextSibling) {
      var a = o.nodeType;
      if (a === 1 || a === 3) break;
      if (a === 8) {
        if (a = o.data, a === "$" || a === "$!" || a === "$?") break;
        if (a === "/$") return null;
      }
    }
    return o;
  }
  function y1(o) {
    o = o.previousSibling;
    for (var a = 0; o; ) {
      if (o.nodeType === 8) {
        var c = o.data;
        if (c === "$" || c === "$!" || c === "$?") {
          if (a === 0) return o;
          a--;
        } else c === "/$" && a++;
      }
      o = o.previousSibling;
    }
    return null;
  }
  var Bo = Math.random().toString(36).slice(2), Jn = "__reactFiber$" + Bo, Ya = "__reactProps$" + Bo, gr = "__reactContainer$" + Bo, Ih = "__reactEvents$" + Bo, fM = "__reactListeners$" + Bo, hM = "__reactHandles$" + Bo;
  function ki(o) {
    var a = o[Jn];
    if (a) return a;
    for (var c = o.parentNode; c; ) {
      if (a = c[gr] || c[Jn]) {
        if (c = a.alternate, a.child !== null || c !== null && c.child !== null) for (o = y1(o); o !== null; ) {
          if (c = o[Jn]) return c;
          o = y1(o);
        }
        return a;
      }
      o = c, c = o.parentNode;
    }
    return null;
  }
  function qa(o) {
    return o = o[Jn] || o[gr], !o || o.tag !== 5 && o.tag !== 6 && o.tag !== 13 && o.tag !== 3 ? null : o;
  }
  function No(o) {
    if (o.tag === 5 || o.tag === 6) return o.stateNode;
    throw Error(n(33));
  }
  function Zu(o) {
    return o[Ya] || null;
  }
  var Lh = [], Do = -1;
  function Xr(o) {
    return { current: o };
  }
  function Xe(o) {
    0 > Do || (o.current = Lh[Do], Lh[Do] = null, Do--);
  }
  function Ge(o, a) {
    Do++, Lh[Do] = o.current, o.current = a;
  }
  var Zr = {}, $t = Xr(Zr), zt = Xr(!1), Ri = Zr;
  function jo(o, a) {
    var c = o.type.contextTypes;
    if (!c) return Zr;
    var p = o.stateNode;
    if (p && p.__reactInternalMemoizedUnmaskedChildContext === a) return p.__reactInternalMemoizedMaskedChildContext;
    var v = {}, y;
    for (y in c) v[y] = a[y];
    return p && (o = o.stateNode, o.__reactInternalMemoizedUnmaskedChildContext = a, o.__reactInternalMemoizedMaskedChildContext = v), v;
  }
  function Ht(o) {
    return o = o.childContextTypes, o != null;
  }
  function Qu() {
    Xe(zt), Xe($t);
  }
  function w1(o, a, c) {
    if ($t.current !== Zr) throw Error(n(168));
    Ge($t, a), Ge(zt, c);
  }
  function b1(o, a, c) {
    var p = o.stateNode;
    if (a = a.childContextTypes, typeof p.getChildContext != "function") return c;
    p = p.getChildContext();
    for (var v in p) if (!(v in a)) throw Error(n(108, q(o) || "Unknown", v));
    return P({}, c, p);
  }
  function Ju(o) {
    return o = (o = o.stateNode) && o.__reactInternalMemoizedMergedChildContext || Zr, Ri = $t.current, Ge($t, o), Ge(zt, zt.current), !0;
  }
  function C1(o, a, c) {
    var p = o.stateNode;
    if (!p) throw Error(n(169));
    c ? (o = b1(o, a, Ri), p.__reactInternalMemoizedMergedChildContext = o, Xe(zt), Xe($t), Ge($t, o)) : Xe(zt), Ge(zt, c);
  }
  var vr = null, ec = !1, Ph = !1;
  function E1(o) {
    vr === null ? vr = [o] : vr.push(o);
  }
  function pM(o) {
    ec = !0, E1(o);
  }
  function Qr() {
    if (!Ph && vr !== null) {
      Ph = !0;
      var o = 0, a = Ke;
      try {
        var c = vr;
        for (Ke = 1; o < c.length; o++) {
          var p = c[o];
          do
            p = p(!0);
          while (p !== null);
        }
        vr = null, ec = !1;
      } catch (v) {
        throw vr !== null && (vr = vr.slice(o + 1)), xb(nh, Qr), v;
      } finally {
        Ke = a, Ph = !1;
      }
    }
    return null;
  }
  var Fo = [], Uo = 0, tc = null, nc = 0, gn = [], vn = 0, Ti = null, yr = 1, wr = "";
  function $i(o, a) {
    Fo[Uo++] = nc, Fo[Uo++] = tc, tc = o, nc = a;
  }
  function A1(o, a, c) {
    gn[vn++] = yr, gn[vn++] = wr, gn[vn++] = Ti, Ti = o;
    var p = yr;
    o = wr;
    var v = 32 - Ln(p) - 1;
    p &= ~(1 << v), c += 1;
    var y = 32 - Ln(a) + v;
    if (30 < y) {
      var k = v - v % 5;
      y = (p & (1 << k) - 1).toString(32), p >>= k, v -= k, yr = 1 << 32 - Ln(a) + v | c << v | p, wr = y + o;
    } else yr = 1 << y | c << v | p, wr = o;
  }
  function Mh(o) {
    o.return !== null && ($i(o, 1), A1(o, 1, 0));
  }
  function Oh(o) {
    for (; o === tc; ) tc = Fo[--Uo], Fo[Uo] = null, nc = Fo[--Uo], Fo[Uo] = null;
    for (; o === Ti; ) Ti = gn[--vn], gn[vn] = null, wr = gn[--vn], gn[vn] = null, yr = gn[--vn], gn[vn] = null;
  }
  var on = null, sn = null, Qe = !1, Mn = null;
  function x1(o, a) {
    var c = Cn(5, null, null, 0);
    c.elementType = "DELETED", c.stateNode = a, c.return = o, a = o.deletions, a === null ? (o.deletions = [c], o.flags |= 16) : a.push(c);
  }
  function S1(o, a) {
    switch (o.tag) {
      case 5:
        var c = o.type;
        return a = a.nodeType !== 1 || c.toLowerCase() !== a.nodeName.toLowerCase() ? null : a, a !== null ? (o.stateNode = a, on = o, sn = qr(a.firstChild), !0) : !1;
      case 6:
        return a = o.pendingProps === "" || a.nodeType !== 3 ? null : a, a !== null ? (o.stateNode = a, on = o, sn = null, !0) : !1;
      case 13:
        return a = a.nodeType !== 8 ? null : a, a !== null ? (c = Ti !== null ? { id: yr, overflow: wr } : null, o.memoizedState = { dehydrated: a, treeContext: c, retryLane: 1073741824 }, c = Cn(18, null, null, 0), c.stateNode = a, c.return = o, o.child = c, on = o, sn = null, !0) : !1;
      default:
        return !1;
    }
  }
  function Bh(o) {
    return (o.mode & 1) !== 0 && (o.flags & 128) === 0;
  }
  function Nh(o) {
    if (Qe) {
      var a = sn;
      if (a) {
        var c = a;
        if (!S1(o, a)) {
          if (Bh(o)) throw Error(n(418));
          a = qr(c.nextSibling);
          var p = on;
          a && S1(o, a) ? x1(p, c) : (o.flags = o.flags & -4097 | 2, Qe = !1, on = o);
        }
      } else {
        if (Bh(o)) throw Error(n(418));
        o.flags = o.flags & -4097 | 2, Qe = !1, on = o;
      }
    }
  }
  function k1(o) {
    for (o = o.return; o !== null && o.tag !== 5 && o.tag !== 3 && o.tag !== 13; ) o = o.return;
    on = o;
  }
  function rc(o) {
    if (o !== on) return !1;
    if (!Qe) return k1(o), Qe = !0, !1;
    var a;
    if ((a = o.tag !== 3) && !(a = o.tag !== 5) && (a = o.type, a = a !== "head" && a !== "body" && !$h(o.type, o.memoizedProps)), a && (a = sn)) {
      if (Bh(o)) throw R1(), Error(n(418));
      for (; a; ) x1(o, a), a = qr(a.nextSibling);
    }
    if (k1(o), o.tag === 13) {
      if (o = o.memoizedState, o = o !== null ? o.dehydrated : null, !o) throw Error(n(317));
      e: {
        for (o = o.nextSibling, a = 0; o; ) {
          if (o.nodeType === 8) {
            var c = o.data;
            if (c === "/$") {
              if (a === 0) {
                sn = qr(o.nextSibling);
                break e;
              }
              a--;
            } else c !== "$" && c !== "$!" && c !== "$?" || a++;
          }
          o = o.nextSibling;
        }
        sn = null;
      }
    } else sn = on ? qr(o.stateNode.nextSibling) : null;
    return !0;
  }
  function R1() {
    for (var o = sn; o; ) o = qr(o.nextSibling);
  }
  function Wo() {
    sn = on = null, Qe = !1;
  }
  function Dh(o) {
    Mn === null ? Mn = [o] : Mn.push(o);
  }
  var mM = L.ReactCurrentBatchConfig;
  function Xa(o, a, c) {
    if (o = c.ref, o !== null && typeof o != "function" && typeof o != "object") {
      if (c._owner) {
        if (c = c._owner, c) {
          if (c.tag !== 1) throw Error(n(309));
          var p = c.stateNode;
        }
        if (!p) throw Error(n(147, o));
        var v = p, y = "" + o;
        return a !== null && a.ref !== null && typeof a.ref == "function" && a.ref._stringRef === y ? a.ref : (a = function(k) {
          var N = v.refs;
          k === null ? delete N[y] : N[y] = k;
        }, a._stringRef = y, a);
      }
      if (typeof o != "string") throw Error(n(284));
      if (!c._owner) throw Error(n(290, o));
    }
    return o;
  }
  function ic(o, a) {
    throw o = Object.prototype.toString.call(a), Error(n(31, o === "[object Object]" ? "object with keys {" + Object.keys(a).join(", ") + "}" : o));
  }
  function T1(o) {
    var a = o._init;
    return a(o._payload);
  }
  function $1(o) {
    function a(z, U) {
      if (o) {
        var K = z.deletions;
        K === null ? (z.deletions = [U], z.flags |= 16) : K.push(U);
      }
    }
    function c(z, U) {
      if (!o) return null;
      for (; U !== null; ) a(z, U), U = U.sibling;
      return null;
    }
    function p(z, U) {
      for (z = /* @__PURE__ */ new Map(); U !== null; ) U.key !== null ? z.set(U.key, U) : z.set(U.index, U), U = U.sibling;
      return z;
    }
    function v(z, U) {
      return z = si(z, U), z.index = 0, z.sibling = null, z;
    }
    function y(z, U, K) {
      return z.index = K, o ? (K = z.alternate, K !== null ? (K = K.index, K < U ? (z.flags |= 2, U) : K) : (z.flags |= 2, U)) : (z.flags |= 1048576, U);
    }
    function k(z) {
      return o && z.alternate === null && (z.flags |= 2), z;
    }
    function N(z, U, K, ue) {
      return U === null || U.tag !== 6 ? (U = Vp(K, z.mode, ue), U.return = z, U) : (U = v(U, K), U.return = z, U);
    }
    function F(z, U, K, ue) {
      var be = K.type;
      return be === D ? oe(z, U, K.props.children, ue, K.key) : U !== null && (U.elementType === be || typeof be == "object" && be !== null && be.$$typeof === Y && T1(be) === U.type) ? (ue = v(U, K.props), ue.ref = Xa(z, U, K), ue.return = z, ue) : (ue = Tc(K.type, K.key, K.props, null, z.mode, ue), ue.ref = Xa(z, U, K), ue.return = z, ue);
    }
    function X(z, U, K, ue) {
      return U === null || U.tag !== 4 || U.stateNode.containerInfo !== K.containerInfo || U.stateNode.implementation !== K.implementation ? (U = _p(K, z.mode, ue), U.return = z, U) : (U = v(U, K.children || []), U.return = z, U);
    }
    function oe(z, U, K, ue, be) {
      return U === null || U.tag !== 7 ? (U = Bi(K, z.mode, ue, be), U.return = z, U) : (U = v(U, K), U.return = z, U);
    }
    function ae(z, U, K) {
      if (typeof U == "string" && U !== "" || typeof U == "number") return U = Vp("" + U, z.mode, K), U.return = z, U;
      if (typeof U == "object" && U !== null) {
        switch (U.$$typeof) {
          case V:
            return K = Tc(U.type, U.key, U.props, null, z.mode, K), K.ref = Xa(z, null, U), K.return = z, K;
          case O:
            return U = _p(U, z.mode, K), U.return = z, U;
          case Y:
            var ue = U._init;
            return ae(z, ue(U._payload), K);
        }
        if (nn(U) || T(U)) return U = Bi(U, z.mode, K, null), U.return = z, U;
        ic(z, U);
      }
      return null;
    }
    function ie(z, U, K, ue) {
      var be = U !== null ? U.key : null;
      if (typeof K == "string" && K !== "" || typeof K == "number") return be !== null ? null : N(z, U, "" + K, ue);
      if (typeof K == "object" && K !== null) {
        switch (K.$$typeof) {
          case V:
            return K.key === be ? F(z, U, K, ue) : null;
          case O:
            return K.key === be ? X(z, U, K, ue) : null;
          case Y:
            return be = K._init, ie(
              z,
              U,
              be(K._payload),
              ue
            );
        }
        if (nn(K) || T(K)) return be !== null ? null : oe(z, U, K, ue, null);
        ic(z, K);
      }
      return null;
    }
    function me(z, U, K, ue, be) {
      if (typeof ue == "string" && ue !== "" || typeof ue == "number") return z = z.get(K) || null, N(U, z, "" + ue, be);
      if (typeof ue == "object" && ue !== null) {
        switch (ue.$$typeof) {
          case V:
            return z = z.get(ue.key === null ? K : ue.key) || null, F(U, z, ue, be);
          case O:
            return z = z.get(ue.key === null ? K : ue.key) || null, X(U, z, ue, be);
          case Y:
            var Ee = ue._init;
            return me(z, U, K, Ee(ue._payload), be);
        }
        if (nn(ue) || T(ue)) return z = z.get(K) || null, oe(U, z, ue, be, null);
        ic(U, ue);
      }
      return null;
    }
    function ye(z, U, K, ue) {
      for (var be = null, Ee = null, Ae = U, ke = U = 0, Et = null; Ae !== null && ke < K.length; ke++) {
        Ae.index > ke ? (Et = Ae, Ae = null) : Et = Ae.sibling;
        var We = ie(z, Ae, K[ke], ue);
        if (We === null) {
          Ae === null && (Ae = Et);
          break;
        }
        o && Ae && We.alternate === null && a(z, Ae), U = y(We, U, ke), Ee === null ? be = We : Ee.sibling = We, Ee = We, Ae = Et;
      }
      if (ke === K.length) return c(z, Ae), Qe && $i(z, ke), be;
      if (Ae === null) {
        for (; ke < K.length; ke++) Ae = ae(z, K[ke], ue), Ae !== null && (U = y(Ae, U, ke), Ee === null ? be = Ae : Ee.sibling = Ae, Ee = Ae);
        return Qe && $i(z, ke), be;
      }
      for (Ae = p(z, Ae); ke < K.length; ke++) Et = me(Ae, z, ke, K[ke], ue), Et !== null && (o && Et.alternate !== null && Ae.delete(Et.key === null ? ke : Et.key), U = y(Et, U, ke), Ee === null ? be = Et : Ee.sibling = Et, Ee = Et);
      return o && Ae.forEach(function(ai) {
        return a(z, ai);
      }), Qe && $i(z, ke), be;
    }
    function we(z, U, K, ue) {
      var be = T(K);
      if (typeof be != "function") throw Error(n(150));
      if (K = be.call(K), K == null) throw Error(n(151));
      for (var Ee = be = null, Ae = U, ke = U = 0, Et = null, We = K.next(); Ae !== null && !We.done; ke++, We = K.next()) {
        Ae.index > ke ? (Et = Ae, Ae = null) : Et = Ae.sibling;
        var ai = ie(z, Ae, We.value, ue);
        if (ai === null) {
          Ae === null && (Ae = Et);
          break;
        }
        o && Ae && ai.alternate === null && a(z, Ae), U = y(ai, U, ke), Ee === null ? be = ai : Ee.sibling = ai, Ee = ai, Ae = Et;
      }
      if (We.done) return c(
        z,
        Ae
      ), Qe && $i(z, ke), be;
      if (Ae === null) {
        for (; !We.done; ke++, We = K.next()) We = ae(z, We.value, ue), We !== null && (U = y(We, U, ke), Ee === null ? be = We : Ee.sibling = We, Ee = We);
        return Qe && $i(z, ke), be;
      }
      for (Ae = p(z, Ae); !We.done; ke++, We = K.next()) We = me(Ae, z, ke, We.value, ue), We !== null && (o && We.alternate !== null && Ae.delete(We.key === null ? ke : We.key), U = y(We, U, ke), Ee === null ? be = We : Ee.sibling = We, Ee = We);
      return o && Ae.forEach(function(YM) {
        return a(z, YM);
      }), Qe && $i(z, ke), be;
    }
    function at(z, U, K, ue) {
      if (typeof K == "object" && K !== null && K.type === D && K.key === null && (K = K.props.children), typeof K == "object" && K !== null) {
        switch (K.$$typeof) {
          case V:
            e: {
              for (var be = K.key, Ee = U; Ee !== null; ) {
                if (Ee.key === be) {
                  if (be = K.type, be === D) {
                    if (Ee.tag === 7) {
                      c(z, Ee.sibling), U = v(Ee, K.props.children), U.return = z, z = U;
                      break e;
                    }
                  } else if (Ee.elementType === be || typeof be == "object" && be !== null && be.$$typeof === Y && T1(be) === Ee.type) {
                    c(z, Ee.sibling), U = v(Ee, K.props), U.ref = Xa(z, Ee, K), U.return = z, z = U;
                    break e;
                  }
                  c(z, Ee);
                  break;
                } else a(z, Ee);
                Ee = Ee.sibling;
              }
              K.type === D ? (U = Bi(K.props.children, z.mode, ue, K.key), U.return = z, z = U) : (ue = Tc(K.type, K.key, K.props, null, z.mode, ue), ue.ref = Xa(z, U, K), ue.return = z, z = ue);
            }
            return k(z);
          case O:
            e: {
              for (Ee = K.key; U !== null; ) {
                if (U.key === Ee) if (U.tag === 4 && U.stateNode.containerInfo === K.containerInfo && U.stateNode.implementation === K.implementation) {
                  c(z, U.sibling), U = v(U, K.children || []), U.return = z, z = U;
                  break e;
                } else {
                  c(z, U);
                  break;
                }
                else a(z, U);
                U = U.sibling;
              }
              U = _p(K, z.mode, ue), U.return = z, z = U;
            }
            return k(z);
          case Y:
            return Ee = K._init, at(z, U, Ee(K._payload), ue);
        }
        if (nn(K)) return ye(z, U, K, ue);
        if (T(K)) return we(z, U, K, ue);
        ic(z, K);
      }
      return typeof K == "string" && K !== "" || typeof K == "number" ? (K = "" + K, U !== null && U.tag === 6 ? (c(z, U.sibling), U = v(U, K), U.return = z, z = U) : (c(z, U), U = Vp(K, z.mode, ue), U.return = z, z = U), k(z)) : c(z, U);
    }
    return at;
  }
  var zo = $1(!0), V1 = $1(!1), oc = Xr(null), sc = null, Ho = null, jh = null;
  function Fh() {
    jh = Ho = sc = null;
  }
  function Uh(o) {
    var a = oc.current;
    Xe(oc), o._currentValue = a;
  }
  function Wh(o, a, c) {
    for (; o !== null; ) {
      var p = o.alternate;
      if ((o.childLanes & a) !== a ? (o.childLanes |= a, p !== null && (p.childLanes |= a)) : p !== null && (p.childLanes & a) !== a && (p.childLanes |= a), o === c) break;
      o = o.return;
    }
  }
  function Ko(o, a) {
    sc = o, jh = Ho = null, o = o.dependencies, o !== null && o.firstContext !== null && ((o.lanes & a) !== 0 && (Kt = !0), o.firstContext = null);
  }
  function yn(o) {
    var a = o._currentValue;
    if (jh !== o) if (o = { context: o, memoizedValue: a, next: null }, Ho === null) {
      if (sc === null) throw Error(n(308));
      Ho = o, sc.dependencies = { lanes: 0, firstContext: o };
    } else Ho = Ho.next = o;
    return a;
  }
  var Vi = null;
  function zh(o) {
    Vi === null ? Vi = [o] : Vi.push(o);
  }
  function _1(o, a, c, p) {
    var v = a.interleaved;
    return v === null ? (c.next = c, zh(a)) : (c.next = v.next, v.next = c), a.interleaved = c, br(o, p);
  }
  function br(o, a) {
    o.lanes |= a;
    var c = o.alternate;
    for (c !== null && (c.lanes |= a), c = o, o = o.return; o !== null; ) o.childLanes |= a, c = o.alternate, c !== null && (c.childLanes |= a), c = o, o = o.return;
    return c.tag === 3 ? c.stateNode : null;
  }
  var Jr = !1;
  function Hh(o) {
    o.updateQueue = { baseState: o.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
  }
  function I1(o, a) {
    o = o.updateQueue, a.updateQueue === o && (a.updateQueue = { baseState: o.baseState, firstBaseUpdate: o.firstBaseUpdate, lastBaseUpdate: o.lastBaseUpdate, shared: o.shared, effects: o.effects });
  }
  function Cr(o, a) {
    return { eventTime: o, lane: a, tag: 0, payload: null, callback: null, next: null };
  }
  function ei(o, a, c) {
    var p = o.updateQueue;
    if (p === null) return null;
    if (p = p.shared, (Ue & 2) !== 0) {
      var v = p.pending;
      return v === null ? a.next = a : (a.next = v.next, v.next = a), p.pending = a, br(o, c);
    }
    return v = p.interleaved, v === null ? (a.next = a, zh(p)) : (a.next = v.next, v.next = a), p.interleaved = a, br(o, c);
  }
  function ac(o, a, c) {
    if (a = a.updateQueue, a !== null && (a = a.shared, (c & 4194240) !== 0)) {
      var p = a.lanes;
      p &= o.pendingLanes, c |= p, a.lanes = c, oh(o, c);
    }
  }
  function L1(o, a) {
    var c = o.updateQueue, p = o.alternate;
    if (p !== null && (p = p.updateQueue, c === p)) {
      var v = null, y = null;
      if (c = c.firstBaseUpdate, c !== null) {
        do {
          var k = { eventTime: c.eventTime, lane: c.lane, tag: c.tag, payload: c.payload, callback: c.callback, next: null };
          y === null ? v = y = k : y = y.next = k, c = c.next;
        } while (c !== null);
        y === null ? v = y = a : y = y.next = a;
      } else v = y = a;
      c = { baseState: p.baseState, firstBaseUpdate: v, lastBaseUpdate: y, shared: p.shared, effects: p.effects }, o.updateQueue = c;
      return;
    }
    o = c.lastBaseUpdate, o === null ? c.firstBaseUpdate = a : o.next = a, c.lastBaseUpdate = a;
  }
  function lc(o, a, c, p) {
    var v = o.updateQueue;
    Jr = !1;
    var y = v.firstBaseUpdate, k = v.lastBaseUpdate, N = v.shared.pending;
    if (N !== null) {
      v.shared.pending = null;
      var F = N, X = F.next;
      F.next = null, k === null ? y = X : k.next = X, k = F;
      var oe = o.alternate;
      oe !== null && (oe = oe.updateQueue, N = oe.lastBaseUpdate, N !== k && (N === null ? oe.firstBaseUpdate = X : N.next = X, oe.lastBaseUpdate = F));
    }
    if (y !== null) {
      var ae = v.baseState;
      k = 0, oe = X = F = null, N = y;
      do {
        var ie = N.lane, me = N.eventTime;
        if ((p & ie) === ie) {
          oe !== null && (oe = oe.next = {
            eventTime: me,
            lane: 0,
            tag: N.tag,
            payload: N.payload,
            callback: N.callback,
            next: null
          });
          e: {
            var ye = o, we = N;
            switch (ie = a, me = c, we.tag) {
              case 1:
                if (ye = we.payload, typeof ye == "function") {
                  ae = ye.call(me, ae, ie);
                  break e;
                }
                ae = ye;
                break e;
              case 3:
                ye.flags = ye.flags & -65537 | 128;
              case 0:
                if (ye = we.payload, ie = typeof ye == "function" ? ye.call(me, ae, ie) : ye, ie == null) break e;
                ae = P({}, ae, ie);
                break e;
              case 2:
                Jr = !0;
            }
          }
          N.callback !== null && N.lane !== 0 && (o.flags |= 64, ie = v.effects, ie === null ? v.effects = [N] : ie.push(N));
        } else me = { eventTime: me, lane: ie, tag: N.tag, payload: N.payload, callback: N.callback, next: null }, oe === null ? (X = oe = me, F = ae) : oe = oe.next = me, k |= ie;
        if (N = N.next, N === null) {
          if (N = v.shared.pending, N === null) break;
          ie = N, N = ie.next, ie.next = null, v.lastBaseUpdate = ie, v.shared.pending = null;
        }
      } while (!0);
      if (oe === null && (F = ae), v.baseState = F, v.firstBaseUpdate = X, v.lastBaseUpdate = oe, a = v.shared.interleaved, a !== null) {
        v = a;
        do
          k |= v.lane, v = v.next;
        while (v !== a);
      } else y === null && (v.shared.lanes = 0);
      Li |= k, o.lanes = k, o.memoizedState = ae;
    }
  }
  function P1(o, a, c) {
    if (o = a.effects, a.effects = null, o !== null) for (a = 0; a < o.length; a++) {
      var p = o[a], v = p.callback;
      if (v !== null) {
        if (p.callback = null, p = c, typeof v != "function") throw Error(n(191, v));
        v.call(p);
      }
    }
  }
  var Za = {}, er = Xr(Za), Qa = Xr(Za), Ja = Xr(Za);
  function _i(o) {
    if (o === Za) throw Error(n(174));
    return o;
  }
  function Kh(o, a) {
    switch (Ge(Ja, a), Ge(Qa, o), Ge(er, Za), o = a.nodeType, o) {
      case 9:
      case 11:
        a = (a = a.documentElement) ? a.namespaceURI : To(null, "");
        break;
      default:
        o = o === 8 ? a.parentNode : a, a = o.namespaceURI || null, o = o.tagName, a = To(a, o);
    }
    Xe(er), Ge(er, a);
  }
  function Go() {
    Xe(er), Xe(Qa), Xe(Ja);
  }
  function M1(o) {
    _i(Ja.current);
    var a = _i(er.current), c = To(a, o.type);
    a !== c && (Ge(Qa, o), Ge(er, c));
  }
  function Gh(o) {
    Qa.current === o && (Xe(er), Xe(Qa));
  }
  var Je = Xr(0);
  function uc(o) {
    for (var a = o; a !== null; ) {
      if (a.tag === 13) {
        var c = a.memoizedState;
        if (c !== null && (c = c.dehydrated, c === null || c.data === "$?" || c.data === "$!")) return a;
      } else if (a.tag === 19 && a.memoizedProps.revealOrder !== void 0) {
        if ((a.flags & 128) !== 0) return a;
      } else if (a.child !== null) {
        a.child.return = a, a = a.child;
        continue;
      }
      if (a === o) break;
      for (; a.sibling === null; ) {
        if (a.return === null || a.return === o) return null;
        a = a.return;
      }
      a.sibling.return = a.return, a = a.sibling;
    }
    return null;
  }
  var Yh = [];
  function qh() {
    for (var o = 0; o < Yh.length; o++) Yh[o]._workInProgressVersionPrimary = null;
    Yh.length = 0;
  }
  var cc = L.ReactCurrentDispatcher, Xh = L.ReactCurrentBatchConfig, Ii = 0, et = null, mt = null, bt = null, dc = !1, el = !1, tl = 0, gM = 0;
  function Vt() {
    throw Error(n(321));
  }
  function Zh(o, a) {
    if (a === null) return !1;
    for (var c = 0; c < a.length && c < o.length; c++) if (!Pn(o[c], a[c])) return !1;
    return !0;
  }
  function Qh(o, a, c, p, v, y) {
    if (Ii = y, et = a, a.memoizedState = null, a.updateQueue = null, a.lanes = 0, cc.current = o === null || o.memoizedState === null ? bM : CM, o = c(p, v), el) {
      y = 0;
      do {
        if (el = !1, tl = 0, 25 <= y) throw Error(n(301));
        y += 1, bt = mt = null, a.updateQueue = null, cc.current = EM, o = c(p, v);
      } while (el);
    }
    if (cc.current = pc, a = mt !== null && mt.next !== null, Ii = 0, bt = mt = et = null, dc = !1, a) throw Error(n(300));
    return o;
  }
  function Jh() {
    var o = tl !== 0;
    return tl = 0, o;
  }
  function tr() {
    var o = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    return bt === null ? et.memoizedState = bt = o : bt = bt.next = o, bt;
  }
  function wn() {
    if (mt === null) {
      var o = et.alternate;
      o = o !== null ? o.memoizedState : null;
    } else o = mt.next;
    var a = bt === null ? et.memoizedState : bt.next;
    if (a !== null) bt = a, mt = o;
    else {
      if (o === null) throw Error(n(310));
      mt = o, o = { memoizedState: mt.memoizedState, baseState: mt.baseState, baseQueue: mt.baseQueue, queue: mt.queue, next: null }, bt === null ? et.memoizedState = bt = o : bt = bt.next = o;
    }
    return bt;
  }
  function nl(o, a) {
    return typeof a == "function" ? a(o) : a;
  }
  function ep(o) {
    var a = wn(), c = a.queue;
    if (c === null) throw Error(n(311));
    c.lastRenderedReducer = o;
    var p = mt, v = p.baseQueue, y = c.pending;
    if (y !== null) {
      if (v !== null) {
        var k = v.next;
        v.next = y.next, y.next = k;
      }
      p.baseQueue = v = y, c.pending = null;
    }
    if (v !== null) {
      y = v.next, p = p.baseState;
      var N = k = null, F = null, X = y;
      do {
        var oe = X.lane;
        if ((Ii & oe) === oe) F !== null && (F = F.next = { lane: 0, action: X.action, hasEagerState: X.hasEagerState, eagerState: X.eagerState, next: null }), p = X.hasEagerState ? X.eagerState : o(p, X.action);
        else {
          var ae = {
            lane: oe,
            action: X.action,
            hasEagerState: X.hasEagerState,
            eagerState: X.eagerState,
            next: null
          };
          F === null ? (N = F = ae, k = p) : F = F.next = ae, et.lanes |= oe, Li |= oe;
        }
        X = X.next;
      } while (X !== null && X !== y);
      F === null ? k = p : F.next = N, Pn(p, a.memoizedState) || (Kt = !0), a.memoizedState = p, a.baseState = k, a.baseQueue = F, c.lastRenderedState = p;
    }
    if (o = c.interleaved, o !== null) {
      v = o;
      do
        y = v.lane, et.lanes |= y, Li |= y, v = v.next;
      while (v !== o);
    } else v === null && (c.lanes = 0);
    return [a.memoizedState, c.dispatch];
  }
  function tp(o) {
    var a = wn(), c = a.queue;
    if (c === null) throw Error(n(311));
    c.lastRenderedReducer = o;
    var p = c.dispatch, v = c.pending, y = a.memoizedState;
    if (v !== null) {
      c.pending = null;
      var k = v = v.next;
      do
        y = o(y, k.action), k = k.next;
      while (k !== v);
      Pn(y, a.memoizedState) || (Kt = !0), a.memoizedState = y, a.baseQueue === null && (a.baseState = y), c.lastRenderedState = y;
    }
    return [y, p];
  }
  function O1() {
  }
  function B1(o, a) {
    var c = et, p = wn(), v = a(), y = !Pn(p.memoizedState, v);
    if (y && (p.memoizedState = v, Kt = !0), p = p.queue, np(j1.bind(null, c, p, o), [o]), p.getSnapshot !== a || y || bt !== null && bt.memoizedState.tag & 1) {
      if (c.flags |= 2048, rl(9, D1.bind(null, c, p, v, a), void 0, null), Ct === null) throw Error(n(349));
      (Ii & 30) !== 0 || N1(c, a, v);
    }
    return v;
  }
  function N1(o, a, c) {
    o.flags |= 16384, o = { getSnapshot: a, value: c }, a = et.updateQueue, a === null ? (a = { lastEffect: null, stores: null }, et.updateQueue = a, a.stores = [o]) : (c = a.stores, c === null ? a.stores = [o] : c.push(o));
  }
  function D1(o, a, c, p) {
    a.value = c, a.getSnapshot = p, F1(a) && U1(o);
  }
  function j1(o, a, c) {
    return c(function() {
      F1(a) && U1(o);
    });
  }
  function F1(o) {
    var a = o.getSnapshot;
    o = o.value;
    try {
      var c = a();
      return !Pn(o, c);
    } catch {
      return !0;
    }
  }
  function U1(o) {
    var a = br(o, 1);
    a !== null && Dn(a, o, 1, -1);
  }
  function W1(o) {
    var a = tr();
    return typeof o == "function" && (o = o()), a.memoizedState = a.baseState = o, o = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: nl, lastRenderedState: o }, a.queue = o, o = o.dispatch = wM.bind(null, et, o), [a.memoizedState, o];
  }
  function rl(o, a, c, p) {
    return o = { tag: o, create: a, destroy: c, deps: p, next: null }, a = et.updateQueue, a === null ? (a = { lastEffect: null, stores: null }, et.updateQueue = a, a.lastEffect = o.next = o) : (c = a.lastEffect, c === null ? a.lastEffect = o.next = o : (p = c.next, c.next = o, o.next = p, a.lastEffect = o)), o;
  }
  function z1() {
    return wn().memoizedState;
  }
  function fc(o, a, c, p) {
    var v = tr();
    et.flags |= o, v.memoizedState = rl(1 | a, c, void 0, p === void 0 ? null : p);
  }
  function hc(o, a, c, p) {
    var v = wn();
    p = p === void 0 ? null : p;
    var y = void 0;
    if (mt !== null) {
      var k = mt.memoizedState;
      if (y = k.destroy, p !== null && Zh(p, k.deps)) {
        v.memoizedState = rl(a, c, y, p);
        return;
      }
    }
    et.flags |= o, v.memoizedState = rl(1 | a, c, y, p);
  }
  function H1(o, a) {
    return fc(8390656, 8, o, a);
  }
  function np(o, a) {
    return hc(2048, 8, o, a);
  }
  function K1(o, a) {
    return hc(4, 2, o, a);
  }
  function G1(o, a) {
    return hc(4, 4, o, a);
  }
  function Y1(o, a) {
    if (typeof a == "function") return o = o(), a(o), function() {
      a(null);
    };
    if (a != null) return o = o(), a.current = o, function() {
      a.current = null;
    };
  }
  function q1(o, a, c) {
    return c = c != null ? c.concat([o]) : null, hc(4, 4, Y1.bind(null, a, o), c);
  }
  function rp() {
  }
  function X1(o, a) {
    var c = wn();
    a = a === void 0 ? null : a;
    var p = c.memoizedState;
    return p !== null && a !== null && Zh(a, p[1]) ? p[0] : (c.memoizedState = [o, a], o);
  }
  function Z1(o, a) {
    var c = wn();
    a = a === void 0 ? null : a;
    var p = c.memoizedState;
    return p !== null && a !== null && Zh(a, p[1]) ? p[0] : (o = o(), c.memoizedState = [o, a], o);
  }
  function Q1(o, a, c) {
    return (Ii & 21) === 0 ? (o.baseState && (o.baseState = !1, Kt = !0), o.memoizedState = c) : (Pn(c, a) || (c = Tb(), et.lanes |= c, Li |= c, o.baseState = !0), a);
  }
  function vM(o, a) {
    var c = Ke;
    Ke = c !== 0 && 4 > c ? c : 4, o(!0);
    var p = Xh.transition;
    Xh.transition = {};
    try {
      o(!1), a();
    } finally {
      Ke = c, Xh.transition = p;
    }
  }
  function J1() {
    return wn().memoizedState;
  }
  function yM(o, a, c) {
    var p = ii(o);
    if (c = { lane: p, action: c, hasEagerState: !1, eagerState: null, next: null }, eC(o)) tC(a, c);
    else if (c = _1(o, a, c, p), c !== null) {
      var v = Ot();
      Dn(c, o, p, v), nC(c, a, p);
    }
  }
  function wM(o, a, c) {
    var p = ii(o), v = { lane: p, action: c, hasEagerState: !1, eagerState: null, next: null };
    if (eC(o)) tC(a, v);
    else {
      var y = o.alternate;
      if (o.lanes === 0 && (y === null || y.lanes === 0) && (y = a.lastRenderedReducer, y !== null)) try {
        var k = a.lastRenderedState, N = y(k, c);
        if (v.hasEagerState = !0, v.eagerState = N, Pn(N, k)) {
          var F = a.interleaved;
          F === null ? (v.next = v, zh(a)) : (v.next = F.next, F.next = v), a.interleaved = v;
          return;
        }
      } catch {
      } finally {
      }
      c = _1(o, a, v, p), c !== null && (v = Ot(), Dn(c, o, p, v), nC(c, a, p));
    }
  }
  function eC(o) {
    var a = o.alternate;
    return o === et || a !== null && a === et;
  }
  function tC(o, a) {
    el = dc = !0;
    var c = o.pending;
    c === null ? a.next = a : (a.next = c.next, c.next = a), o.pending = a;
  }
  function nC(o, a, c) {
    if ((c & 4194240) !== 0) {
      var p = a.lanes;
      p &= o.pendingLanes, c |= p, a.lanes = c, oh(o, c);
    }
  }
  var pc = { readContext: yn, useCallback: Vt, useContext: Vt, useEffect: Vt, useImperativeHandle: Vt, useInsertionEffect: Vt, useLayoutEffect: Vt, useMemo: Vt, useReducer: Vt, useRef: Vt, useState: Vt, useDebugValue: Vt, useDeferredValue: Vt, useTransition: Vt, useMutableSource: Vt, useSyncExternalStore: Vt, useId: Vt, unstable_isNewReconciler: !1 }, bM = { readContext: yn, useCallback: function(o, a) {
    return tr().memoizedState = [o, a === void 0 ? null : a], o;
  }, useContext: yn, useEffect: H1, useImperativeHandle: function(o, a, c) {
    return c = c != null ? c.concat([o]) : null, fc(
      4194308,
      4,
      Y1.bind(null, a, o),
      c
    );
  }, useLayoutEffect: function(o, a) {
    return fc(4194308, 4, o, a);
  }, useInsertionEffect: function(o, a) {
    return fc(4, 2, o, a);
  }, useMemo: function(o, a) {
    var c = tr();
    return a = a === void 0 ? null : a, o = o(), c.memoizedState = [o, a], o;
  }, useReducer: function(o, a, c) {
    var p = tr();
    return a = c !== void 0 ? c(a) : a, p.memoizedState = p.baseState = a, o = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: o, lastRenderedState: a }, p.queue = o, o = o.dispatch = yM.bind(null, et, o), [p.memoizedState, o];
  }, useRef: function(o) {
    var a = tr();
    return o = { current: o }, a.memoizedState = o;
  }, useState: W1, useDebugValue: rp, useDeferredValue: function(o) {
    return tr().memoizedState = o;
  }, useTransition: function() {
    var o = W1(!1), a = o[0];
    return o = vM.bind(null, o[1]), tr().memoizedState = o, [a, o];
  }, useMutableSource: function() {
  }, useSyncExternalStore: function(o, a, c) {
    var p = et, v = tr();
    if (Qe) {
      if (c === void 0) throw Error(n(407));
      c = c();
    } else {
      if (c = a(), Ct === null) throw Error(n(349));
      (Ii & 30) !== 0 || N1(p, a, c);
    }
    v.memoizedState = c;
    var y = { value: c, getSnapshot: a };
    return v.queue = y, H1(j1.bind(
      null,
      p,
      y,
      o
    ), [o]), p.flags |= 2048, rl(9, D1.bind(null, p, y, c, a), void 0, null), c;
  }, useId: function() {
    var o = tr(), a = Ct.identifierPrefix;
    if (Qe) {
      var c = wr, p = yr;
      c = (p & ~(1 << 32 - Ln(p) - 1)).toString(32) + c, a = ":" + a + "R" + c, c = tl++, 0 < c && (a += "H" + c.toString(32)), a += ":";
    } else c = gM++, a = ":" + a + "r" + c.toString(32) + ":";
    return o.memoizedState = a;
  }, unstable_isNewReconciler: !1 }, CM = {
    readContext: yn,
    useCallback: X1,
    useContext: yn,
    useEffect: np,
    useImperativeHandle: q1,
    useInsertionEffect: K1,
    useLayoutEffect: G1,
    useMemo: Z1,
    useReducer: ep,
    useRef: z1,
    useState: function() {
      return ep(nl);
    },
    useDebugValue: rp,
    useDeferredValue: function(o) {
      var a = wn();
      return Q1(a, mt.memoizedState, o);
    },
    useTransition: function() {
      var o = ep(nl)[0], a = wn().memoizedState;
      return [o, a];
    },
    useMutableSource: O1,
    useSyncExternalStore: B1,
    useId: J1,
    unstable_isNewReconciler: !1
  }, EM = { readContext: yn, useCallback: X1, useContext: yn, useEffect: np, useImperativeHandle: q1, useInsertionEffect: K1, useLayoutEffect: G1, useMemo: Z1, useReducer: tp, useRef: z1, useState: function() {
    return tp(nl);
  }, useDebugValue: rp, useDeferredValue: function(o) {
    var a = wn();
    return mt === null ? a.memoizedState = o : Q1(a, mt.memoizedState, o);
  }, useTransition: function() {
    var o = tp(nl)[0], a = wn().memoizedState;
    return [o, a];
  }, useMutableSource: O1, useSyncExternalStore: B1, useId: J1, unstable_isNewReconciler: !1 };
  function On(o, a) {
    if (o && o.defaultProps) {
      a = P({}, a), o = o.defaultProps;
      for (var c in o) a[c] === void 0 && (a[c] = o[c]);
      return a;
    }
    return a;
  }
  function ip(o, a, c, p) {
    a = o.memoizedState, c = c(p, a), c = c == null ? a : P({}, a, c), o.memoizedState = c, o.lanes === 0 && (o.updateQueue.baseState = c);
  }
  var mc = { isMounted: function(o) {
    return (o = o._reactInternals) ? Si(o) === o : !1;
  }, enqueueSetState: function(o, a, c) {
    o = o._reactInternals;
    var p = Ot(), v = ii(o), y = Cr(p, v);
    y.payload = a, c != null && (y.callback = c), a = ei(o, y, v), a !== null && (Dn(a, o, v, p), ac(a, o, v));
  }, enqueueReplaceState: function(o, a, c) {
    o = o._reactInternals;
    var p = Ot(), v = ii(o), y = Cr(p, v);
    y.tag = 1, y.payload = a, c != null && (y.callback = c), a = ei(o, y, v), a !== null && (Dn(a, o, v, p), ac(a, o, v));
  }, enqueueForceUpdate: function(o, a) {
    o = o._reactInternals;
    var c = Ot(), p = ii(o), v = Cr(c, p);
    v.tag = 2, a != null && (v.callback = a), a = ei(o, v, p), a !== null && (Dn(a, o, p, c), ac(a, o, p));
  } };
  function rC(o, a, c, p, v, y, k) {
    return o = o.stateNode, typeof o.shouldComponentUpdate == "function" ? o.shouldComponentUpdate(p, y, k) : a.prototype && a.prototype.isPureReactComponent ? !Wa(c, p) || !Wa(v, y) : !0;
  }
  function iC(o, a, c) {
    var p = !1, v = Zr, y = a.contextType;
    return typeof y == "object" && y !== null ? y = yn(y) : (v = Ht(a) ? Ri : $t.current, p = a.contextTypes, y = (p = p != null) ? jo(o, v) : Zr), a = new a(c, y), o.memoizedState = a.state !== null && a.state !== void 0 ? a.state : null, a.updater = mc, o.stateNode = a, a._reactInternals = o, p && (o = o.stateNode, o.__reactInternalMemoizedUnmaskedChildContext = v, o.__reactInternalMemoizedMaskedChildContext = y), a;
  }
  function oC(o, a, c, p) {
    o = a.state, typeof a.componentWillReceiveProps == "function" && a.componentWillReceiveProps(c, p), typeof a.UNSAFE_componentWillReceiveProps == "function" && a.UNSAFE_componentWillReceiveProps(c, p), a.state !== o && mc.enqueueReplaceState(a, a.state, null);
  }
  function op(o, a, c, p) {
    var v = o.stateNode;
    v.props = c, v.state = o.memoizedState, v.refs = {}, Hh(o);
    var y = a.contextType;
    typeof y == "object" && y !== null ? v.context = yn(y) : (y = Ht(a) ? Ri : $t.current, v.context = jo(o, y)), v.state = o.memoizedState, y = a.getDerivedStateFromProps, typeof y == "function" && (ip(o, a, y, c), v.state = o.memoizedState), typeof a.getDerivedStateFromProps == "function" || typeof v.getSnapshotBeforeUpdate == "function" || typeof v.UNSAFE_componentWillMount != "function" && typeof v.componentWillMount != "function" || (a = v.state, typeof v.componentWillMount == "function" && v.componentWillMount(), typeof v.UNSAFE_componentWillMount == "function" && v.UNSAFE_componentWillMount(), a !== v.state && mc.enqueueReplaceState(v, v.state, null), lc(o, c, v, p), v.state = o.memoizedState), typeof v.componentDidMount == "function" && (o.flags |= 4194308);
  }
  function Yo(o, a) {
    try {
      var c = "", p = a;
      do
        c += ee(p), p = p.return;
      while (p);
      var v = c;
    } catch (y) {
      v = `
Error generating stack: ` + y.message + `
` + y.stack;
    }
    return { value: o, source: a, stack: v, digest: null };
  }
  function sp(o, a, c) {
    return { value: o, source: null, stack: c ?? null, digest: a ?? null };
  }
  function ap(o, a) {
    try {
      console.error(a.value);
    } catch (c) {
      setTimeout(function() {
        throw c;
      });
    }
  }
  var AM = typeof WeakMap == "function" ? WeakMap : Map;
  function sC(o, a, c) {
    c = Cr(-1, c), c.tag = 3, c.payload = { element: null };
    var p = a.value;
    return c.callback = function() {
      Ec || (Ec = !0, Ep = p), ap(o, a);
    }, c;
  }
  function aC(o, a, c) {
    c = Cr(-1, c), c.tag = 3;
    var p = o.type.getDerivedStateFromError;
    if (typeof p == "function") {
      var v = a.value;
      c.payload = function() {
        return p(v);
      }, c.callback = function() {
        ap(o, a);
      };
    }
    var y = o.stateNode;
    return y !== null && typeof y.componentDidCatch == "function" && (c.callback = function() {
      ap(o, a), typeof p != "function" && (ni === null ? ni = /* @__PURE__ */ new Set([this]) : ni.add(this));
      var k = a.stack;
      this.componentDidCatch(a.value, { componentStack: k !== null ? k : "" });
    }), c;
  }
  function lC(o, a, c) {
    var p = o.pingCache;
    if (p === null) {
      p = o.pingCache = new AM();
      var v = /* @__PURE__ */ new Set();
      p.set(a, v);
    } else v = p.get(a), v === void 0 && (v = /* @__PURE__ */ new Set(), p.set(a, v));
    v.has(c) || (v.add(c), o = BM.bind(null, o, a, c), a.then(o, o));
  }
  function uC(o) {
    do {
      var a;
      if ((a = o.tag === 13) && (a = o.memoizedState, a = a !== null ? a.dehydrated !== null : !0), a) return o;
      o = o.return;
    } while (o !== null);
    return null;
  }
  function cC(o, a, c, p, v) {
    return (o.mode & 1) === 0 ? (o === a ? o.flags |= 65536 : (o.flags |= 128, c.flags |= 131072, c.flags &= -52805, c.tag === 1 && (c.alternate === null ? c.tag = 17 : (a = Cr(-1, 1), a.tag = 2, ei(c, a, 1))), c.lanes |= 1), o) : (o.flags |= 65536, o.lanes = v, o);
  }
  var xM = L.ReactCurrentOwner, Kt = !1;
  function Mt(o, a, c, p) {
    a.child = o === null ? V1(a, null, c, p) : zo(a, o.child, c, p);
  }
  function dC(o, a, c, p, v) {
    c = c.render;
    var y = a.ref;
    return Ko(a, v), p = Qh(o, a, c, p, y, v), c = Jh(), o !== null && !Kt ? (a.updateQueue = o.updateQueue, a.flags &= -2053, o.lanes &= ~v, Er(o, a, v)) : (Qe && c && Mh(a), a.flags |= 1, Mt(o, a, p, v), a.child);
  }
  function fC(o, a, c, p, v) {
    if (o === null) {
      var y = c.type;
      return typeof y == "function" && !$p(y) && y.defaultProps === void 0 && c.compare === null && c.defaultProps === void 0 ? (a.tag = 15, a.type = y, hC(o, a, y, p, v)) : (o = Tc(c.type, null, p, a, a.mode, v), o.ref = a.ref, o.return = a, a.child = o);
    }
    if (y = o.child, (o.lanes & v) === 0) {
      var k = y.memoizedProps;
      if (c = c.compare, c = c !== null ? c : Wa, c(k, p) && o.ref === a.ref) return Er(o, a, v);
    }
    return a.flags |= 1, o = si(y, p), o.ref = a.ref, o.return = a, a.child = o;
  }
  function hC(o, a, c, p, v) {
    if (o !== null) {
      var y = o.memoizedProps;
      if (Wa(y, p) && o.ref === a.ref) if (Kt = !1, a.pendingProps = p = y, (o.lanes & v) !== 0) (o.flags & 131072) !== 0 && (Kt = !0);
      else return a.lanes = o.lanes, Er(o, a, v);
    }
    return lp(o, a, c, p, v);
  }
  function pC(o, a, c) {
    var p = a.pendingProps, v = p.children, y = o !== null ? o.memoizedState : null;
    if (p.mode === "hidden") if ((a.mode & 1) === 0) a.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, Ge(Xo, an), an |= c;
    else {
      if ((c & 1073741824) === 0) return o = y !== null ? y.baseLanes | c : c, a.lanes = a.childLanes = 1073741824, a.memoizedState = { baseLanes: o, cachePool: null, transitions: null }, a.updateQueue = null, Ge(Xo, an), an |= o, null;
      a.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, p = y !== null ? y.baseLanes : c, Ge(Xo, an), an |= p;
    }
    else y !== null ? (p = y.baseLanes | c, a.memoizedState = null) : p = c, Ge(Xo, an), an |= p;
    return Mt(o, a, v, c), a.child;
  }
  function mC(o, a) {
    var c = a.ref;
    (o === null && c !== null || o !== null && o.ref !== c) && (a.flags |= 512, a.flags |= 2097152);
  }
  function lp(o, a, c, p, v) {
    var y = Ht(c) ? Ri : $t.current;
    return y = jo(a, y), Ko(a, v), c = Qh(o, a, c, p, y, v), p = Jh(), o !== null && !Kt ? (a.updateQueue = o.updateQueue, a.flags &= -2053, o.lanes &= ~v, Er(o, a, v)) : (Qe && p && Mh(a), a.flags |= 1, Mt(o, a, c, v), a.child);
  }
  function gC(o, a, c, p, v) {
    if (Ht(c)) {
      var y = !0;
      Ju(a);
    } else y = !1;
    if (Ko(a, v), a.stateNode === null) vc(o, a), iC(a, c, p), op(a, c, p, v), p = !0;
    else if (o === null) {
      var k = a.stateNode, N = a.memoizedProps;
      k.props = N;
      var F = k.context, X = c.contextType;
      typeof X == "object" && X !== null ? X = yn(X) : (X = Ht(c) ? Ri : $t.current, X = jo(a, X));
      var oe = c.getDerivedStateFromProps, ae = typeof oe == "function" || typeof k.getSnapshotBeforeUpdate == "function";
      ae || typeof k.UNSAFE_componentWillReceiveProps != "function" && typeof k.componentWillReceiveProps != "function" || (N !== p || F !== X) && oC(a, k, p, X), Jr = !1;
      var ie = a.memoizedState;
      k.state = ie, lc(a, p, k, v), F = a.memoizedState, N !== p || ie !== F || zt.current || Jr ? (typeof oe == "function" && (ip(a, c, oe, p), F = a.memoizedState), (N = Jr || rC(a, c, N, p, ie, F, X)) ? (ae || typeof k.UNSAFE_componentWillMount != "function" && typeof k.componentWillMount != "function" || (typeof k.componentWillMount == "function" && k.componentWillMount(), typeof k.UNSAFE_componentWillMount == "function" && k.UNSAFE_componentWillMount()), typeof k.componentDidMount == "function" && (a.flags |= 4194308)) : (typeof k.componentDidMount == "function" && (a.flags |= 4194308), a.memoizedProps = p, a.memoizedState = F), k.props = p, k.state = F, k.context = X, p = N) : (typeof k.componentDidMount == "function" && (a.flags |= 4194308), p = !1);
    } else {
      k = a.stateNode, I1(o, a), N = a.memoizedProps, X = a.type === a.elementType ? N : On(a.type, N), k.props = X, ae = a.pendingProps, ie = k.context, F = c.contextType, typeof F == "object" && F !== null ? F = yn(F) : (F = Ht(c) ? Ri : $t.current, F = jo(a, F));
      var me = c.getDerivedStateFromProps;
      (oe = typeof me == "function" || typeof k.getSnapshotBeforeUpdate == "function") || typeof k.UNSAFE_componentWillReceiveProps != "function" && typeof k.componentWillReceiveProps != "function" || (N !== ae || ie !== F) && oC(a, k, p, F), Jr = !1, ie = a.memoizedState, k.state = ie, lc(a, p, k, v);
      var ye = a.memoizedState;
      N !== ae || ie !== ye || zt.current || Jr ? (typeof me == "function" && (ip(a, c, me, p), ye = a.memoizedState), (X = Jr || rC(a, c, X, p, ie, ye, F) || !1) ? (oe || typeof k.UNSAFE_componentWillUpdate != "function" && typeof k.componentWillUpdate != "function" || (typeof k.componentWillUpdate == "function" && k.componentWillUpdate(p, ye, F), typeof k.UNSAFE_componentWillUpdate == "function" && k.UNSAFE_componentWillUpdate(p, ye, F)), typeof k.componentDidUpdate == "function" && (a.flags |= 4), typeof k.getSnapshotBeforeUpdate == "function" && (a.flags |= 1024)) : (typeof k.componentDidUpdate != "function" || N === o.memoizedProps && ie === o.memoizedState || (a.flags |= 4), typeof k.getSnapshotBeforeUpdate != "function" || N === o.memoizedProps && ie === o.memoizedState || (a.flags |= 1024), a.memoizedProps = p, a.memoizedState = ye), k.props = p, k.state = ye, k.context = F, p = X) : (typeof k.componentDidUpdate != "function" || N === o.memoizedProps && ie === o.memoizedState || (a.flags |= 4), typeof k.getSnapshotBeforeUpdate != "function" || N === o.memoizedProps && ie === o.memoizedState || (a.flags |= 1024), p = !1);
    }
    return up(o, a, c, p, y, v);
  }
  function up(o, a, c, p, v, y) {
    mC(o, a);
    var k = (a.flags & 128) !== 0;
    if (!p && !k) return v && C1(a, c, !1), Er(o, a, y);
    p = a.stateNode, xM.current = a;
    var N = k && typeof c.getDerivedStateFromError != "function" ? null : p.render();
    return a.flags |= 1, o !== null && k ? (a.child = zo(a, o.child, null, y), a.child = zo(a, null, N, y)) : Mt(o, a, N, y), a.memoizedState = p.state, v && C1(a, c, !0), a.child;
  }
  function vC(o) {
    var a = o.stateNode;
    a.pendingContext ? w1(o, a.pendingContext, a.pendingContext !== a.context) : a.context && w1(o, a.context, !1), Kh(o, a.containerInfo);
  }
  function yC(o, a, c, p, v) {
    return Wo(), Dh(v), a.flags |= 256, Mt(o, a, c, p), a.child;
  }
  var cp = { dehydrated: null, treeContext: null, retryLane: 0 };
  function dp(o) {
    return { baseLanes: o, cachePool: null, transitions: null };
  }
  function wC(o, a, c) {
    var p = a.pendingProps, v = Je.current, y = !1, k = (a.flags & 128) !== 0, N;
    if ((N = k) || (N = o !== null && o.memoizedState === null ? !1 : (v & 2) !== 0), N ? (y = !0, a.flags &= -129) : (o === null || o.memoizedState !== null) && (v |= 1), Ge(Je, v & 1), o === null)
      return Nh(a), o = a.memoizedState, o !== null && (o = o.dehydrated, o !== null) ? ((a.mode & 1) === 0 ? a.lanes = 1 : o.data === "$!" ? a.lanes = 8 : a.lanes = 1073741824, null) : (k = p.children, o = p.fallback, y ? (p = a.mode, y = a.child, k = { mode: "hidden", children: k }, (p & 1) === 0 && y !== null ? (y.childLanes = 0, y.pendingProps = k) : y = $c(k, p, 0, null), o = Bi(o, p, c, null), y.return = a, o.return = a, y.sibling = o, a.child = y, a.child.memoizedState = dp(c), a.memoizedState = cp, o) : fp(a, k));
    if (v = o.memoizedState, v !== null && (N = v.dehydrated, N !== null)) return SM(o, a, k, p, N, v, c);
    if (y) {
      y = p.fallback, k = a.mode, v = o.child, N = v.sibling;
      var F = { mode: "hidden", children: p.children };
      return (k & 1) === 0 && a.child !== v ? (p = a.child, p.childLanes = 0, p.pendingProps = F, a.deletions = null) : (p = si(v, F), p.subtreeFlags = v.subtreeFlags & 14680064), N !== null ? y = si(N, y) : (y = Bi(y, k, c, null), y.flags |= 2), y.return = a, p.return = a, p.sibling = y, a.child = p, p = y, y = a.child, k = o.child.memoizedState, k = k === null ? dp(c) : { baseLanes: k.baseLanes | c, cachePool: null, transitions: k.transitions }, y.memoizedState = k, y.childLanes = o.childLanes & ~c, a.memoizedState = cp, p;
    }
    return y = o.child, o = y.sibling, p = si(y, { mode: "visible", children: p.children }), (a.mode & 1) === 0 && (p.lanes = c), p.return = a, p.sibling = null, o !== null && (c = a.deletions, c === null ? (a.deletions = [o], a.flags |= 16) : c.push(o)), a.child = p, a.memoizedState = null, p;
  }
  function fp(o, a) {
    return a = $c({ mode: "visible", children: a }, o.mode, 0, null), a.return = o, o.child = a;
  }
  function gc(o, a, c, p) {
    return p !== null && Dh(p), zo(a, o.child, null, c), o = fp(a, a.pendingProps.children), o.flags |= 2, a.memoizedState = null, o;
  }
  function SM(o, a, c, p, v, y, k) {
    if (c)
      return a.flags & 256 ? (a.flags &= -257, p = sp(Error(n(422))), gc(o, a, k, p)) : a.memoizedState !== null ? (a.child = o.child, a.flags |= 128, null) : (y = p.fallback, v = a.mode, p = $c({ mode: "visible", children: p.children }, v, 0, null), y = Bi(y, v, k, null), y.flags |= 2, p.return = a, y.return = a, p.sibling = y, a.child = p, (a.mode & 1) !== 0 && zo(a, o.child, null, k), a.child.memoizedState = dp(k), a.memoizedState = cp, y);
    if ((a.mode & 1) === 0) return gc(o, a, k, null);
    if (v.data === "$!") {
      if (p = v.nextSibling && v.nextSibling.dataset, p) var N = p.dgst;
      return p = N, y = Error(n(419)), p = sp(y, p, void 0), gc(o, a, k, p);
    }
    if (N = (k & o.childLanes) !== 0, Kt || N) {
      if (p = Ct, p !== null) {
        switch (k & -k) {
          case 4:
            v = 2;
            break;
          case 16:
            v = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            v = 32;
            break;
          case 536870912:
            v = 268435456;
            break;
          default:
            v = 0;
        }
        v = (v & (p.suspendedLanes | k)) !== 0 ? 0 : v, v !== 0 && v !== y.retryLane && (y.retryLane = v, br(o, v), Dn(p, o, v, -1));
      }
      return Tp(), p = sp(Error(n(421))), gc(o, a, k, p);
    }
    return v.data === "$?" ? (a.flags |= 128, a.child = o.child, a = NM.bind(null, o), v._reactRetry = a, null) : (o = y.treeContext, sn = qr(v.nextSibling), on = a, Qe = !0, Mn = null, o !== null && (gn[vn++] = yr, gn[vn++] = wr, gn[vn++] = Ti, yr = o.id, wr = o.overflow, Ti = a), a = fp(a, p.children), a.flags |= 4096, a);
  }
  function bC(o, a, c) {
    o.lanes |= a;
    var p = o.alternate;
    p !== null && (p.lanes |= a), Wh(o.return, a, c);
  }
  function hp(o, a, c, p, v) {
    var y = o.memoizedState;
    y === null ? o.memoizedState = { isBackwards: a, rendering: null, renderingStartTime: 0, last: p, tail: c, tailMode: v } : (y.isBackwards = a, y.rendering = null, y.renderingStartTime = 0, y.last = p, y.tail = c, y.tailMode = v);
  }
  function CC(o, a, c) {
    var p = a.pendingProps, v = p.revealOrder, y = p.tail;
    if (Mt(o, a, p.children, c), p = Je.current, (p & 2) !== 0) p = p & 1 | 2, a.flags |= 128;
    else {
      if (o !== null && (o.flags & 128) !== 0) e: for (o = a.child; o !== null; ) {
        if (o.tag === 13) o.memoizedState !== null && bC(o, c, a);
        else if (o.tag === 19) bC(o, c, a);
        else if (o.child !== null) {
          o.child.return = o, o = o.child;
          continue;
        }
        if (o === a) break e;
        for (; o.sibling === null; ) {
          if (o.return === null || o.return === a) break e;
          o = o.return;
        }
        o.sibling.return = o.return, o = o.sibling;
      }
      p &= 1;
    }
    if (Ge(Je, p), (a.mode & 1) === 0) a.memoizedState = null;
    else switch (v) {
      case "forwards":
        for (c = a.child, v = null; c !== null; ) o = c.alternate, o !== null && uc(o) === null && (v = c), c = c.sibling;
        c = v, c === null ? (v = a.child, a.child = null) : (v = c.sibling, c.sibling = null), hp(a, !1, v, c, y);
        break;
      case "backwards":
        for (c = null, v = a.child, a.child = null; v !== null; ) {
          if (o = v.alternate, o !== null && uc(o) === null) {
            a.child = v;
            break;
          }
          o = v.sibling, v.sibling = c, c = v, v = o;
        }
        hp(a, !0, c, null, y);
        break;
      case "together":
        hp(a, !1, null, null, void 0);
        break;
      default:
        a.memoizedState = null;
    }
    return a.child;
  }
  function vc(o, a) {
    (a.mode & 1) === 0 && o !== null && (o.alternate = null, a.alternate = null, a.flags |= 2);
  }
  function Er(o, a, c) {
    if (o !== null && (a.dependencies = o.dependencies), Li |= a.lanes, (c & a.childLanes) === 0) return null;
    if (o !== null && a.child !== o.child) throw Error(n(153));
    if (a.child !== null) {
      for (o = a.child, c = si(o, o.pendingProps), a.child = c, c.return = a; o.sibling !== null; ) o = o.sibling, c = c.sibling = si(o, o.pendingProps), c.return = a;
      c.sibling = null;
    }
    return a.child;
  }
  function kM(o, a, c) {
    switch (a.tag) {
      case 3:
        vC(a), Wo();
        break;
      case 5:
        M1(a);
        break;
      case 1:
        Ht(a.type) && Ju(a);
        break;
      case 4:
        Kh(a, a.stateNode.containerInfo);
        break;
      case 10:
        var p = a.type._context, v = a.memoizedProps.value;
        Ge(oc, p._currentValue), p._currentValue = v;
        break;
      case 13:
        if (p = a.memoizedState, p !== null)
          return p.dehydrated !== null ? (Ge(Je, Je.current & 1), a.flags |= 128, null) : (c & a.child.childLanes) !== 0 ? wC(o, a, c) : (Ge(Je, Je.current & 1), o = Er(o, a, c), o !== null ? o.sibling : null);
        Ge(Je, Je.current & 1);
        break;
      case 19:
        if (p = (c & a.childLanes) !== 0, (o.flags & 128) !== 0) {
          if (p) return CC(o, a, c);
          a.flags |= 128;
        }
        if (v = a.memoizedState, v !== null && (v.rendering = null, v.tail = null, v.lastEffect = null), Ge(Je, Je.current), p) break;
        return null;
      case 22:
      case 23:
        return a.lanes = 0, pC(o, a, c);
    }
    return Er(o, a, c);
  }
  var EC, pp, AC, xC;
  EC = function(o, a) {
    for (var c = a.child; c !== null; ) {
      if (c.tag === 5 || c.tag === 6) o.appendChild(c.stateNode);
      else if (c.tag !== 4 && c.child !== null) {
        c.child.return = c, c = c.child;
        continue;
      }
      if (c === a) break;
      for (; c.sibling === null; ) {
        if (c.return === null || c.return === a) return;
        c = c.return;
      }
      c.sibling.return = c.return, c = c.sibling;
    }
  }, pp = function() {
  }, AC = function(o, a, c, p) {
    var v = o.memoizedProps;
    if (v !== p) {
      o = a.stateNode, _i(er.current);
      var y = null;
      switch (c) {
        case "input":
          v = pn(o, v), p = pn(o, p), y = [];
          break;
        case "select":
          v = P({}, v, { value: void 0 }), p = P({}, p, { value: void 0 }), y = [];
          break;
        case "textarea":
          v = ko(o, v), p = ko(o, p), y = [];
          break;
        default:
          typeof v.onClick != "function" && typeof p.onClick == "function" && (o.onclick = Xu);
      }
      Yf(c, p);
      var k;
      c = null;
      for (X in v) if (!p.hasOwnProperty(X) && v.hasOwnProperty(X) && v[X] != null) if (X === "style") {
        var N = v[X];
        for (k in N) N.hasOwnProperty(k) && (c || (c = {}), c[k] = "");
      } else X !== "dangerouslySetInnerHTML" && X !== "children" && X !== "suppressContentEditableWarning" && X !== "suppressHydrationWarning" && X !== "autoFocus" && (i.hasOwnProperty(X) ? y || (y = []) : (y = y || []).push(X, null));
      for (X in p) {
        var F = p[X];
        if (N = v != null ? v[X] : void 0, p.hasOwnProperty(X) && F !== N && (F != null || N != null)) if (X === "style") if (N) {
          for (k in N) !N.hasOwnProperty(k) || F && F.hasOwnProperty(k) || (c || (c = {}), c[k] = "");
          for (k in F) F.hasOwnProperty(k) && N[k] !== F[k] && (c || (c = {}), c[k] = F[k]);
        } else c || (y || (y = []), y.push(
          X,
          c
        )), c = F;
        else X === "dangerouslySetInnerHTML" ? (F = F ? F.__html : void 0, N = N ? N.__html : void 0, F != null && N !== F && (y = y || []).push(X, F)) : X === "children" ? typeof F != "string" && typeof F != "number" || (y = y || []).push(X, "" + F) : X !== "suppressContentEditableWarning" && X !== "suppressHydrationWarning" && (i.hasOwnProperty(X) ? (F != null && X === "onScroll" && qe("scroll", o), y || N === F || (y = [])) : (y = y || []).push(X, F));
      }
      c && (y = y || []).push("style", c);
      var X = y;
      (a.updateQueue = X) && (a.flags |= 4);
    }
  }, xC = function(o, a, c, p) {
    c !== p && (a.flags |= 4);
  };
  function il(o, a) {
    if (!Qe) switch (o.tailMode) {
      case "hidden":
        a = o.tail;
        for (var c = null; a !== null; ) a.alternate !== null && (c = a), a = a.sibling;
        c === null ? o.tail = null : c.sibling = null;
        break;
      case "collapsed":
        c = o.tail;
        for (var p = null; c !== null; ) c.alternate !== null && (p = c), c = c.sibling;
        p === null ? a || o.tail === null ? o.tail = null : o.tail.sibling = null : p.sibling = null;
    }
  }
  function _t(o) {
    var a = o.alternate !== null && o.alternate.child === o.child, c = 0, p = 0;
    if (a) for (var v = o.child; v !== null; ) c |= v.lanes | v.childLanes, p |= v.subtreeFlags & 14680064, p |= v.flags & 14680064, v.return = o, v = v.sibling;
    else for (v = o.child; v !== null; ) c |= v.lanes | v.childLanes, p |= v.subtreeFlags, p |= v.flags, v.return = o, v = v.sibling;
    return o.subtreeFlags |= p, o.childLanes = c, a;
  }
  function RM(o, a, c) {
    var p = a.pendingProps;
    switch (Oh(a), a.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return _t(a), null;
      case 1:
        return Ht(a.type) && Qu(), _t(a), null;
      case 3:
        return p = a.stateNode, Go(), Xe(zt), Xe($t), qh(), p.pendingContext && (p.context = p.pendingContext, p.pendingContext = null), (o === null || o.child === null) && (rc(a) ? a.flags |= 4 : o === null || o.memoizedState.isDehydrated && (a.flags & 256) === 0 || (a.flags |= 1024, Mn !== null && (Sp(Mn), Mn = null))), pp(o, a), _t(a), null;
      case 5:
        Gh(a);
        var v = _i(Ja.current);
        if (c = a.type, o !== null && a.stateNode != null) AC(o, a, c, p, v), o.ref !== a.ref && (a.flags |= 512, a.flags |= 2097152);
        else {
          if (!p) {
            if (a.stateNode === null) throw Error(n(166));
            return _t(a), null;
          }
          if (o = _i(er.current), rc(a)) {
            p = a.stateNode, c = a.type;
            var y = a.memoizedProps;
            switch (p[Jn] = a, p[Ya] = y, o = (a.mode & 1) !== 0, c) {
              case "dialog":
                qe("cancel", p), qe("close", p);
                break;
              case "iframe":
              case "object":
              case "embed":
                qe("load", p);
                break;
              case "video":
              case "audio":
                for (v = 0; v < Ha.length; v++) qe(Ha[v], p);
                break;
              case "source":
                qe("error", p);
                break;
              case "img":
              case "image":
              case "link":
                qe(
                  "error",
                  p
                ), qe("load", p);
                break;
              case "details":
                qe("toggle", p);
                break;
              case "input":
                Zn(p, y), qe("invalid", p);
                break;
              case "select":
                p._wrapperState = { wasMultiple: !!y.multiple }, qe("invalid", p);
                break;
              case "textarea":
                Aa(p, y), qe("invalid", p);
            }
            Yf(c, y), v = null;
            for (var k in y) if (y.hasOwnProperty(k)) {
              var N = y[k];
              k === "children" ? typeof N == "string" ? p.textContent !== N && (y.suppressHydrationWarning !== !0 && qu(p.textContent, N, o), v = ["children", N]) : typeof N == "number" && p.textContent !== "" + N && (y.suppressHydrationWarning !== !0 && qu(
                p.textContent,
                N,
                o
              ), v = ["children", "" + N]) : i.hasOwnProperty(k) && N != null && k === "onScroll" && qe("scroll", p);
            }
            switch (c) {
              case "input":
                Ie(p), Tt(p, y, !0);
                break;
              case "textarea":
                Ie(p), xa(p);
                break;
              case "select":
              case "option":
                break;
              default:
                typeof y.onClick == "function" && (p.onclick = Xu);
            }
            p = v, a.updateQueue = p, p !== null && (a.flags |= 4);
          } else {
            k = v.nodeType === 9 ? v : v.ownerDocument, o === "http://www.w3.org/1999/xhtml" && (o = Sa(c)), o === "http://www.w3.org/1999/xhtml" ? c === "script" ? (o = k.createElement("div"), o.innerHTML = "<script><\/script>", o = o.removeChild(o.firstChild)) : typeof p.is == "string" ? o = k.createElement(c, { is: p.is }) : (o = k.createElement(c), c === "select" && (k = o, p.multiple ? k.multiple = !0 : p.size && (k.size = p.size))) : o = k.createElementNS(o, c), o[Jn] = a, o[Ya] = p, EC(o, a, !1, !1), a.stateNode = o;
            e: {
              switch (k = qf(c, p), c) {
                case "dialog":
                  qe("cancel", o), qe("close", o), v = p;
                  break;
                case "iframe":
                case "object":
                case "embed":
                  qe("load", o), v = p;
                  break;
                case "video":
                case "audio":
                  for (v = 0; v < Ha.length; v++) qe(Ha[v], o);
                  v = p;
                  break;
                case "source":
                  qe("error", o), v = p;
                  break;
                case "img":
                case "image":
                case "link":
                  qe(
                    "error",
                    o
                  ), qe("load", o), v = p;
                  break;
                case "details":
                  qe("toggle", o), v = p;
                  break;
                case "input":
                  Zn(o, p), v = pn(o, p), qe("invalid", o);
                  break;
                case "option":
                  v = p;
                  break;
                case "select":
                  o._wrapperState = { wasMultiple: !!p.multiple }, v = P({}, p, { value: void 0 }), qe("invalid", o);
                  break;
                case "textarea":
                  Aa(o, p), v = ko(o, p), qe("invalid", o);
                  break;
                default:
                  v = p;
              }
              Yf(c, v), N = v;
              for (y in N) if (N.hasOwnProperty(y)) {
                var F = N[y];
                y === "style" ? hb(o, F) : y === "dangerouslySetInnerHTML" ? (F = F ? F.__html : void 0, F != null && db(o, F)) : y === "children" ? typeof F == "string" ? (c !== "textarea" || F !== "") && ka(o, F) : typeof F == "number" && ka(o, "" + F) : y !== "suppressContentEditableWarning" && y !== "suppressHydrationWarning" && y !== "autoFocus" && (i.hasOwnProperty(y) ? F != null && y === "onScroll" && qe("scroll", o) : F != null && _(o, y, F, k));
              }
              switch (c) {
                case "input":
                  Ie(o), Tt(o, p, !1);
                  break;
                case "textarea":
                  Ie(o), xa(o);
                  break;
                case "option":
                  p.value != null && o.setAttribute("value", "" + re(p.value));
                  break;
                case "select":
                  o.multiple = !!p.multiple, y = p.value, y != null ? In(o, !!p.multiple, y, !1) : p.defaultValue != null && In(
                    o,
                    !!p.multiple,
                    p.defaultValue,
                    !0
                  );
                  break;
                default:
                  typeof v.onClick == "function" && (o.onclick = Xu);
              }
              switch (c) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  p = !!p.autoFocus;
                  break e;
                case "img":
                  p = !0;
                  break e;
                default:
                  p = !1;
              }
            }
            p && (a.flags |= 4);
          }
          a.ref !== null && (a.flags |= 512, a.flags |= 2097152);
        }
        return _t(a), null;
      case 6:
        if (o && a.stateNode != null) xC(o, a, o.memoizedProps, p);
        else {
          if (typeof p != "string" && a.stateNode === null) throw Error(n(166));
          if (c = _i(Ja.current), _i(er.current), rc(a)) {
            if (p = a.stateNode, c = a.memoizedProps, p[Jn] = a, (y = p.nodeValue !== c) && (o = on, o !== null)) switch (o.tag) {
              case 3:
                qu(p.nodeValue, c, (o.mode & 1) !== 0);
                break;
              case 5:
                o.memoizedProps.suppressHydrationWarning !== !0 && qu(p.nodeValue, c, (o.mode & 1) !== 0);
            }
            y && (a.flags |= 4);
          } else p = (c.nodeType === 9 ? c : c.ownerDocument).createTextNode(p), p[Jn] = a, a.stateNode = p;
        }
        return _t(a), null;
      case 13:
        if (Xe(Je), p = a.memoizedState, o === null || o.memoizedState !== null && o.memoizedState.dehydrated !== null) {
          if (Qe && sn !== null && (a.mode & 1) !== 0 && (a.flags & 128) === 0) R1(), Wo(), a.flags |= 98560, y = !1;
          else if (y = rc(a), p !== null && p.dehydrated !== null) {
            if (o === null) {
              if (!y) throw Error(n(318));
              if (y = a.memoizedState, y = y !== null ? y.dehydrated : null, !y) throw Error(n(317));
              y[Jn] = a;
            } else Wo(), (a.flags & 128) === 0 && (a.memoizedState = null), a.flags |= 4;
            _t(a), y = !1;
          } else Mn !== null && (Sp(Mn), Mn = null), y = !0;
          if (!y) return a.flags & 65536 ? a : null;
        }
        return (a.flags & 128) !== 0 ? (a.lanes = c, a) : (p = p !== null, p !== (o !== null && o.memoizedState !== null) && p && (a.child.flags |= 8192, (a.mode & 1) !== 0 && (o === null || (Je.current & 1) !== 0 ? gt === 0 && (gt = 3) : Tp())), a.updateQueue !== null && (a.flags |= 4), _t(a), null);
      case 4:
        return Go(), pp(o, a), o === null && Ka(a.stateNode.containerInfo), _t(a), null;
      case 10:
        return Uh(a.type._context), _t(a), null;
      case 17:
        return Ht(a.type) && Qu(), _t(a), null;
      case 19:
        if (Xe(Je), y = a.memoizedState, y === null) return _t(a), null;
        if (p = (a.flags & 128) !== 0, k = y.rendering, k === null) if (p) il(y, !1);
        else {
          if (gt !== 0 || o !== null && (o.flags & 128) !== 0) for (o = a.child; o !== null; ) {
            if (k = uc(o), k !== null) {
              for (a.flags |= 128, il(y, !1), p = k.updateQueue, p !== null && (a.updateQueue = p, a.flags |= 4), a.subtreeFlags = 0, p = c, c = a.child; c !== null; ) y = c, o = p, y.flags &= 14680066, k = y.alternate, k === null ? (y.childLanes = 0, y.lanes = o, y.child = null, y.subtreeFlags = 0, y.memoizedProps = null, y.memoizedState = null, y.updateQueue = null, y.dependencies = null, y.stateNode = null) : (y.childLanes = k.childLanes, y.lanes = k.lanes, y.child = k.child, y.subtreeFlags = 0, y.deletions = null, y.memoizedProps = k.memoizedProps, y.memoizedState = k.memoizedState, y.updateQueue = k.updateQueue, y.type = k.type, o = k.dependencies, y.dependencies = o === null ? null : { lanes: o.lanes, firstContext: o.firstContext }), c = c.sibling;
              return Ge(Je, Je.current & 1 | 2), a.child;
            }
            o = o.sibling;
          }
          y.tail !== null && st() > Zo && (a.flags |= 128, p = !0, il(y, !1), a.lanes = 4194304);
        }
        else {
          if (!p) if (o = uc(k), o !== null) {
            if (a.flags |= 128, p = !0, c = o.updateQueue, c !== null && (a.updateQueue = c, a.flags |= 4), il(y, !0), y.tail === null && y.tailMode === "hidden" && !k.alternate && !Qe) return _t(a), null;
          } else 2 * st() - y.renderingStartTime > Zo && c !== 1073741824 && (a.flags |= 128, p = !0, il(y, !1), a.lanes = 4194304);
          y.isBackwards ? (k.sibling = a.child, a.child = k) : (c = y.last, c !== null ? c.sibling = k : a.child = k, y.last = k);
        }
        return y.tail !== null ? (a = y.tail, y.rendering = a, y.tail = a.sibling, y.renderingStartTime = st(), a.sibling = null, c = Je.current, Ge(Je, p ? c & 1 | 2 : c & 1), a) : (_t(a), null);
      case 22:
      case 23:
        return Rp(), p = a.memoizedState !== null, o !== null && o.memoizedState !== null !== p && (a.flags |= 8192), p && (a.mode & 1) !== 0 ? (an & 1073741824) !== 0 && (_t(a), a.subtreeFlags & 6 && (a.flags |= 8192)) : _t(a), null;
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(n(156, a.tag));
  }
  function TM(o, a) {
    switch (Oh(a), a.tag) {
      case 1:
        return Ht(a.type) && Qu(), o = a.flags, o & 65536 ? (a.flags = o & -65537 | 128, a) : null;
      case 3:
        return Go(), Xe(zt), Xe($t), qh(), o = a.flags, (o & 65536) !== 0 && (o & 128) === 0 ? (a.flags = o & -65537 | 128, a) : null;
      case 5:
        return Gh(a), null;
      case 13:
        if (Xe(Je), o = a.memoizedState, o !== null && o.dehydrated !== null) {
          if (a.alternate === null) throw Error(n(340));
          Wo();
        }
        return o = a.flags, o & 65536 ? (a.flags = o & -65537 | 128, a) : null;
      case 19:
        return Xe(Je), null;
      case 4:
        return Go(), null;
      case 10:
        return Uh(a.type._context), null;
      case 22:
      case 23:
        return Rp(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var yc = !1, It = !1, $M = typeof WeakSet == "function" ? WeakSet : Set, ge = null;
  function qo(o, a) {
    var c = o.ref;
    if (c !== null) if (typeof c == "function") try {
      c(null);
    } catch (p) {
      tt(o, a, p);
    }
    else c.current = null;
  }
  function mp(o, a, c) {
    try {
      c();
    } catch (p) {
      tt(o, a, p);
    }
  }
  var SC = !1;
  function VM(o, a) {
    if (Rh = Nu, o = r1(), wh(o)) {
      if ("selectionStart" in o) var c = { start: o.selectionStart, end: o.selectionEnd };
      else e: {
        c = (c = o.ownerDocument) && c.defaultView || window;
        var p = c.getSelection && c.getSelection();
        if (p && p.rangeCount !== 0) {
          c = p.anchorNode;
          var v = p.anchorOffset, y = p.focusNode;
          p = p.focusOffset;
          try {
            c.nodeType, y.nodeType;
          } catch {
            c = null;
            break e;
          }
          var k = 0, N = -1, F = -1, X = 0, oe = 0, ae = o, ie = null;
          t: for (; ; ) {
            for (var me; ae !== c || v !== 0 && ae.nodeType !== 3 || (N = k + v), ae !== y || p !== 0 && ae.nodeType !== 3 || (F = k + p), ae.nodeType === 3 && (k += ae.nodeValue.length), (me = ae.firstChild) !== null; )
              ie = ae, ae = me;
            for (; ; ) {
              if (ae === o) break t;
              if (ie === c && ++X === v && (N = k), ie === y && ++oe === p && (F = k), (me = ae.nextSibling) !== null) break;
              ae = ie, ie = ae.parentNode;
            }
            ae = me;
          }
          c = N === -1 || F === -1 ? null : { start: N, end: F };
        } else c = null;
      }
      c = c || { start: 0, end: 0 };
    } else c = null;
    for (Th = { focusedElem: o, selectionRange: c }, Nu = !1, ge = a; ge !== null; ) if (a = ge, o = a.child, (a.subtreeFlags & 1028) !== 0 && o !== null) o.return = a, ge = o;
    else for (; ge !== null; ) {
      a = ge;
      try {
        var ye = a.alternate;
        if ((a.flags & 1024) !== 0) switch (a.tag) {
          case 0:
          case 11:
          case 15:
            break;
          case 1:
            if (ye !== null) {
              var we = ye.memoizedProps, at = ye.memoizedState, z = a.stateNode, U = z.getSnapshotBeforeUpdate(a.elementType === a.type ? we : On(a.type, we), at);
              z.__reactInternalSnapshotBeforeUpdate = U;
            }
            break;
          case 3:
            var K = a.stateNode.containerInfo;
            K.nodeType === 1 ? K.textContent = "" : K.nodeType === 9 && K.documentElement && K.removeChild(K.documentElement);
            break;
          case 5:
          case 6:
          case 4:
          case 17:
            break;
          default:
            throw Error(n(163));
        }
      } catch (ue) {
        tt(a, a.return, ue);
      }
      if (o = a.sibling, o !== null) {
        o.return = a.return, ge = o;
        break;
      }
      ge = a.return;
    }
    return ye = SC, SC = !1, ye;
  }
  function ol(o, a, c) {
    var p = a.updateQueue;
    if (p = p !== null ? p.lastEffect : null, p !== null) {
      var v = p = p.next;
      do {
        if ((v.tag & o) === o) {
          var y = v.destroy;
          v.destroy = void 0, y !== void 0 && mp(a, c, y);
        }
        v = v.next;
      } while (v !== p);
    }
  }
  function wc(o, a) {
    if (a = a.updateQueue, a = a !== null ? a.lastEffect : null, a !== null) {
      var c = a = a.next;
      do {
        if ((c.tag & o) === o) {
          var p = c.create;
          c.destroy = p();
        }
        c = c.next;
      } while (c !== a);
    }
  }
  function gp(o) {
    var a = o.ref;
    if (a !== null) {
      var c = o.stateNode;
      switch (o.tag) {
        case 5:
          o = c;
          break;
        default:
          o = c;
      }
      typeof a == "function" ? a(o) : a.current = o;
    }
  }
  function kC(o) {
    var a = o.alternate;
    a !== null && (o.alternate = null, kC(a)), o.child = null, o.deletions = null, o.sibling = null, o.tag === 5 && (a = o.stateNode, a !== null && (delete a[Jn], delete a[Ya], delete a[Ih], delete a[fM], delete a[hM])), o.stateNode = null, o.return = null, o.dependencies = null, o.memoizedProps = null, o.memoizedState = null, o.pendingProps = null, o.stateNode = null, o.updateQueue = null;
  }
  function RC(o) {
    return o.tag === 5 || o.tag === 3 || o.tag === 4;
  }
  function TC(o) {
    e: for (; ; ) {
      for (; o.sibling === null; ) {
        if (o.return === null || RC(o.return)) return null;
        o = o.return;
      }
      for (o.sibling.return = o.return, o = o.sibling; o.tag !== 5 && o.tag !== 6 && o.tag !== 18; ) {
        if (o.flags & 2 || o.child === null || o.tag === 4) continue e;
        o.child.return = o, o = o.child;
      }
      if (!(o.flags & 2)) return o.stateNode;
    }
  }
  function vp(o, a, c) {
    var p = o.tag;
    if (p === 5 || p === 6) o = o.stateNode, a ? c.nodeType === 8 ? c.parentNode.insertBefore(o, a) : c.insertBefore(o, a) : (c.nodeType === 8 ? (a = c.parentNode, a.insertBefore(o, c)) : (a = c, a.appendChild(o)), c = c._reactRootContainer, c != null || a.onclick !== null || (a.onclick = Xu));
    else if (p !== 4 && (o = o.child, o !== null)) for (vp(o, a, c), o = o.sibling; o !== null; ) vp(o, a, c), o = o.sibling;
  }
  function yp(o, a, c) {
    var p = o.tag;
    if (p === 5 || p === 6) o = o.stateNode, a ? c.insertBefore(o, a) : c.appendChild(o);
    else if (p !== 4 && (o = o.child, o !== null)) for (yp(o, a, c), o = o.sibling; o !== null; ) yp(o, a, c), o = o.sibling;
  }
  var kt = null, Bn = !1;
  function ti(o, a, c) {
    for (c = c.child; c !== null; ) $C(o, a, c), c = c.sibling;
  }
  function $C(o, a, c) {
    if (Qn && typeof Qn.onCommitFiberUnmount == "function") try {
      Qn.onCommitFiberUnmount(Iu, c);
    } catch {
    }
    switch (c.tag) {
      case 5:
        It || qo(c, a);
      case 6:
        var p = kt, v = Bn;
        kt = null, ti(o, a, c), kt = p, Bn = v, kt !== null && (Bn ? (o = kt, c = c.stateNode, o.nodeType === 8 ? o.parentNode.removeChild(c) : o.removeChild(c)) : kt.removeChild(c.stateNode));
        break;
      case 18:
        kt !== null && (Bn ? (o = kt, c = c.stateNode, o.nodeType === 8 ? _h(o.parentNode, c) : o.nodeType === 1 && _h(o, c), Ba(o)) : _h(kt, c.stateNode));
        break;
      case 4:
        p = kt, v = Bn, kt = c.stateNode.containerInfo, Bn = !0, ti(o, a, c), kt = p, Bn = v;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (!It && (p = c.updateQueue, p !== null && (p = p.lastEffect, p !== null))) {
          v = p = p.next;
          do {
            var y = v, k = y.destroy;
            y = y.tag, k !== void 0 && ((y & 2) !== 0 || (y & 4) !== 0) && mp(c, a, k), v = v.next;
          } while (v !== p);
        }
        ti(o, a, c);
        break;
      case 1:
        if (!It && (qo(c, a), p = c.stateNode, typeof p.componentWillUnmount == "function")) try {
          p.props = c.memoizedProps, p.state = c.memoizedState, p.componentWillUnmount();
        } catch (N) {
          tt(c, a, N);
        }
        ti(o, a, c);
        break;
      case 21:
        ti(o, a, c);
        break;
      case 22:
        c.mode & 1 ? (It = (p = It) || c.memoizedState !== null, ti(o, a, c), It = p) : ti(o, a, c);
        break;
      default:
        ti(o, a, c);
    }
  }
  function VC(o) {
    var a = o.updateQueue;
    if (a !== null) {
      o.updateQueue = null;
      var c = o.stateNode;
      c === null && (c = o.stateNode = new $M()), a.forEach(function(p) {
        var v = DM.bind(null, o, p);
        c.has(p) || (c.add(p), p.then(v, v));
      });
    }
  }
  function Nn(o, a) {
    var c = a.deletions;
    if (c !== null) for (var p = 0; p < c.length; p++) {
      var v = c[p];
      try {
        var y = o, k = a, N = k;
        e: for (; N !== null; ) {
          switch (N.tag) {
            case 5:
              kt = N.stateNode, Bn = !1;
              break e;
            case 3:
              kt = N.stateNode.containerInfo, Bn = !0;
              break e;
            case 4:
              kt = N.stateNode.containerInfo, Bn = !0;
              break e;
          }
          N = N.return;
        }
        if (kt === null) throw Error(n(160));
        $C(y, k, v), kt = null, Bn = !1;
        var F = v.alternate;
        F !== null && (F.return = null), v.return = null;
      } catch (X) {
        tt(v, a, X);
      }
    }
    if (a.subtreeFlags & 12854) for (a = a.child; a !== null; ) _C(a, o), a = a.sibling;
  }
  function _C(o, a) {
    var c = o.alternate, p = o.flags;
    switch (o.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if (Nn(a, o), nr(o), p & 4) {
          try {
            ol(3, o, o.return), wc(3, o);
          } catch (we) {
            tt(o, o.return, we);
          }
          try {
            ol(5, o, o.return);
          } catch (we) {
            tt(o, o.return, we);
          }
        }
        break;
      case 1:
        Nn(a, o), nr(o), p & 512 && c !== null && qo(c, c.return);
        break;
      case 5:
        if (Nn(a, o), nr(o), p & 512 && c !== null && qo(c, c.return), o.flags & 32) {
          var v = o.stateNode;
          try {
            ka(v, "");
          } catch (we) {
            tt(o, o.return, we);
          }
        }
        if (p & 4 && (v = o.stateNode, v != null)) {
          var y = o.memoizedProps, k = c !== null ? c.memoizedProps : y, N = o.type, F = o.updateQueue;
          if (o.updateQueue = null, F !== null) try {
            N === "input" && y.type === "radio" && y.name != null && tn(v, y), qf(N, k);
            var X = qf(N, y);
            for (k = 0; k < F.length; k += 2) {
              var oe = F[k], ae = F[k + 1];
              oe === "style" ? hb(v, ae) : oe === "dangerouslySetInnerHTML" ? db(v, ae) : oe === "children" ? ka(v, ae) : _(v, oe, ae, X);
            }
            switch (N) {
              case "input":
                mn(v, y);
                break;
              case "textarea":
                Ro(v, y);
                break;
              case "select":
                var ie = v._wrapperState.wasMultiple;
                v._wrapperState.wasMultiple = !!y.multiple;
                var me = y.value;
                me != null ? In(v, !!y.multiple, me, !1) : ie !== !!y.multiple && (y.defaultValue != null ? In(
                  v,
                  !!y.multiple,
                  y.defaultValue,
                  !0
                ) : In(v, !!y.multiple, y.multiple ? [] : "", !1));
            }
            v[Ya] = y;
          } catch (we) {
            tt(o, o.return, we);
          }
        }
        break;
      case 6:
        if (Nn(a, o), nr(o), p & 4) {
          if (o.stateNode === null) throw Error(n(162));
          v = o.stateNode, y = o.memoizedProps;
          try {
            v.nodeValue = y;
          } catch (we) {
            tt(o, o.return, we);
          }
        }
        break;
      case 3:
        if (Nn(a, o), nr(o), p & 4 && c !== null && c.memoizedState.isDehydrated) try {
          Ba(a.containerInfo);
        } catch (we) {
          tt(o, o.return, we);
        }
        break;
      case 4:
        Nn(a, o), nr(o);
        break;
      case 13:
        Nn(a, o), nr(o), v = o.child, v.flags & 8192 && (y = v.memoizedState !== null, v.stateNode.isHidden = y, !y || v.alternate !== null && v.alternate.memoizedState !== null || (Cp = st())), p & 4 && VC(o);
        break;
      case 22:
        if (oe = c !== null && c.memoizedState !== null, o.mode & 1 ? (It = (X = It) || oe, Nn(a, o), It = X) : Nn(a, o), nr(o), p & 8192) {
          if (X = o.memoizedState !== null, (o.stateNode.isHidden = X) && !oe && (o.mode & 1) !== 0) for (ge = o, oe = o.child; oe !== null; ) {
            for (ae = ge = oe; ge !== null; ) {
              switch (ie = ge, me = ie.child, ie.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  ol(4, ie, ie.return);
                  break;
                case 1:
                  qo(ie, ie.return);
                  var ye = ie.stateNode;
                  if (typeof ye.componentWillUnmount == "function") {
                    p = ie, c = ie.return;
                    try {
                      a = p, ye.props = a.memoizedProps, ye.state = a.memoizedState, ye.componentWillUnmount();
                    } catch (we) {
                      tt(p, c, we);
                    }
                  }
                  break;
                case 5:
                  qo(ie, ie.return);
                  break;
                case 22:
                  if (ie.memoizedState !== null) {
                    PC(ae);
                    continue;
                  }
              }
              me !== null ? (me.return = ie, ge = me) : PC(ae);
            }
            oe = oe.sibling;
          }
          e: for (oe = null, ae = o; ; ) {
            if (ae.tag === 5) {
              if (oe === null) {
                oe = ae;
                try {
                  v = ae.stateNode, X ? (y = v.style, typeof y.setProperty == "function" ? y.setProperty("display", "none", "important") : y.display = "none") : (N = ae.stateNode, F = ae.memoizedProps.style, k = F != null && F.hasOwnProperty("display") ? F.display : null, N.style.display = fb("display", k));
                } catch (we) {
                  tt(o, o.return, we);
                }
              }
            } else if (ae.tag === 6) {
              if (oe === null) try {
                ae.stateNode.nodeValue = X ? "" : ae.memoizedProps;
              } catch (we) {
                tt(o, o.return, we);
              }
            } else if ((ae.tag !== 22 && ae.tag !== 23 || ae.memoizedState === null || ae === o) && ae.child !== null) {
              ae.child.return = ae, ae = ae.child;
              continue;
            }
            if (ae === o) break e;
            for (; ae.sibling === null; ) {
              if (ae.return === null || ae.return === o) break e;
              oe === ae && (oe = null), ae = ae.return;
            }
            oe === ae && (oe = null), ae.sibling.return = ae.return, ae = ae.sibling;
          }
        }
        break;
      case 19:
        Nn(a, o), nr(o), p & 4 && VC(o);
        break;
      case 21:
        break;
      default:
        Nn(
          a,
          o
        ), nr(o);
    }
  }
  function nr(o) {
    var a = o.flags;
    if (a & 2) {
      try {
        e: {
          for (var c = o.return; c !== null; ) {
            if (RC(c)) {
              var p = c;
              break e;
            }
            c = c.return;
          }
          throw Error(n(160));
        }
        switch (p.tag) {
          case 5:
            var v = p.stateNode;
            p.flags & 32 && (ka(v, ""), p.flags &= -33);
            var y = TC(o);
            yp(o, y, v);
            break;
          case 3:
          case 4:
            var k = p.stateNode.containerInfo, N = TC(o);
            vp(o, N, k);
            break;
          default:
            throw Error(n(161));
        }
      } catch (F) {
        tt(o, o.return, F);
      }
      o.flags &= -3;
    }
    a & 4096 && (o.flags &= -4097);
  }
  function _M(o, a, c) {
    ge = o, IC(o);
  }
  function IC(o, a, c) {
    for (var p = (o.mode & 1) !== 0; ge !== null; ) {
      var v = ge, y = v.child;
      if (v.tag === 22 && p) {
        var k = v.memoizedState !== null || yc;
        if (!k) {
          var N = v.alternate, F = N !== null && N.memoizedState !== null || It;
          N = yc;
          var X = It;
          if (yc = k, (It = F) && !X) for (ge = v; ge !== null; ) k = ge, F = k.child, k.tag === 22 && k.memoizedState !== null ? MC(v) : F !== null ? (F.return = k, ge = F) : MC(v);
          for (; y !== null; ) ge = y, IC(y), y = y.sibling;
          ge = v, yc = N, It = X;
        }
        LC(o);
      } else (v.subtreeFlags & 8772) !== 0 && y !== null ? (y.return = v, ge = y) : LC(o);
    }
  }
  function LC(o) {
    for (; ge !== null; ) {
      var a = ge;
      if ((a.flags & 8772) !== 0) {
        var c = a.alternate;
        try {
          if ((a.flags & 8772) !== 0) switch (a.tag) {
            case 0:
            case 11:
            case 15:
              It || wc(5, a);
              break;
            case 1:
              var p = a.stateNode;
              if (a.flags & 4 && !It) if (c === null) p.componentDidMount();
              else {
                var v = a.elementType === a.type ? c.memoizedProps : On(a.type, c.memoizedProps);
                p.componentDidUpdate(v, c.memoizedState, p.__reactInternalSnapshotBeforeUpdate);
              }
              var y = a.updateQueue;
              y !== null && P1(a, y, p);
              break;
            case 3:
              var k = a.updateQueue;
              if (k !== null) {
                if (c = null, a.child !== null) switch (a.child.tag) {
                  case 5:
                    c = a.child.stateNode;
                    break;
                  case 1:
                    c = a.child.stateNode;
                }
                P1(a, k, c);
              }
              break;
            case 5:
              var N = a.stateNode;
              if (c === null && a.flags & 4) {
                c = N;
                var F = a.memoizedProps;
                switch (a.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    F.autoFocus && c.focus();
                    break;
                  case "img":
                    F.src && (c.src = F.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (a.memoizedState === null) {
                var X = a.alternate;
                if (X !== null) {
                  var oe = X.memoizedState;
                  if (oe !== null) {
                    var ae = oe.dehydrated;
                    ae !== null && Ba(ae);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(n(163));
          }
          It || a.flags & 512 && gp(a);
        } catch (ie) {
          tt(a, a.return, ie);
        }
      }
      if (a === o) {
        ge = null;
        break;
      }
      if (c = a.sibling, c !== null) {
        c.return = a.return, ge = c;
        break;
      }
      ge = a.return;
    }
  }
  function PC(o) {
    for (; ge !== null; ) {
      var a = ge;
      if (a === o) {
        ge = null;
        break;
      }
      var c = a.sibling;
      if (c !== null) {
        c.return = a.return, ge = c;
        break;
      }
      ge = a.return;
    }
  }
  function MC(o) {
    for (; ge !== null; ) {
      var a = ge;
      try {
        switch (a.tag) {
          case 0:
          case 11:
          case 15:
            var c = a.return;
            try {
              wc(4, a);
            } catch (F) {
              tt(a, c, F);
            }
            break;
          case 1:
            var p = a.stateNode;
            if (typeof p.componentDidMount == "function") {
              var v = a.return;
              try {
                p.componentDidMount();
              } catch (F) {
                tt(a, v, F);
              }
            }
            var y = a.return;
            try {
              gp(a);
            } catch (F) {
              tt(a, y, F);
            }
            break;
          case 5:
            var k = a.return;
            try {
              gp(a);
            } catch (F) {
              tt(a, k, F);
            }
        }
      } catch (F) {
        tt(a, a.return, F);
      }
      if (a === o) {
        ge = null;
        break;
      }
      var N = a.sibling;
      if (N !== null) {
        N.return = a.return, ge = N;
        break;
      }
      ge = a.return;
    }
  }
  var IM = Math.ceil, bc = L.ReactCurrentDispatcher, wp = L.ReactCurrentOwner, bn = L.ReactCurrentBatchConfig, Ue = 0, Ct = null, ct = null, Rt = 0, an = 0, Xo = Xr(0), gt = 0, sl = null, Li = 0, Cc = 0, bp = 0, al = null, Gt = null, Cp = 0, Zo = 1 / 0, Ar = null, Ec = !1, Ep = null, ni = null, Ac = !1, ri = null, xc = 0, ll = 0, Ap = null, Sc = -1, kc = 0;
  function Ot() {
    return (Ue & 6) !== 0 ? st() : Sc !== -1 ? Sc : Sc = st();
  }
  function ii(o) {
    return (o.mode & 1) === 0 ? 1 : (Ue & 2) !== 0 && Rt !== 0 ? Rt & -Rt : mM.transition !== null ? (kc === 0 && (kc = Tb()), kc) : (o = Ke, o !== 0 || (o = window.event, o = o === void 0 ? 16 : Bb(o.type)), o);
  }
  function Dn(o, a, c, p) {
    if (50 < ll) throw ll = 0, Ap = null, Error(n(185));
    Ia(o, c, p), ((Ue & 2) === 0 || o !== Ct) && (o === Ct && ((Ue & 2) === 0 && (Cc |= c), gt === 4 && oi(o, Rt)), Yt(o, p), c === 1 && Ue === 0 && (a.mode & 1) === 0 && (Zo = st() + 500, ec && Qr()));
  }
  function Yt(o, a) {
    var c = o.callbackNode;
    mP(o, a);
    var p = Mu(o, o === Ct ? Rt : 0);
    if (p === 0) c !== null && Sb(c), o.callbackNode = null, o.callbackPriority = 0;
    else if (a = p & -p, o.callbackPriority !== a) {
      if (c != null && Sb(c), a === 1) o.tag === 0 ? pM(BC.bind(null, o)) : E1(BC.bind(null, o)), cM(function() {
        (Ue & 6) === 0 && Qr();
      }), c = null;
      else {
        switch ($b(p)) {
          case 1:
            c = nh;
            break;
          case 4:
            c = kb;
            break;
          case 16:
            c = _u;
            break;
          case 536870912:
            c = Rb;
            break;
          default:
            c = _u;
        }
        c = HC(c, OC.bind(null, o));
      }
      o.callbackPriority = a, o.callbackNode = c;
    }
  }
  function OC(o, a) {
    if (Sc = -1, kc = 0, (Ue & 6) !== 0) throw Error(n(327));
    var c = o.callbackNode;
    if (Qo() && o.callbackNode !== c) return null;
    var p = Mu(o, o === Ct ? Rt : 0);
    if (p === 0) return null;
    if ((p & 30) !== 0 || (p & o.expiredLanes) !== 0 || a) a = Rc(o, p);
    else {
      a = p;
      var v = Ue;
      Ue |= 2;
      var y = DC();
      (Ct !== o || Rt !== a) && (Ar = null, Zo = st() + 500, Mi(o, a));
      do
        try {
          MM();
          break;
        } catch (N) {
          NC(o, N);
        }
      while (!0);
      Fh(), bc.current = y, Ue = v, ct !== null ? a = 0 : (Ct = null, Rt = 0, a = gt);
    }
    if (a !== 0) {
      if (a === 2 && (v = rh(o), v !== 0 && (p = v, a = xp(o, v))), a === 1) throw c = sl, Mi(o, 0), oi(o, p), Yt(o, st()), c;
      if (a === 6) oi(o, p);
      else {
        if (v = o.current.alternate, (p & 30) === 0 && !LM(v) && (a = Rc(o, p), a === 2 && (y = rh(o), y !== 0 && (p = y, a = xp(o, y))), a === 1)) throw c = sl, Mi(o, 0), oi(o, p), Yt(o, st()), c;
        switch (o.finishedWork = v, o.finishedLanes = p, a) {
          case 0:
          case 1:
            throw Error(n(345));
          case 2:
            Oi(o, Gt, Ar);
            break;
          case 3:
            if (oi(o, p), (p & 130023424) === p && (a = Cp + 500 - st(), 10 < a)) {
              if (Mu(o, 0) !== 0) break;
              if (v = o.suspendedLanes, (v & p) !== p) {
                Ot(), o.pingedLanes |= o.suspendedLanes & v;
                break;
              }
              o.timeoutHandle = Vh(Oi.bind(null, o, Gt, Ar), a);
              break;
            }
            Oi(o, Gt, Ar);
            break;
          case 4:
            if (oi(o, p), (p & 4194240) === p) break;
            for (a = o.eventTimes, v = -1; 0 < p; ) {
              var k = 31 - Ln(p);
              y = 1 << k, k = a[k], k > v && (v = k), p &= ~y;
            }
            if (p = v, p = st() - p, p = (120 > p ? 120 : 480 > p ? 480 : 1080 > p ? 1080 : 1920 > p ? 1920 : 3e3 > p ? 3e3 : 4320 > p ? 4320 : 1960 * IM(p / 1960)) - p, 10 < p) {
              o.timeoutHandle = Vh(Oi.bind(null, o, Gt, Ar), p);
              break;
            }
            Oi(o, Gt, Ar);
            break;
          case 5:
            Oi(o, Gt, Ar);
            break;
          default:
            throw Error(n(329));
        }
      }
    }
    return Yt(o, st()), o.callbackNode === c ? OC.bind(null, o) : null;
  }
  function xp(o, a) {
    var c = al;
    return o.current.memoizedState.isDehydrated && (Mi(o, a).flags |= 256), o = Rc(o, a), o !== 2 && (a = Gt, Gt = c, a !== null && Sp(a)), o;
  }
  function Sp(o) {
    Gt === null ? Gt = o : Gt.push.apply(Gt, o);
  }
  function LM(o) {
    for (var a = o; ; ) {
      if (a.flags & 16384) {
        var c = a.updateQueue;
        if (c !== null && (c = c.stores, c !== null)) for (var p = 0; p < c.length; p++) {
          var v = c[p], y = v.getSnapshot;
          v = v.value;
          try {
            if (!Pn(y(), v)) return !1;
          } catch {
            return !1;
          }
        }
      }
      if (c = a.child, a.subtreeFlags & 16384 && c !== null) c.return = a, a = c;
      else {
        if (a === o) break;
        for (; a.sibling === null; ) {
          if (a.return === null || a.return === o) return !0;
          a = a.return;
        }
        a.sibling.return = a.return, a = a.sibling;
      }
    }
    return !0;
  }
  function oi(o, a) {
    for (a &= ~bp, a &= ~Cc, o.suspendedLanes |= a, o.pingedLanes &= ~a, o = o.expirationTimes; 0 < a; ) {
      var c = 31 - Ln(a), p = 1 << c;
      o[c] = -1, a &= ~p;
    }
  }
  function BC(o) {
    if ((Ue & 6) !== 0) throw Error(n(327));
    Qo();
    var a = Mu(o, 0);
    if ((a & 1) === 0) return Yt(o, st()), null;
    var c = Rc(o, a);
    if (o.tag !== 0 && c === 2) {
      var p = rh(o);
      p !== 0 && (a = p, c = xp(o, p));
    }
    if (c === 1) throw c = sl, Mi(o, 0), oi(o, a), Yt(o, st()), c;
    if (c === 6) throw Error(n(345));
    return o.finishedWork = o.current.alternate, o.finishedLanes = a, Oi(o, Gt, Ar), Yt(o, st()), null;
  }
  function kp(o, a) {
    var c = Ue;
    Ue |= 1;
    try {
      return o(a);
    } finally {
      Ue = c, Ue === 0 && (Zo = st() + 500, ec && Qr());
    }
  }
  function Pi(o) {
    ri !== null && ri.tag === 0 && (Ue & 6) === 0 && Qo();
    var a = Ue;
    Ue |= 1;
    var c = bn.transition, p = Ke;
    try {
      if (bn.transition = null, Ke = 1, o) return o();
    } finally {
      Ke = p, bn.transition = c, Ue = a, (Ue & 6) === 0 && Qr();
    }
  }
  function Rp() {
    an = Xo.current, Xe(Xo);
  }
  function Mi(o, a) {
    o.finishedWork = null, o.finishedLanes = 0;
    var c = o.timeoutHandle;
    if (c !== -1 && (o.timeoutHandle = -1, uM(c)), ct !== null) for (c = ct.return; c !== null; ) {
      var p = c;
      switch (Oh(p), p.tag) {
        case 1:
          p = p.type.childContextTypes, p != null && Qu();
          break;
        case 3:
          Go(), Xe(zt), Xe($t), qh();
          break;
        case 5:
          Gh(p);
          break;
        case 4:
          Go();
          break;
        case 13:
          Xe(Je);
          break;
        case 19:
          Xe(Je);
          break;
        case 10:
          Uh(p.type._context);
          break;
        case 22:
        case 23:
          Rp();
      }
      c = c.return;
    }
    if (Ct = o, ct = o = si(o.current, null), Rt = an = a, gt = 0, sl = null, bp = Cc = Li = 0, Gt = al = null, Vi !== null) {
      for (a = 0; a < Vi.length; a++) if (c = Vi[a], p = c.interleaved, p !== null) {
        c.interleaved = null;
        var v = p.next, y = c.pending;
        if (y !== null) {
          var k = y.next;
          y.next = v, p.next = k;
        }
        c.pending = p;
      }
      Vi = null;
    }
    return o;
  }
  function NC(o, a) {
    do {
      var c = ct;
      try {
        if (Fh(), cc.current = pc, dc) {
          for (var p = et.memoizedState; p !== null; ) {
            var v = p.queue;
            v !== null && (v.pending = null), p = p.next;
          }
          dc = !1;
        }
        if (Ii = 0, bt = mt = et = null, el = !1, tl = 0, wp.current = null, c === null || c.return === null) {
          gt = 1, sl = a, ct = null;
          break;
        }
        e: {
          var y = o, k = c.return, N = c, F = a;
          if (a = Rt, N.flags |= 32768, F !== null && typeof F == "object" && typeof F.then == "function") {
            var X = F, oe = N, ae = oe.tag;
            if ((oe.mode & 1) === 0 && (ae === 0 || ae === 11 || ae === 15)) {
              var ie = oe.alternate;
              ie ? (oe.updateQueue = ie.updateQueue, oe.memoizedState = ie.memoizedState, oe.lanes = ie.lanes) : (oe.updateQueue = null, oe.memoizedState = null);
            }
            var me = uC(k);
            if (me !== null) {
              me.flags &= -257, cC(me, k, N, y, a), me.mode & 1 && lC(y, X, a), a = me, F = X;
              var ye = a.updateQueue;
              if (ye === null) {
                var we = /* @__PURE__ */ new Set();
                we.add(F), a.updateQueue = we;
              } else ye.add(F);
              break e;
            } else {
              if ((a & 1) === 0) {
                lC(y, X, a), Tp();
                break e;
              }
              F = Error(n(426));
            }
          } else if (Qe && N.mode & 1) {
            var at = uC(k);
            if (at !== null) {
              (at.flags & 65536) === 0 && (at.flags |= 256), cC(at, k, N, y, a), Dh(Yo(F, N));
              break e;
            }
          }
          y = F = Yo(F, N), gt !== 4 && (gt = 2), al === null ? al = [y] : al.push(y), y = k;
          do {
            switch (y.tag) {
              case 3:
                y.flags |= 65536, a &= -a, y.lanes |= a;
                var z = sC(y, F, a);
                L1(y, z);
                break e;
              case 1:
                N = F;
                var U = y.type, K = y.stateNode;
                if ((y.flags & 128) === 0 && (typeof U.getDerivedStateFromError == "function" || K !== null && typeof K.componentDidCatch == "function" && (ni === null || !ni.has(K)))) {
                  y.flags |= 65536, a &= -a, y.lanes |= a;
                  var ue = aC(y, N, a);
                  L1(y, ue);
                  break e;
                }
            }
            y = y.return;
          } while (y !== null);
        }
        FC(c);
      } catch (be) {
        a = be, ct === c && c !== null && (ct = c = c.return);
        continue;
      }
      break;
    } while (!0);
  }
  function DC() {
    var o = bc.current;
    return bc.current = pc, o === null ? pc : o;
  }
  function Tp() {
    (gt === 0 || gt === 3 || gt === 2) && (gt = 4), Ct === null || (Li & 268435455) === 0 && (Cc & 268435455) === 0 || oi(Ct, Rt);
  }
  function Rc(o, a) {
    var c = Ue;
    Ue |= 2;
    var p = DC();
    (Ct !== o || Rt !== a) && (Ar = null, Mi(o, a));
    do
      try {
        PM();
        break;
      } catch (v) {
        NC(o, v);
      }
    while (!0);
    if (Fh(), Ue = c, bc.current = p, ct !== null) throw Error(n(261));
    return Ct = null, Rt = 0, gt;
  }
  function PM() {
    for (; ct !== null; ) jC(ct);
  }
  function MM() {
    for (; ct !== null && !sP(); ) jC(ct);
  }
  function jC(o) {
    var a = zC(o.alternate, o, an);
    o.memoizedProps = o.pendingProps, a === null ? FC(o) : ct = a, wp.current = null;
  }
  function FC(o) {
    var a = o;
    do {
      var c = a.alternate;
      if (o = a.return, (a.flags & 32768) === 0) {
        if (c = RM(c, a, an), c !== null) {
          ct = c;
          return;
        }
      } else {
        if (c = TM(c, a), c !== null) {
          c.flags &= 32767, ct = c;
          return;
        }
        if (o !== null) o.flags |= 32768, o.subtreeFlags = 0, o.deletions = null;
        else {
          gt = 6, ct = null;
          return;
        }
      }
      if (a = a.sibling, a !== null) {
        ct = a;
        return;
      }
      ct = a = o;
    } while (a !== null);
    gt === 0 && (gt = 5);
  }
  function Oi(o, a, c) {
    var p = Ke, v = bn.transition;
    try {
      bn.transition = null, Ke = 1, OM(o, a, c, p);
    } finally {
      bn.transition = v, Ke = p;
    }
    return null;
  }
  function OM(o, a, c, p) {
    do
      Qo();
    while (ri !== null);
    if ((Ue & 6) !== 0) throw Error(n(327));
    c = o.finishedWork;
    var v = o.finishedLanes;
    if (c === null) return null;
    if (o.finishedWork = null, o.finishedLanes = 0, c === o.current) throw Error(n(177));
    o.callbackNode = null, o.callbackPriority = 0;
    var y = c.lanes | c.childLanes;
    if (gP(o, y), o === Ct && (ct = Ct = null, Rt = 0), (c.subtreeFlags & 2064) === 0 && (c.flags & 2064) === 0 || Ac || (Ac = !0, HC(_u, function() {
      return Qo(), null;
    })), y = (c.flags & 15990) !== 0, (c.subtreeFlags & 15990) !== 0 || y) {
      y = bn.transition, bn.transition = null;
      var k = Ke;
      Ke = 1;
      var N = Ue;
      Ue |= 4, wp.current = null, VM(o, c), _C(c, o), nM(Th), Nu = !!Rh, Th = Rh = null, o.current = c, _M(c), aP(), Ue = N, Ke = k, bn.transition = y;
    } else o.current = c;
    if (Ac && (Ac = !1, ri = o, xc = v), y = o.pendingLanes, y === 0 && (ni = null), cP(c.stateNode), Yt(o, st()), a !== null) for (p = o.onRecoverableError, c = 0; c < a.length; c++) v = a[c], p(v.value, { componentStack: v.stack, digest: v.digest });
    if (Ec) throw Ec = !1, o = Ep, Ep = null, o;
    return (xc & 1) !== 0 && o.tag !== 0 && Qo(), y = o.pendingLanes, (y & 1) !== 0 ? o === Ap ? ll++ : (ll = 0, Ap = o) : ll = 0, Qr(), null;
  }
  function Qo() {
    if (ri !== null) {
      var o = $b(xc), a = bn.transition, c = Ke;
      try {
        if (bn.transition = null, Ke = 16 > o ? 16 : o, ri === null) var p = !1;
        else {
          if (o = ri, ri = null, xc = 0, (Ue & 6) !== 0) throw Error(n(331));
          var v = Ue;
          for (Ue |= 4, ge = o.current; ge !== null; ) {
            var y = ge, k = y.child;
            if ((ge.flags & 16) !== 0) {
              var N = y.deletions;
              if (N !== null) {
                for (var F = 0; F < N.length; F++) {
                  var X = N[F];
                  for (ge = X; ge !== null; ) {
                    var oe = ge;
                    switch (oe.tag) {
                      case 0:
                      case 11:
                      case 15:
                        ol(8, oe, y);
                    }
                    var ae = oe.child;
                    if (ae !== null) ae.return = oe, ge = ae;
                    else for (; ge !== null; ) {
                      oe = ge;
                      var ie = oe.sibling, me = oe.return;
                      if (kC(oe), oe === X) {
                        ge = null;
                        break;
                      }
                      if (ie !== null) {
                        ie.return = me, ge = ie;
                        break;
                      }
                      ge = me;
                    }
                  }
                }
                var ye = y.alternate;
                if (ye !== null) {
                  var we = ye.child;
                  if (we !== null) {
                    ye.child = null;
                    do {
                      var at = we.sibling;
                      we.sibling = null, we = at;
                    } while (we !== null);
                  }
                }
                ge = y;
              }
            }
            if ((y.subtreeFlags & 2064) !== 0 && k !== null) k.return = y, ge = k;
            else e: for (; ge !== null; ) {
              if (y = ge, (y.flags & 2048) !== 0) switch (y.tag) {
                case 0:
                case 11:
                case 15:
                  ol(9, y, y.return);
              }
              var z = y.sibling;
              if (z !== null) {
                z.return = y.return, ge = z;
                break e;
              }
              ge = y.return;
            }
          }
          var U = o.current;
          for (ge = U; ge !== null; ) {
            k = ge;
            var K = k.child;
            if ((k.subtreeFlags & 2064) !== 0 && K !== null) K.return = k, ge = K;
            else e: for (k = U; ge !== null; ) {
              if (N = ge, (N.flags & 2048) !== 0) try {
                switch (N.tag) {
                  case 0:
                  case 11:
                  case 15:
                    wc(9, N);
                }
              } catch (be) {
                tt(N, N.return, be);
              }
              if (N === k) {
                ge = null;
                break e;
              }
              var ue = N.sibling;
              if (ue !== null) {
                ue.return = N.return, ge = ue;
                break e;
              }
              ge = N.return;
            }
          }
          if (Ue = v, Qr(), Qn && typeof Qn.onPostCommitFiberRoot == "function") try {
            Qn.onPostCommitFiberRoot(Iu, o);
          } catch {
          }
          p = !0;
        }
        return p;
      } finally {
        Ke = c, bn.transition = a;
      }
    }
    return !1;
  }
  function UC(o, a, c) {
    a = Yo(c, a), a = sC(o, a, 1), o = ei(o, a, 1), a = Ot(), o !== null && (Ia(o, 1, a), Yt(o, a));
  }
  function tt(o, a, c) {
    if (o.tag === 3) UC(o, o, c);
    else for (; a !== null; ) {
      if (a.tag === 3) {
        UC(a, o, c);
        break;
      } else if (a.tag === 1) {
        var p = a.stateNode;
        if (typeof a.type.getDerivedStateFromError == "function" || typeof p.componentDidCatch == "function" && (ni === null || !ni.has(p))) {
          o = Yo(c, o), o = aC(a, o, 1), a = ei(a, o, 1), o = Ot(), a !== null && (Ia(a, 1, o), Yt(a, o));
          break;
        }
      }
      a = a.return;
    }
  }
  function BM(o, a, c) {
    var p = o.pingCache;
    p !== null && p.delete(a), a = Ot(), o.pingedLanes |= o.suspendedLanes & c, Ct === o && (Rt & c) === c && (gt === 4 || gt === 3 && (Rt & 130023424) === Rt && 500 > st() - Cp ? Mi(o, 0) : bp |= c), Yt(o, a);
  }
  function WC(o, a) {
    a === 0 && ((o.mode & 1) === 0 ? a = 1 : (a = Pu, Pu <<= 1, (Pu & 130023424) === 0 && (Pu = 4194304)));
    var c = Ot();
    o = br(o, a), o !== null && (Ia(o, a, c), Yt(o, c));
  }
  function NM(o) {
    var a = o.memoizedState, c = 0;
    a !== null && (c = a.retryLane), WC(o, c);
  }
  function DM(o, a) {
    var c = 0;
    switch (o.tag) {
      case 13:
        var p = o.stateNode, v = o.memoizedState;
        v !== null && (c = v.retryLane);
        break;
      case 19:
        p = o.stateNode;
        break;
      default:
        throw Error(n(314));
    }
    p !== null && p.delete(a), WC(o, c);
  }
  var zC;
  zC = function(o, a, c) {
    if (o !== null) if (o.memoizedProps !== a.pendingProps || zt.current) Kt = !0;
    else {
      if ((o.lanes & c) === 0 && (a.flags & 128) === 0) return Kt = !1, kM(o, a, c);
      Kt = (o.flags & 131072) !== 0;
    }
    else Kt = !1, Qe && (a.flags & 1048576) !== 0 && A1(a, nc, a.index);
    switch (a.lanes = 0, a.tag) {
      case 2:
        var p = a.type;
        vc(o, a), o = a.pendingProps;
        var v = jo(a, $t.current);
        Ko(a, c), v = Qh(null, a, p, o, v, c);
        var y = Jh();
        return a.flags |= 1, typeof v == "object" && v !== null && typeof v.render == "function" && v.$$typeof === void 0 ? (a.tag = 1, a.memoizedState = null, a.updateQueue = null, Ht(p) ? (y = !0, Ju(a)) : y = !1, a.memoizedState = v.state !== null && v.state !== void 0 ? v.state : null, Hh(a), v.updater = mc, a.stateNode = v, v._reactInternals = a, op(a, p, o, c), a = up(null, a, p, !0, y, c)) : (a.tag = 0, Qe && y && Mh(a), Mt(null, a, v, c), a = a.child), a;
      case 16:
        p = a.elementType;
        e: {
          switch (vc(o, a), o = a.pendingProps, v = p._init, p = v(p._payload), a.type = p, v = a.tag = FM(p), o = On(p, o), v) {
            case 0:
              a = lp(null, a, p, o, c);
              break e;
            case 1:
              a = gC(null, a, p, o, c);
              break e;
            case 11:
              a = dC(null, a, p, o, c);
              break e;
            case 14:
              a = fC(null, a, p, On(p.type, o), c);
              break e;
          }
          throw Error(n(
            306,
            p,
            ""
          ));
        }
        return a;
      case 0:
        return p = a.type, v = a.pendingProps, v = a.elementType === p ? v : On(p, v), lp(o, a, p, v, c);
      case 1:
        return p = a.type, v = a.pendingProps, v = a.elementType === p ? v : On(p, v), gC(o, a, p, v, c);
      case 3:
        e: {
          if (vC(a), o === null) throw Error(n(387));
          p = a.pendingProps, y = a.memoizedState, v = y.element, I1(o, a), lc(a, p, null, c);
          var k = a.memoizedState;
          if (p = k.element, y.isDehydrated) if (y = { element: p, isDehydrated: !1, cache: k.cache, pendingSuspenseBoundaries: k.pendingSuspenseBoundaries, transitions: k.transitions }, a.updateQueue.baseState = y, a.memoizedState = y, a.flags & 256) {
            v = Yo(Error(n(423)), a), a = yC(o, a, p, c, v);
            break e;
          } else if (p !== v) {
            v = Yo(Error(n(424)), a), a = yC(o, a, p, c, v);
            break e;
          } else for (sn = qr(a.stateNode.containerInfo.firstChild), on = a, Qe = !0, Mn = null, c = V1(a, null, p, c), a.child = c; c; ) c.flags = c.flags & -3 | 4096, c = c.sibling;
          else {
            if (Wo(), p === v) {
              a = Er(o, a, c);
              break e;
            }
            Mt(o, a, p, c);
          }
          a = a.child;
        }
        return a;
      case 5:
        return M1(a), o === null && Nh(a), p = a.type, v = a.pendingProps, y = o !== null ? o.memoizedProps : null, k = v.children, $h(p, v) ? k = null : y !== null && $h(p, y) && (a.flags |= 32), mC(o, a), Mt(o, a, k, c), a.child;
      case 6:
        return o === null && Nh(a), null;
      case 13:
        return wC(o, a, c);
      case 4:
        return Kh(a, a.stateNode.containerInfo), p = a.pendingProps, o === null ? a.child = zo(a, null, p, c) : Mt(o, a, p, c), a.child;
      case 11:
        return p = a.type, v = a.pendingProps, v = a.elementType === p ? v : On(p, v), dC(o, a, p, v, c);
      case 7:
        return Mt(o, a, a.pendingProps, c), a.child;
      case 8:
        return Mt(o, a, a.pendingProps.children, c), a.child;
      case 12:
        return Mt(o, a, a.pendingProps.children, c), a.child;
      case 10:
        e: {
          if (p = a.type._context, v = a.pendingProps, y = a.memoizedProps, k = v.value, Ge(oc, p._currentValue), p._currentValue = k, y !== null) if (Pn(y.value, k)) {
            if (y.children === v.children && !zt.current) {
              a = Er(o, a, c);
              break e;
            }
          } else for (y = a.child, y !== null && (y.return = a); y !== null; ) {
            var N = y.dependencies;
            if (N !== null) {
              k = y.child;
              for (var F = N.firstContext; F !== null; ) {
                if (F.context === p) {
                  if (y.tag === 1) {
                    F = Cr(-1, c & -c), F.tag = 2;
                    var X = y.updateQueue;
                    if (X !== null) {
                      X = X.shared;
                      var oe = X.pending;
                      oe === null ? F.next = F : (F.next = oe.next, oe.next = F), X.pending = F;
                    }
                  }
                  y.lanes |= c, F = y.alternate, F !== null && (F.lanes |= c), Wh(
                    y.return,
                    c,
                    a
                  ), N.lanes |= c;
                  break;
                }
                F = F.next;
              }
            } else if (y.tag === 10) k = y.type === a.type ? null : y.child;
            else if (y.tag === 18) {
              if (k = y.return, k === null) throw Error(n(341));
              k.lanes |= c, N = k.alternate, N !== null && (N.lanes |= c), Wh(k, c, a), k = y.sibling;
            } else k = y.child;
            if (k !== null) k.return = y;
            else for (k = y; k !== null; ) {
              if (k === a) {
                k = null;
                break;
              }
              if (y = k.sibling, y !== null) {
                y.return = k.return, k = y;
                break;
              }
              k = k.return;
            }
            y = k;
          }
          Mt(o, a, v.children, c), a = a.child;
        }
        return a;
      case 9:
        return v = a.type, p = a.pendingProps.children, Ko(a, c), v = yn(v), p = p(v), a.flags |= 1, Mt(o, a, p, c), a.child;
      case 14:
        return p = a.type, v = On(p, a.pendingProps), v = On(p.type, v), fC(o, a, p, v, c);
      case 15:
        return hC(o, a, a.type, a.pendingProps, c);
      case 17:
        return p = a.type, v = a.pendingProps, v = a.elementType === p ? v : On(p, v), vc(o, a), a.tag = 1, Ht(p) ? (o = !0, Ju(a)) : o = !1, Ko(a, c), iC(a, p, v), op(a, p, v, c), up(null, a, p, !0, o, c);
      case 19:
        return CC(o, a, c);
      case 22:
        return pC(o, a, c);
    }
    throw Error(n(156, a.tag));
  };
  function HC(o, a) {
    return xb(o, a);
  }
  function jM(o, a, c, p) {
    this.tag = o, this.key = c, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = a, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = p, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function Cn(o, a, c, p) {
    return new jM(o, a, c, p);
  }
  function $p(o) {
    return o = o.prototype, !(!o || !o.isReactComponent);
  }
  function FM(o) {
    if (typeof o == "function") return $p(o) ? 1 : 0;
    if (o != null) {
      if (o = o.$$typeof, o === fe) return 11;
      if (o === le) return 14;
    }
    return 2;
  }
  function si(o, a) {
    var c = o.alternate;
    return c === null ? (c = Cn(o.tag, a, o.key, o.mode), c.elementType = o.elementType, c.type = o.type, c.stateNode = o.stateNode, c.alternate = o, o.alternate = c) : (c.pendingProps = a, c.type = o.type, c.flags = 0, c.subtreeFlags = 0, c.deletions = null), c.flags = o.flags & 14680064, c.childLanes = o.childLanes, c.lanes = o.lanes, c.child = o.child, c.memoizedProps = o.memoizedProps, c.memoizedState = o.memoizedState, c.updateQueue = o.updateQueue, a = o.dependencies, c.dependencies = a === null ? null : { lanes: a.lanes, firstContext: a.firstContext }, c.sibling = o.sibling, c.index = o.index, c.ref = o.ref, c;
  }
  function Tc(o, a, c, p, v, y) {
    var k = 2;
    if (p = o, typeof o == "function") $p(o) && (k = 1);
    else if (typeof o == "string") k = 5;
    else e: switch (o) {
      case D:
        return Bi(c.children, v, y, a);
      case B:
        k = 8, v |= 8;
        break;
      case H:
        return o = Cn(12, c, a, v | 2), o.elementType = H, o.lanes = y, o;
      case de:
        return o = Cn(13, c, a, v), o.elementType = de, o.lanes = y, o;
      case he:
        return o = Cn(19, c, a, v), o.elementType = he, o.lanes = y, o;
      case te:
        return $c(c, v, y, a);
      default:
        if (typeof o == "object" && o !== null) switch (o.$$typeof) {
          case J:
            k = 10;
            break e;
          case ce:
            k = 9;
            break e;
          case fe:
            k = 11;
            break e;
          case le:
            k = 14;
            break e;
          case Y:
            k = 16, p = null;
            break e;
        }
        throw Error(n(130, o == null ? o : typeof o, ""));
    }
    return a = Cn(k, c, a, v), a.elementType = o, a.type = p, a.lanes = y, a;
  }
  function Bi(o, a, c, p) {
    return o = Cn(7, o, p, a), o.lanes = c, o;
  }
  function $c(o, a, c, p) {
    return o = Cn(22, o, p, a), o.elementType = te, o.lanes = c, o.stateNode = { isHidden: !1 }, o;
  }
  function Vp(o, a, c) {
    return o = Cn(6, o, null, a), o.lanes = c, o;
  }
  function _p(o, a, c) {
    return a = Cn(4, o.children !== null ? o.children : [], o.key, a), a.lanes = c, a.stateNode = { containerInfo: o.containerInfo, pendingChildren: null, implementation: o.implementation }, a;
  }
  function UM(o, a, c, p, v) {
    this.tag = a, this.containerInfo = o, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = ih(0), this.expirationTimes = ih(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = ih(0), this.identifierPrefix = p, this.onRecoverableError = v, this.mutableSourceEagerHydrationData = null;
  }
  function Ip(o, a, c, p, v, y, k, N, F) {
    return o = new UM(o, a, c, N, F), a === 1 ? (a = 1, y === !0 && (a |= 8)) : a = 0, y = Cn(3, null, null, a), o.current = y, y.stateNode = o, y.memoizedState = { element: p, isDehydrated: c, cache: null, transitions: null, pendingSuspenseBoundaries: null }, Hh(y), o;
  }
  function WM(o, a, c) {
    var p = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return { $$typeof: O, key: p == null ? null : "" + p, children: o, containerInfo: a, implementation: c };
  }
  function KC(o) {
    if (!o) return Zr;
    o = o._reactInternals;
    e: {
      if (Si(o) !== o || o.tag !== 1) throw Error(n(170));
      var a = o;
      do {
        switch (a.tag) {
          case 3:
            a = a.stateNode.context;
            break e;
          case 1:
            if (Ht(a.type)) {
              a = a.stateNode.__reactInternalMemoizedMergedChildContext;
              break e;
            }
        }
        a = a.return;
      } while (a !== null);
      throw Error(n(171));
    }
    if (o.tag === 1) {
      var c = o.type;
      if (Ht(c)) return b1(o, c, a);
    }
    return a;
  }
  function GC(o, a, c, p, v, y, k, N, F) {
    return o = Ip(c, p, !0, o, v, y, k, N, F), o.context = KC(null), c = o.current, p = Ot(), v = ii(c), y = Cr(p, v), y.callback = a ?? null, ei(c, y, v), o.current.lanes = v, Ia(o, v, p), Yt(o, p), o;
  }
  function Vc(o, a, c, p) {
    var v = a.current, y = Ot(), k = ii(v);
    return c = KC(c), a.context === null ? a.context = c : a.pendingContext = c, a = Cr(y, k), a.payload = { element: o }, p = p === void 0 ? null : p, p !== null && (a.callback = p), o = ei(v, a, k), o !== null && (Dn(o, v, k, y), ac(o, v, k)), k;
  }
  function _c(o) {
    if (o = o.current, !o.child) return null;
    switch (o.child.tag) {
      case 5:
        return o.child.stateNode;
      default:
        return o.child.stateNode;
    }
  }
  function YC(o, a) {
    if (o = o.memoizedState, o !== null && o.dehydrated !== null) {
      var c = o.retryLane;
      o.retryLane = c !== 0 && c < a ? c : a;
    }
  }
  function Lp(o, a) {
    YC(o, a), (o = o.alternate) && YC(o, a);
  }
  function zM() {
    return null;
  }
  var qC = typeof reportError == "function" ? reportError : function(o) {
    console.error(o);
  };
  function Pp(o) {
    this._internalRoot = o;
  }
  Ic.prototype.render = Pp.prototype.render = function(o) {
    var a = this._internalRoot;
    if (a === null) throw Error(n(409));
    Vc(o, a, null, null);
  }, Ic.prototype.unmount = Pp.prototype.unmount = function() {
    var o = this._internalRoot;
    if (o !== null) {
      this._internalRoot = null;
      var a = o.containerInfo;
      Pi(function() {
        Vc(null, o, null, null);
      }), a[gr] = null;
    }
  };
  function Ic(o) {
    this._internalRoot = o;
  }
  Ic.prototype.unstable_scheduleHydration = function(o) {
    if (o) {
      var a = Ib();
      o = { blockedOn: null, target: o, priority: a };
      for (var c = 0; c < Kr.length && a !== 0 && a < Kr[c].priority; c++) ;
      Kr.splice(c, 0, o), c === 0 && Mb(o);
    }
  };
  function Mp(o) {
    return !(!o || o.nodeType !== 1 && o.nodeType !== 9 && o.nodeType !== 11);
  }
  function Lc(o) {
    return !(!o || o.nodeType !== 1 && o.nodeType !== 9 && o.nodeType !== 11 && (o.nodeType !== 8 || o.nodeValue !== " react-mount-point-unstable "));
  }
  function XC() {
  }
  function HM(o, a, c, p, v) {
    if (v) {
      if (typeof p == "function") {
        var y = p;
        p = function() {
          var X = _c(k);
          y.call(X);
        };
      }
      var k = GC(a, p, o, 0, null, !1, !1, "", XC);
      return o._reactRootContainer = k, o[gr] = k.current, Ka(o.nodeType === 8 ? o.parentNode : o), Pi(), k;
    }
    for (; v = o.lastChild; ) o.removeChild(v);
    if (typeof p == "function") {
      var N = p;
      p = function() {
        var X = _c(F);
        N.call(X);
      };
    }
    var F = Ip(o, 0, !1, null, null, !1, !1, "", XC);
    return o._reactRootContainer = F, o[gr] = F.current, Ka(o.nodeType === 8 ? o.parentNode : o), Pi(function() {
      Vc(a, F, c, p);
    }), F;
  }
  function Pc(o, a, c, p, v) {
    var y = c._reactRootContainer;
    if (y) {
      var k = y;
      if (typeof v == "function") {
        var N = v;
        v = function() {
          var F = _c(k);
          N.call(F);
        };
      }
      Vc(a, k, o, v);
    } else k = HM(c, a, o, v, p);
    return _c(k);
  }
  Vb = function(o) {
    switch (o.tag) {
      case 3:
        var a = o.stateNode;
        if (a.current.memoizedState.isDehydrated) {
          var c = _a(a.pendingLanes);
          c !== 0 && (oh(a, c | 1), Yt(a, st()), (Ue & 6) === 0 && (Zo = st() + 500, Qr()));
        }
        break;
      case 13:
        Pi(function() {
          var p = br(o, 1);
          if (p !== null) {
            var v = Ot();
            Dn(p, o, 1, v);
          }
        }), Lp(o, 1);
    }
  }, sh = function(o) {
    if (o.tag === 13) {
      var a = br(o, 134217728);
      if (a !== null) {
        var c = Ot();
        Dn(a, o, 134217728, c);
      }
      Lp(o, 134217728);
    }
  }, _b = function(o) {
    if (o.tag === 13) {
      var a = ii(o), c = br(o, a);
      if (c !== null) {
        var p = Ot();
        Dn(c, o, a, p);
      }
      Lp(o, a);
    }
  }, Ib = function() {
    return Ke;
  }, Lb = function(o, a) {
    var c = Ke;
    try {
      return Ke = o, a();
    } finally {
      Ke = c;
    }
  }, Qf = function(o, a, c) {
    switch (a) {
      case "input":
        if (mn(o, c), a = c.name, c.type === "radio" && a != null) {
          for (c = o; c.parentNode; ) c = c.parentNode;
          for (c = c.querySelectorAll("input[name=" + JSON.stringify("" + a) + '][type="radio"]'), a = 0; a < c.length; a++) {
            var p = c[a];
            if (p !== o && p.form === o.form) {
              var v = Zu(p);
              if (!v) throw Error(n(90));
              ze(p), mn(p, v);
            }
          }
        }
        break;
      case "textarea":
        Ro(o, c);
        break;
      case "select":
        a = c.value, a != null && In(o, !!c.multiple, a, !1);
    }
  }, vb = kp, yb = Pi;
  var KM = { usingClientEntryPoint: !1, Events: [qa, No, Zu, mb, gb, kp] }, ul = { findFiberByHostInstance: ki, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" }, GM = { bundleType: ul.bundleType, version: ul.version, rendererPackageName: ul.rendererPackageName, rendererConfig: ul.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: L.ReactCurrentDispatcher, findHostInstanceByFiber: function(o) {
    return o = Eb(o), o === null ? null : o.stateNode;
  }, findFiberByHostInstance: ul.findFiberByHostInstance || zM, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var Mc = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!Mc.isDisabled && Mc.supportsFiber) try {
      Iu = Mc.inject(GM), Qn = Mc;
    } catch {
    }
  }
  return Xt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = KM, Xt.createPortal = function(o, a) {
    var c = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!Mp(a)) throw Error(n(200));
    return WM(o, a, null, c);
  }, Xt.createRoot = function(o, a) {
    if (!Mp(o)) throw Error(n(299));
    var c = !1, p = "", v = qC;
    return a != null && (a.unstable_strictMode === !0 && (c = !0), a.identifierPrefix !== void 0 && (p = a.identifierPrefix), a.onRecoverableError !== void 0 && (v = a.onRecoverableError)), a = Ip(o, 1, !1, null, null, c, !1, p, v), o[gr] = a.current, Ka(o.nodeType === 8 ? o.parentNode : o), new Pp(a);
  }, Xt.findDOMNode = function(o) {
    if (o == null) return null;
    if (o.nodeType === 1) return o;
    var a = o._reactInternals;
    if (a === void 0)
      throw typeof o.render == "function" ? Error(n(188)) : (o = Object.keys(o).join(","), Error(n(268, o)));
    return o = Eb(a), o = o === null ? null : o.stateNode, o;
  }, Xt.flushSync = function(o) {
    return Pi(o);
  }, Xt.hydrate = function(o, a, c) {
    if (!Lc(a)) throw Error(n(200));
    return Pc(null, o, a, !0, c);
  }, Xt.hydrateRoot = function(o, a, c) {
    if (!Mp(o)) throw Error(n(405));
    var p = c != null && c.hydratedSources || null, v = !1, y = "", k = qC;
    if (c != null && (c.unstable_strictMode === !0 && (v = !0), c.identifierPrefix !== void 0 && (y = c.identifierPrefix), c.onRecoverableError !== void 0 && (k = c.onRecoverableError)), a = GC(a, null, o, 1, c ?? null, v, !1, y, k), o[gr] = a.current, Ka(o), p) for (o = 0; o < p.length; o++) c = p[o], v = c._getVersion, v = v(c._source), a.mutableSourceEagerHydrationData == null ? a.mutableSourceEagerHydrationData = [c, v] : a.mutableSourceEagerHydrationData.push(
      c,
      v
    );
    return new Ic(a);
  }, Xt.render = function(o, a, c) {
    if (!Lc(a)) throw Error(n(200));
    return Pc(null, o, a, !1, c);
  }, Xt.unmountComponentAtNode = function(o) {
    if (!Lc(o)) throw Error(n(40));
    return o._reactRootContainer ? (Pi(function() {
      Pc(null, null, o, !1, function() {
        o._reactRootContainer = null, o[gr] = null;
      });
    }), !0) : !1;
  }, Xt.unstable_batchedUpdates = kp, Xt.unstable_renderSubtreeIntoContainer = function(o, a, c, p) {
    if (!Lc(c)) throw Error(n(200));
    if (o == null || o._reactInternals === void 0) throw Error(n(38));
    return Pc(o, a, c, !1, p);
  }, Xt.version = "18.3.1-next-f1338f8080-20240426", Xt;
}
var mA;
function KR() {
  if (mA) return om.exports;
  mA = 1;
  function e() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e);
      } catch (t) {
        console.error(t);
      }
  }
  return e(), om.exports = ZF(), om.exports;
}
var Oy = KR();
const QF = /* @__PURE__ */ ru(Oy);
// @__NO_SIDE_EFFECTS__
function Bs(e) {
  const t = /* @__PURE__ */ JF(e), n = C.forwardRef((r, i) => {
    const { children: s, ...l } = r, u = C.Children.toArray(s), d = u.find(t4);
    if (d) {
      const h = d.props.children, f = u.map((m) => m === d ? C.Children.count(h) > 1 ? C.Children.only(null) : C.isValidElement(h) ? h.props.children : null : m);
      return /* @__PURE__ */ I.jsx(t, { ...l, ref: i, children: C.isValidElement(h) ? C.cloneElement(h, void 0, f) : null });
    }
    return /* @__PURE__ */ I.jsx(t, { ...l, ref: i, children: s });
  });
  return n.displayName = `${e}.Slot`, n;
}
var GR = /* @__PURE__ */ Bs("Slot");
// @__NO_SIDE_EFFECTS__
function JF(e) {
  const t = C.forwardRef((n, r) => {
    const { children: i, ...s } = n;
    if (C.isValidElement(i)) {
      const l = r4(i), u = n4(s, i.props);
      return i.type !== C.Fragment && (u.ref = r ? pf(r, l) : l), C.cloneElement(i, u);
    }
    return C.Children.count(i) > 1 ? C.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var YR = Symbol("radix.slottable");
// @__NO_SIDE_EFFECTS__
function e4(e) {
  const t = ({ children: n }) => /* @__PURE__ */ I.jsx(I.Fragment, { children: n });
  return t.displayName = `${e}.Slottable`, t.__radixId = YR, t;
}
function t4(e) {
  return C.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === YR;
}
function n4(e, t) {
  const n = { ...t };
  for (const r in t) {
    const i = e[r], s = t[r];
    /^on[A-Z]/.test(r) ? i && s ? n[r] = (...u) => {
      const d = s(...u);
      return i(...u), d;
    } : i && (n[r] = i) : r === "style" ? n[r] = { ...i, ...s } : r === "className" && (n[r] = [i, s].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function r4(e) {
  var r, i;
  let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = (i = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : i.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var i4 = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
], ut = i4.reduce((e, t) => {
  const n = /* @__PURE__ */ Bs(`Primitive.${t}`), r = C.forwardRef((i, s) => {
    const { asChild: l, ...u } = i, d = l ? n : t;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ I.jsx(d, { ...u, ref: s });
  });
  return r.displayName = `Primitive.${t}`, { ...e, [t]: r };
}, {});
function qR(e, t) {
  e && Oy.flushSync(() => e.dispatchEvent(t));
}
function Mr(e) {
  const t = C.useRef(e);
  return C.useEffect(() => {
    t.current = e;
  }), C.useMemo(() => (...n) => {
    var r;
    return (r = t.current) == null ? void 0 : r.call(t, ...n);
  }, []);
}
function o4(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = Mr(e);
  C.useEffect(() => {
    const r = (i) => {
      i.key === "Escape" && n(i);
    };
    return t.addEventListener("keydown", r, { capture: !0 }), () => t.removeEventListener("keydown", r, { capture: !0 });
  }, [n, t]);
}
var s4 = "DismissableLayer", ug = "dismissableLayer.update", a4 = "dismissableLayer.pointerDownOutside", l4 = "dismissableLayer.focusOutside", gA, XR = C.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
}), fu = C.forwardRef(
  (e, t) => {
    const {
      disableOutsidePointerEvents: n = !1,
      onEscapeKeyDown: r,
      onPointerDownOutside: i,
      onFocusOutside: s,
      onInteractOutside: l,
      onDismiss: u,
      ...d
    } = e, h = C.useContext(XR), [f, m] = C.useState(null), g = (f == null ? void 0 : f.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), [, w] = C.useState({}), E = wt(t, (D) => m(D)), b = Array.from(h.layers), [A] = [...h.layersWithOutsidePointerEventsDisabled].slice(-1), x = b.indexOf(A), R = f ? b.indexOf(f) : -1, _ = h.layersWithOutsidePointerEventsDisabled.size > 0, L = R >= x, V = d4((D) => {
      const B = D.target, H = [...h.branches].some((J) => J.contains(B));
      !L || H || (i == null || i(D), l == null || l(D), D.defaultPrevented || u == null || u());
    }, g), O = f4((D) => {
      const B = D.target;
      [...h.branches].some((J) => J.contains(B)) || (s == null || s(D), l == null || l(D), D.defaultPrevented || u == null || u());
    }, g);
    return o4((D) => {
      R === h.layers.size - 1 && (r == null || r(D), !D.defaultPrevented && u && (D.preventDefault(), u()));
    }, g), C.useEffect(() => {
      if (f)
        return n && (h.layersWithOutsidePointerEventsDisabled.size === 0 && (gA = g.body.style.pointerEvents, g.body.style.pointerEvents = "none"), h.layersWithOutsidePointerEventsDisabled.add(f)), h.layers.add(f), vA(), () => {
          n && h.layersWithOutsidePointerEventsDisabled.size === 1 && (g.body.style.pointerEvents = gA);
        };
    }, [f, g, n, h]), C.useEffect(() => () => {
      f && (h.layers.delete(f), h.layersWithOutsidePointerEventsDisabled.delete(f), vA());
    }, [f, h]), C.useEffect(() => {
      const D = () => w({});
      return document.addEventListener(ug, D), () => document.removeEventListener(ug, D);
    }, []), /* @__PURE__ */ I.jsx(
      ut.div,
      {
        ...d,
        ref: E,
        style: {
          pointerEvents: _ ? L ? "auto" : "none" : void 0,
          ...e.style
        },
        onFocusCapture: Le(e.onFocusCapture, O.onFocusCapture),
        onBlurCapture: Le(e.onBlurCapture, O.onBlurCapture),
        onPointerDownCapture: Le(
          e.onPointerDownCapture,
          V.onPointerDownCapture
        )
      }
    );
  }
);
fu.displayName = s4;
var u4 = "DismissableLayerBranch", c4 = C.forwardRef((e, t) => {
  const n = C.useContext(XR), r = C.useRef(null), i = wt(t, r);
  return C.useEffect(() => {
    const s = r.current;
    if (s)
      return n.branches.add(s), () => {
        n.branches.delete(s);
      };
  }, [n.branches]), /* @__PURE__ */ I.jsx(ut.div, { ...e, ref: i });
});
c4.displayName = u4;
function d4(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = Mr(e), r = C.useRef(!1), i = C.useRef(() => {
  });
  return C.useEffect(() => {
    const s = (u) => {
      if (u.target && !r.current) {
        let d = function() {
          ZR(
            a4,
            n,
            h,
            { discrete: !0 }
          );
        };
        const h = { originalEvent: u };
        u.pointerType === "touch" ? (t.removeEventListener("click", i.current), i.current = d, t.addEventListener("click", i.current, { once: !0 })) : d();
      } else
        t.removeEventListener("click", i.current);
      r.current = !1;
    }, l = window.setTimeout(() => {
      t.addEventListener("pointerdown", s);
    }, 0);
    return () => {
      window.clearTimeout(l), t.removeEventListener("pointerdown", s), t.removeEventListener("click", i.current);
    };
  }, [t, n]), {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => r.current = !0
  };
}
function f4(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = Mr(e), r = C.useRef(!1);
  return C.useEffect(() => {
    const i = (s) => {
      s.target && !r.current && ZR(l4, n, { originalEvent: s }, {
        discrete: !1
      });
    };
    return t.addEventListener("focusin", i), () => t.removeEventListener("focusin", i);
  }, [t, n]), {
    onFocusCapture: () => r.current = !0,
    onBlurCapture: () => r.current = !1
  };
}
function vA() {
  const e = new CustomEvent(ug);
  document.dispatchEvent(e);
}
function ZR(e, t, n, { discrete: r }) {
  const i = n.originalEvent.target, s = new CustomEvent(e, { bubbles: !1, cancelable: !0, detail: n });
  t && i.addEventListener(e, t, { once: !0 }), r ? qR(i, s) : i.dispatchEvent(s);
}
var bi = globalThis != null && globalThis.document ? C.useLayoutEffect : () => {
}, h4 = Dv[" useId ".trim().toString()] || (() => {
}), p4 = 0;
function Rl(e) {
  const [t, n] = C.useState(h4());
  return bi(() => {
    n((r) => r ?? String(p4++));
  }, [e]), t ? `radix-${t}` : "";
}
const m4 = ["top", "right", "bottom", "left"], Ci = Math.min, dn = Math.max, Vd = Math.round, Wc = Math.floor, fr = (e) => ({
  x: e,
  y: e
}), g4 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, v4 = {
  start: "end",
  end: "start"
};
function cg(e, t, n) {
  return dn(e, Ci(t, n));
}
function Or(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function Br(e) {
  return e.split("-")[0];
}
function qs(e) {
  return e.split("-")[1];
}
function By(e) {
  return e === "x" ? "y" : "x";
}
function Ny(e) {
  return e === "y" ? "height" : "width";
}
const y4 = /* @__PURE__ */ new Set(["top", "bottom"]);
function ur(e) {
  return y4.has(Br(e)) ? "y" : "x";
}
function Dy(e) {
  return By(ur(e));
}
function w4(e, t, n) {
  n === void 0 && (n = !1);
  const r = qs(e), i = Dy(e), s = Ny(i);
  let l = i === "x" ? r === (n ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
  return t.reference[s] > t.floating[s] && (l = _d(l)), [l, _d(l)];
}
function b4(e) {
  const t = _d(e);
  return [dg(e), t, dg(t)];
}
function dg(e) {
  return e.replace(/start|end/g, (t) => v4[t]);
}
const yA = ["left", "right"], wA = ["right", "left"], C4 = ["top", "bottom"], E4 = ["bottom", "top"];
function A4(e, t, n) {
  switch (e) {
    case "top":
    case "bottom":
      return n ? t ? wA : yA : t ? yA : wA;
    case "left":
    case "right":
      return t ? C4 : E4;
    default:
      return [];
  }
}
function x4(e, t, n, r) {
  const i = qs(e);
  let s = A4(Br(e), n === "start", r);
  return i && (s = s.map((l) => l + "-" + i), t && (s = s.concat(s.map(dg)))), s;
}
function _d(e) {
  return e.replace(/left|right|bottom|top/g, (t) => g4[t]);
}
function S4(e) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...e
  };
}
function QR(e) {
  return typeof e != "number" ? S4(e) : {
    top: e,
    right: e,
    bottom: e,
    left: e
  };
}
function Id(e) {
  const {
    x: t,
    y: n,
    width: r,
    height: i
  } = e;
  return {
    width: r,
    height: i,
    top: n,
    left: t,
    right: t + r,
    bottom: n + i,
    x: t,
    y: n
  };
}
function bA(e, t, n) {
  let {
    reference: r,
    floating: i
  } = e;
  const s = ur(t), l = Dy(t), u = Ny(l), d = Br(t), h = s === "y", f = r.x + r.width / 2 - i.width / 2, m = r.y + r.height / 2 - i.height / 2, g = r[u] / 2 - i[u] / 2;
  let w;
  switch (d) {
    case "top":
      w = {
        x: f,
        y: r.y - i.height
      };
      break;
    case "bottom":
      w = {
        x: f,
        y: r.y + r.height
      };
      break;
    case "right":
      w = {
        x: r.x + r.width,
        y: m
      };
      break;
    case "left":
      w = {
        x: r.x - i.width,
        y: m
      };
      break;
    default:
      w = {
        x: r.x,
        y: r.y
      };
  }
  switch (qs(t)) {
    case "start":
      w[l] -= g * (n && h ? -1 : 1);
      break;
    case "end":
      w[l] += g * (n && h ? -1 : 1);
      break;
  }
  return w;
}
const k4 = async (e, t, n) => {
  const {
    placement: r = "bottom",
    strategy: i = "absolute",
    middleware: s = [],
    platform: l
  } = n, u = s.filter(Boolean), d = await (l.isRTL == null ? void 0 : l.isRTL(t));
  let h = await l.getElementRects({
    reference: e,
    floating: t,
    strategy: i
  }), {
    x: f,
    y: m
  } = bA(h, r, d), g = r, w = {}, E = 0;
  for (let b = 0; b < u.length; b++) {
    const {
      name: A,
      fn: x
    } = u[b], {
      x: R,
      y: _,
      data: L,
      reset: V
    } = await x({
      x: f,
      y: m,
      initialPlacement: r,
      placement: g,
      strategy: i,
      middlewareData: w,
      rects: h,
      platform: l,
      elements: {
        reference: e,
        floating: t
      }
    });
    f = R ?? f, m = _ ?? m, w = {
      ...w,
      [A]: {
        ...w[A],
        ...L
      }
    }, V && E <= 50 && (E++, typeof V == "object" && (V.placement && (g = V.placement), V.rects && (h = V.rects === !0 ? await l.getElementRects({
      reference: e,
      floating: t,
      strategy: i
    }) : V.rects), {
      x: f,
      y: m
    } = bA(h, g, d)), b = -1);
  }
  return {
    x: f,
    y: m,
    placement: g,
    strategy: i,
    middlewareData: w
  };
};
async function jl(e, t) {
  var n;
  t === void 0 && (t = {});
  const {
    x: r,
    y: i,
    platform: s,
    rects: l,
    elements: u,
    strategy: d
  } = e, {
    boundary: h = "clippingAncestors",
    rootBoundary: f = "viewport",
    elementContext: m = "floating",
    altBoundary: g = !1,
    padding: w = 0
  } = Or(t, e), E = QR(w), A = u[g ? m === "floating" ? "reference" : "floating" : m], x = Id(await s.getClippingRect({
    element: (n = await (s.isElement == null ? void 0 : s.isElement(A))) == null || n ? A : A.contextElement || await (s.getDocumentElement == null ? void 0 : s.getDocumentElement(u.floating)),
    boundary: h,
    rootBoundary: f,
    strategy: d
  })), R = m === "floating" ? {
    x: r,
    y: i,
    width: l.floating.width,
    height: l.floating.height
  } : l.reference, _ = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(u.floating)), L = await (s.isElement == null ? void 0 : s.isElement(_)) ? await (s.getScale == null ? void 0 : s.getScale(_)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, V = Id(s.convertOffsetParentRelativeRectToViewportRelativeRect ? await s.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: u,
    rect: R,
    offsetParent: _,
    strategy: d
  }) : R);
  return {
    top: (x.top - V.top + E.top) / L.y,
    bottom: (V.bottom - x.bottom + E.bottom) / L.y,
    left: (x.left - V.left + E.left) / L.x,
    right: (V.right - x.right + E.right) / L.x
  };
}
const R4 = (e) => ({
  name: "arrow",
  options: e,
  async fn(t) {
    const {
      x: n,
      y: r,
      placement: i,
      rects: s,
      platform: l,
      elements: u,
      middlewareData: d
    } = t, {
      element: h,
      padding: f = 0
    } = Or(e, t) || {};
    if (h == null)
      return {};
    const m = QR(f), g = {
      x: n,
      y: r
    }, w = Dy(i), E = Ny(w), b = await l.getDimensions(h), A = w === "y", x = A ? "top" : "left", R = A ? "bottom" : "right", _ = A ? "clientHeight" : "clientWidth", L = s.reference[E] + s.reference[w] - g[w] - s.floating[E], V = g[w] - s.reference[w], O = await (l.getOffsetParent == null ? void 0 : l.getOffsetParent(h));
    let D = O ? O[_] : 0;
    (!D || !await (l.isElement == null ? void 0 : l.isElement(O))) && (D = u.floating[_] || s.floating[E]);
    const B = L / 2 - V / 2, H = D / 2 - b[E] / 2 - 1, J = Ci(m[x], H), ce = Ci(m[R], H), fe = J, de = D - b[E] - ce, he = D / 2 - b[E] / 2 + B, le = cg(fe, he, de), Y = !d.arrow && qs(i) != null && he !== le && s.reference[E] / 2 - (he < fe ? J : ce) - b[E] / 2 < 0, te = Y ? he < fe ? he - fe : he - de : 0;
    return {
      [w]: g[w] + te,
      data: {
        [w]: le,
        centerOffset: he - le - te,
        ...Y && {
          alignmentOffset: te
        }
      },
      reset: Y
    };
  }
}), T4 = function(e) {
  return e === void 0 && (e = {}), {
    name: "flip",
    options: e,
    async fn(t) {
      var n, r;
      const {
        placement: i,
        middlewareData: s,
        rects: l,
        initialPlacement: u,
        platform: d,
        elements: h
      } = t, {
        mainAxis: f = !0,
        crossAxis: m = !0,
        fallbackPlacements: g,
        fallbackStrategy: w = "bestFit",
        fallbackAxisSideDirection: E = "none",
        flipAlignment: b = !0,
        ...A
      } = Or(e, t);
      if ((n = s.arrow) != null && n.alignmentOffset)
        return {};
      const x = Br(i), R = ur(u), _ = Br(u) === u, L = await (d.isRTL == null ? void 0 : d.isRTL(h.floating)), V = g || (_ || !b ? [_d(u)] : b4(u)), O = E !== "none";
      !g && O && V.push(...x4(u, b, E, L));
      const D = [u, ...V], B = await jl(t, A), H = [];
      let J = ((r = s.flip) == null ? void 0 : r.overflows) || [];
      if (f && H.push(B[x]), m) {
        const he = w4(i, l, L);
        H.push(B[he[0]], B[he[1]]);
      }
      if (J = [...J, {
        placement: i,
        overflows: H
      }], !H.every((he) => he <= 0)) {
        var ce, fe;
        const he = (((ce = s.flip) == null ? void 0 : ce.index) || 0) + 1, le = D[he];
        if (le && (!(m === "alignment" ? R !== ur(le) : !1) || // We leave the current main axis only if every placement on that axis
        // overflows the main axis.
        J.every((S) => ur(S.placement) === R ? S.overflows[0] > 0 : !0)))
          return {
            data: {
              index: he,
              overflows: J
            },
            reset: {
              placement: le
            }
          };
        let Y = (fe = J.filter((te) => te.overflows[0] <= 0).sort((te, S) => te.overflows[1] - S.overflows[1])[0]) == null ? void 0 : fe.placement;
        if (!Y)
          switch (w) {
            case "bestFit": {
              var de;
              const te = (de = J.filter((S) => {
                if (O) {
                  const T = ur(S.placement);
                  return T === R || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  T === "y";
                }
                return !0;
              }).map((S) => [S.placement, S.overflows.filter((T) => T > 0).reduce((T, P) => T + P, 0)]).sort((S, T) => S[1] - T[1])[0]) == null ? void 0 : de[0];
              te && (Y = te);
              break;
            }
            case "initialPlacement":
              Y = u;
              break;
          }
        if (i !== Y)
          return {
            reset: {
              placement: Y
            }
          };
      }
      return {};
    }
  };
};
function CA(e, t) {
  return {
    top: e.top - t.height,
    right: e.right - t.width,
    bottom: e.bottom - t.height,
    left: e.left - t.width
  };
}
function EA(e) {
  return m4.some((t) => e[t] >= 0);
}
const $4 = function(e) {
  return e === void 0 && (e = {}), {
    name: "hide",
    options: e,
    async fn(t) {
      const {
        rects: n
      } = t, {
        strategy: r = "referenceHidden",
        ...i
      } = Or(e, t);
      switch (r) {
        case "referenceHidden": {
          const s = await jl(t, {
            ...i,
            elementContext: "reference"
          }), l = CA(s, n.reference);
          return {
            data: {
              referenceHiddenOffsets: l,
              referenceHidden: EA(l)
            }
          };
        }
        case "escaped": {
          const s = await jl(t, {
            ...i,
            altBoundary: !0
          }), l = CA(s, n.floating);
          return {
            data: {
              escapedOffsets: l,
              escaped: EA(l)
            }
          };
        }
        default:
          return {};
      }
    }
  };
}, JR = /* @__PURE__ */ new Set(["left", "top"]);
async function V4(e, t) {
  const {
    placement: n,
    platform: r,
    elements: i
  } = e, s = await (r.isRTL == null ? void 0 : r.isRTL(i.floating)), l = Br(n), u = qs(n), d = ur(n) === "y", h = JR.has(l) ? -1 : 1, f = s && d ? -1 : 1, m = Or(t, e);
  let {
    mainAxis: g,
    crossAxis: w,
    alignmentAxis: E
  } = typeof m == "number" ? {
    mainAxis: m,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: m.mainAxis || 0,
    crossAxis: m.crossAxis || 0,
    alignmentAxis: m.alignmentAxis
  };
  return u && typeof E == "number" && (w = u === "end" ? E * -1 : E), d ? {
    x: w * f,
    y: g * h
  } : {
    x: g * h,
    y: w * f
  };
}
const _4 = function(e) {
  return e === void 0 && (e = 0), {
    name: "offset",
    options: e,
    async fn(t) {
      var n, r;
      const {
        x: i,
        y: s,
        placement: l,
        middlewareData: u
      } = t, d = await V4(t, e);
      return l === ((n = u.offset) == null ? void 0 : n.placement) && (r = u.arrow) != null && r.alignmentOffset ? {} : {
        x: i + d.x,
        y: s + d.y,
        data: {
          ...d,
          placement: l
        }
      };
    }
  };
}, I4 = function(e) {
  return e === void 0 && (e = {}), {
    name: "shift",
    options: e,
    async fn(t) {
      const {
        x: n,
        y: r,
        placement: i
      } = t, {
        mainAxis: s = !0,
        crossAxis: l = !1,
        limiter: u = {
          fn: (A) => {
            let {
              x,
              y: R
            } = A;
            return {
              x,
              y: R
            };
          }
        },
        ...d
      } = Or(e, t), h = {
        x: n,
        y: r
      }, f = await jl(t, d), m = ur(Br(i)), g = By(m);
      let w = h[g], E = h[m];
      if (s) {
        const A = g === "y" ? "top" : "left", x = g === "y" ? "bottom" : "right", R = w + f[A], _ = w - f[x];
        w = cg(R, w, _);
      }
      if (l) {
        const A = m === "y" ? "top" : "left", x = m === "y" ? "bottom" : "right", R = E + f[A], _ = E - f[x];
        E = cg(R, E, _);
      }
      const b = u.fn({
        ...t,
        [g]: w,
        [m]: E
      });
      return {
        ...b,
        data: {
          x: b.x - n,
          y: b.y - r,
          enabled: {
            [g]: s,
            [m]: l
          }
        }
      };
    }
  };
}, L4 = function(e) {
  return e === void 0 && (e = {}), {
    options: e,
    fn(t) {
      const {
        x: n,
        y: r,
        placement: i,
        rects: s,
        middlewareData: l
      } = t, {
        offset: u = 0,
        mainAxis: d = !0,
        crossAxis: h = !0
      } = Or(e, t), f = {
        x: n,
        y: r
      }, m = ur(i), g = By(m);
      let w = f[g], E = f[m];
      const b = Or(u, t), A = typeof b == "number" ? {
        mainAxis: b,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...b
      };
      if (d) {
        const _ = g === "y" ? "height" : "width", L = s.reference[g] - s.floating[_] + A.mainAxis, V = s.reference[g] + s.reference[_] - A.mainAxis;
        w < L ? w = L : w > V && (w = V);
      }
      if (h) {
        var x, R;
        const _ = g === "y" ? "width" : "height", L = JR.has(Br(i)), V = s.reference[m] - s.floating[_] + (L && ((x = l.offset) == null ? void 0 : x[m]) || 0) + (L ? 0 : A.crossAxis), O = s.reference[m] + s.reference[_] + (L ? 0 : ((R = l.offset) == null ? void 0 : R[m]) || 0) - (L ? A.crossAxis : 0);
        E < V ? E = V : E > O && (E = O);
      }
      return {
        [g]: w,
        [m]: E
      };
    }
  };
}, P4 = function(e) {
  return e === void 0 && (e = {}), {
    name: "size",
    options: e,
    async fn(t) {
      var n, r;
      const {
        placement: i,
        rects: s,
        platform: l,
        elements: u
      } = t, {
        apply: d = () => {
        },
        ...h
      } = Or(e, t), f = await jl(t, h), m = Br(i), g = qs(i), w = ur(i) === "y", {
        width: E,
        height: b
      } = s.floating;
      let A, x;
      m === "top" || m === "bottom" ? (A = m, x = g === (await (l.isRTL == null ? void 0 : l.isRTL(u.floating)) ? "start" : "end") ? "left" : "right") : (x = m, A = g === "end" ? "top" : "bottom");
      const R = b - f.top - f.bottom, _ = E - f.left - f.right, L = Ci(b - f[A], R), V = Ci(E - f[x], _), O = !t.middlewareData.shift;
      let D = L, B = V;
      if ((n = t.middlewareData.shift) != null && n.enabled.x && (B = _), (r = t.middlewareData.shift) != null && r.enabled.y && (D = R), O && !g) {
        const J = dn(f.left, 0), ce = dn(f.right, 0), fe = dn(f.top, 0), de = dn(f.bottom, 0);
        w ? B = E - 2 * (J !== 0 || ce !== 0 ? J + ce : dn(f.left, f.right)) : D = b - 2 * (fe !== 0 || de !== 0 ? fe + de : dn(f.top, f.bottom));
      }
      await d({
        ...t,
        availableWidth: B,
        availableHeight: D
      });
      const H = await l.getDimensions(u.floating);
      return E !== H.width || b !== H.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function mf() {
  return typeof window < "u";
}
function Xs(e) {
  return eT(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function fn(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function mr(e) {
  var t;
  return (t = (eT(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
function eT(e) {
  return mf() ? e instanceof Node || e instanceof fn(e).Node : !1;
}
function Un(e) {
  return mf() ? e instanceof Element || e instanceof fn(e).Element : !1;
}
function pr(e) {
  return mf() ? e instanceof HTMLElement || e instanceof fn(e).HTMLElement : !1;
}
function AA(e) {
  return !mf() || typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof fn(e).ShadowRoot;
}
const M4 = /* @__PURE__ */ new Set(["inline", "contents"]);
function hu(e) {
  const {
    overflow: t,
    overflowX: n,
    overflowY: r,
    display: i
  } = Wn(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + r + n) && !M4.has(i);
}
const O4 = /* @__PURE__ */ new Set(["table", "td", "th"]);
function B4(e) {
  return O4.has(Xs(e));
}
const N4 = [":popover-open", ":modal"];
function gf(e) {
  return N4.some((t) => {
    try {
      return e.matches(t);
    } catch {
      return !1;
    }
  });
}
const D4 = ["transform", "translate", "scale", "rotate", "perspective"], j4 = ["transform", "translate", "scale", "rotate", "perspective", "filter"], F4 = ["paint", "layout", "strict", "content"];
function jy(e) {
  const t = Fy(), n = Un(e) ? Wn(e) : e;
  return D4.some((r) => n[r] ? n[r] !== "none" : !1) || (n.containerType ? n.containerType !== "normal" : !1) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !t && (n.filter ? n.filter !== "none" : !1) || j4.some((r) => (n.willChange || "").includes(r)) || F4.some((r) => (n.contain || "").includes(r));
}
function U4(e) {
  let t = Ei(e);
  for (; pr(t) && !Ns(t); ) {
    if (jy(t))
      return t;
    if (gf(t))
      return null;
    t = Ei(t);
  }
  return null;
}
function Fy() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
const W4 = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function Ns(e) {
  return W4.has(Xs(e));
}
function Wn(e) {
  return fn(e).getComputedStyle(e);
}
function vf(e) {
  return Un(e) ? {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  } : {
    scrollLeft: e.scrollX,
    scrollTop: e.scrollY
  };
}
function Ei(e) {
  if (Xs(e) === "html")
    return e;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    AA(e) && e.host || // Fallback.
    mr(e)
  );
  return AA(t) ? t.host : t;
}
function tT(e) {
  const t = Ei(e);
  return Ns(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : pr(t) && hu(t) ? t : tT(t);
}
function Fl(e, t, n) {
  var r;
  t === void 0 && (t = []), n === void 0 && (n = !0);
  const i = tT(e), s = i === ((r = e.ownerDocument) == null ? void 0 : r.body), l = fn(i);
  if (s) {
    const u = fg(l);
    return t.concat(l, l.visualViewport || [], hu(i) ? i : [], u && n ? Fl(u) : []);
  }
  return t.concat(i, Fl(i, [], n));
}
function fg(e) {
  return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null;
}
function nT(e) {
  const t = Wn(e);
  let n = parseFloat(t.width) || 0, r = parseFloat(t.height) || 0;
  const i = pr(e), s = i ? e.offsetWidth : n, l = i ? e.offsetHeight : r, u = Vd(n) !== s || Vd(r) !== l;
  return u && (n = s, r = l), {
    width: n,
    height: r,
    $: u
  };
}
function Uy(e) {
  return Un(e) ? e : e.contextElement;
}
function ms(e) {
  const t = Uy(e);
  if (!pr(t))
    return fr(1);
  const n = t.getBoundingClientRect(), {
    width: r,
    height: i,
    $: s
  } = nT(t);
  let l = (s ? Vd(n.width) : n.width) / r, u = (s ? Vd(n.height) : n.height) / i;
  return (!l || !Number.isFinite(l)) && (l = 1), (!u || !Number.isFinite(u)) && (u = 1), {
    x: l,
    y: u
  };
}
const z4 = /* @__PURE__ */ fr(0);
function rT(e) {
  const t = fn(e);
  return !Fy() || !t.visualViewport ? z4 : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function H4(e, t, n) {
  return t === void 0 && (t = !1), !n || t && n !== fn(e) ? !1 : t;
}
function vo(e, t, n, r) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  const i = e.getBoundingClientRect(), s = Uy(e);
  let l = fr(1);
  t && (r ? Un(r) && (l = ms(r)) : l = ms(e));
  const u = H4(s, n, r) ? rT(s) : fr(0);
  let d = (i.left + u.x) / l.x, h = (i.top + u.y) / l.y, f = i.width / l.x, m = i.height / l.y;
  if (s) {
    const g = fn(s), w = r && Un(r) ? fn(r) : r;
    let E = g, b = fg(E);
    for (; b && r && w !== E; ) {
      const A = ms(b), x = b.getBoundingClientRect(), R = Wn(b), _ = x.left + (b.clientLeft + parseFloat(R.paddingLeft)) * A.x, L = x.top + (b.clientTop + parseFloat(R.paddingTop)) * A.y;
      d *= A.x, h *= A.y, f *= A.x, m *= A.y, d += _, h += L, E = fn(b), b = fg(E);
    }
  }
  return Id({
    width: f,
    height: m,
    x: d,
    y: h
  });
}
function yf(e, t) {
  const n = vf(e).scrollLeft;
  return t ? t.left + n : vo(mr(e)).left + n;
}
function iT(e, t) {
  const n = e.getBoundingClientRect(), r = n.left + t.scrollLeft - yf(e, n), i = n.top + t.scrollTop;
  return {
    x: r,
    y: i
  };
}
function K4(e) {
  let {
    elements: t,
    rect: n,
    offsetParent: r,
    strategy: i
  } = e;
  const s = i === "fixed", l = mr(r), u = t ? gf(t.floating) : !1;
  if (r === l || u && s)
    return n;
  let d = {
    scrollLeft: 0,
    scrollTop: 0
  }, h = fr(1);
  const f = fr(0), m = pr(r);
  if ((m || !m && !s) && ((Xs(r) !== "body" || hu(l)) && (d = vf(r)), pr(r))) {
    const w = vo(r);
    h = ms(r), f.x = w.x + r.clientLeft, f.y = w.y + r.clientTop;
  }
  const g = l && !m && !s ? iT(l, d) : fr(0);
  return {
    width: n.width * h.x,
    height: n.height * h.y,
    x: n.x * h.x - d.scrollLeft * h.x + f.x + g.x,
    y: n.y * h.y - d.scrollTop * h.y + f.y + g.y
  };
}
function G4(e) {
  return Array.from(e.getClientRects());
}
function Y4(e) {
  const t = mr(e), n = vf(e), r = e.ownerDocument.body, i = dn(t.scrollWidth, t.clientWidth, r.scrollWidth, r.clientWidth), s = dn(t.scrollHeight, t.clientHeight, r.scrollHeight, r.clientHeight);
  let l = -n.scrollLeft + yf(e);
  const u = -n.scrollTop;
  return Wn(r).direction === "rtl" && (l += dn(t.clientWidth, r.clientWidth) - i), {
    width: i,
    height: s,
    x: l,
    y: u
  };
}
const xA = 25;
function q4(e, t) {
  const n = fn(e), r = mr(e), i = n.visualViewport;
  let s = r.clientWidth, l = r.clientHeight, u = 0, d = 0;
  if (i) {
    s = i.width, l = i.height;
    const f = Fy();
    (!f || f && t === "fixed") && (u = i.offsetLeft, d = i.offsetTop);
  }
  const h = yf(r);
  if (h <= 0) {
    const f = r.ownerDocument, m = f.body, g = getComputedStyle(m), w = f.compatMode === "CSS1Compat" && parseFloat(g.marginLeft) + parseFloat(g.marginRight) || 0, E = Math.abs(r.clientWidth - m.clientWidth - w);
    E <= xA && (s -= E);
  } else h <= xA && (s += h);
  return {
    width: s,
    height: l,
    x: u,
    y: d
  };
}
const X4 = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function Z4(e, t) {
  const n = vo(e, !0, t === "fixed"), r = n.top + e.clientTop, i = n.left + e.clientLeft, s = pr(e) ? ms(e) : fr(1), l = e.clientWidth * s.x, u = e.clientHeight * s.y, d = i * s.x, h = r * s.y;
  return {
    width: l,
    height: u,
    x: d,
    y: h
  };
}
function SA(e, t, n) {
  let r;
  if (t === "viewport")
    r = q4(e, n);
  else if (t === "document")
    r = Y4(mr(e));
  else if (Un(t))
    r = Z4(t, n);
  else {
    const i = rT(e);
    r = {
      x: t.x - i.x,
      y: t.y - i.y,
      width: t.width,
      height: t.height
    };
  }
  return Id(r);
}
function oT(e, t) {
  const n = Ei(e);
  return n === t || !Un(n) || Ns(n) ? !1 : Wn(n).position === "fixed" || oT(n, t);
}
function Q4(e, t) {
  const n = t.get(e);
  if (n)
    return n;
  let r = Fl(e, [], !1).filter((u) => Un(u) && Xs(u) !== "body"), i = null;
  const s = Wn(e).position === "fixed";
  let l = s ? Ei(e) : e;
  for (; Un(l) && !Ns(l); ) {
    const u = Wn(l), d = jy(l);
    !d && u.position === "fixed" && (i = null), (s ? !d && !i : !d && u.position === "static" && !!i && X4.has(i.position) || hu(l) && !d && oT(e, l)) ? r = r.filter((f) => f !== l) : i = u, l = Ei(l);
  }
  return t.set(e, r), r;
}
function J4(e) {
  let {
    element: t,
    boundary: n,
    rootBoundary: r,
    strategy: i
  } = e;
  const l = [...n === "clippingAncestors" ? gf(t) ? [] : Q4(t, this._c) : [].concat(n), r], u = l[0], d = l.reduce((h, f) => {
    const m = SA(t, f, i);
    return h.top = dn(m.top, h.top), h.right = Ci(m.right, h.right), h.bottom = Ci(m.bottom, h.bottom), h.left = dn(m.left, h.left), h;
  }, SA(t, u, i));
  return {
    width: d.right - d.left,
    height: d.bottom - d.top,
    x: d.left,
    y: d.top
  };
}
function e5(e) {
  const {
    width: t,
    height: n
  } = nT(e);
  return {
    width: t,
    height: n
  };
}
function t5(e, t, n) {
  const r = pr(t), i = mr(t), s = n === "fixed", l = vo(e, !0, s, t);
  let u = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const d = fr(0);
  function h() {
    d.x = yf(i);
  }
  if (r || !r && !s)
    if ((Xs(t) !== "body" || hu(i)) && (u = vf(t)), r) {
      const w = vo(t, !0, s, t);
      d.x = w.x + t.clientLeft, d.y = w.y + t.clientTop;
    } else i && h();
  s && !r && i && h();
  const f = i && !r && !s ? iT(i, u) : fr(0), m = l.left + u.scrollLeft - d.x - f.x, g = l.top + u.scrollTop - d.y - f.y;
  return {
    x: m,
    y: g,
    width: l.width,
    height: l.height
  };
}
function lm(e) {
  return Wn(e).position === "static";
}
function kA(e, t) {
  if (!pr(e) || Wn(e).position === "fixed")
    return null;
  if (t)
    return t(e);
  let n = e.offsetParent;
  return mr(e) === n && (n = n.ownerDocument.body), n;
}
function sT(e, t) {
  const n = fn(e);
  if (gf(e))
    return n;
  if (!pr(e)) {
    let i = Ei(e);
    for (; i && !Ns(i); ) {
      if (Un(i) && !lm(i))
        return i;
      i = Ei(i);
    }
    return n;
  }
  let r = kA(e, t);
  for (; r && B4(r) && lm(r); )
    r = kA(r, t);
  return r && Ns(r) && lm(r) && !jy(r) ? n : r || U4(e) || n;
}
const n5 = async function(e) {
  const t = this.getOffsetParent || sT, n = this.getDimensions, r = await n(e.floating);
  return {
    reference: t5(e.reference, await t(e.floating), e.strategy),
    floating: {
      x: 0,
      y: 0,
      width: r.width,
      height: r.height
    }
  };
};
function r5(e) {
  return Wn(e).direction === "rtl";
}
const i5 = {
  convertOffsetParentRelativeRectToViewportRelativeRect: K4,
  getDocumentElement: mr,
  getClippingRect: J4,
  getOffsetParent: sT,
  getElementRects: n5,
  getClientRects: G4,
  getDimensions: e5,
  getScale: ms,
  isElement: Un,
  isRTL: r5
};
function aT(e, t) {
  return e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height;
}
function o5(e, t) {
  let n = null, r;
  const i = mr(e);
  function s() {
    var u;
    clearTimeout(r), (u = n) == null || u.disconnect(), n = null;
  }
  function l(u, d) {
    u === void 0 && (u = !1), d === void 0 && (d = 1), s();
    const h = e.getBoundingClientRect(), {
      left: f,
      top: m,
      width: g,
      height: w
    } = h;
    if (u || t(), !g || !w)
      return;
    const E = Wc(m), b = Wc(i.clientWidth - (f + g)), A = Wc(i.clientHeight - (m + w)), x = Wc(f), _ = {
      rootMargin: -E + "px " + -b + "px " + -A + "px " + -x + "px",
      threshold: dn(0, Ci(1, d)) || 1
    };
    let L = !0;
    function V(O) {
      const D = O[0].intersectionRatio;
      if (D !== d) {
        if (!L)
          return l();
        D ? l(!1, D) : r = setTimeout(() => {
          l(!1, 1e-7);
        }, 1e3);
      }
      D === 1 && !aT(h, e.getBoundingClientRect()) && l(), L = !1;
    }
    try {
      n = new IntersectionObserver(V, {
        ..._,
        // Handle <iframe>s
        root: i.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(V, _);
    }
    n.observe(e);
  }
  return l(!0), s;
}
function s5(e, t, n, r) {
  r === void 0 && (r = {});
  const {
    ancestorScroll: i = !0,
    ancestorResize: s = !0,
    elementResize: l = typeof ResizeObserver == "function",
    layoutShift: u = typeof IntersectionObserver == "function",
    animationFrame: d = !1
  } = r, h = Uy(e), f = i || s ? [...h ? Fl(h) : [], ...Fl(t)] : [];
  f.forEach((x) => {
    i && x.addEventListener("scroll", n, {
      passive: !0
    }), s && x.addEventListener("resize", n);
  });
  const m = h && u ? o5(h, n) : null;
  let g = -1, w = null;
  l && (w = new ResizeObserver((x) => {
    let [R] = x;
    R && R.target === h && w && (w.unobserve(t), cancelAnimationFrame(g), g = requestAnimationFrame(() => {
      var _;
      (_ = w) == null || _.observe(t);
    })), n();
  }), h && !d && w.observe(h), w.observe(t));
  let E, b = d ? vo(e) : null;
  d && A();
  function A() {
    const x = vo(e);
    b && !aT(b, x) && n(), b = x, E = requestAnimationFrame(A);
  }
  return n(), () => {
    var x;
    f.forEach((R) => {
      i && R.removeEventListener("scroll", n), s && R.removeEventListener("resize", n);
    }), m == null || m(), (x = w) == null || x.disconnect(), w = null, d && cancelAnimationFrame(E);
  };
}
const a5 = _4, l5 = I4, u5 = T4, c5 = P4, d5 = $4, RA = R4, f5 = L4, h5 = (e, t, n) => {
  const r = /* @__PURE__ */ new Map(), i = {
    platform: i5,
    ...n
  }, s = {
    ...i.platform,
    _c: r
  };
  return k4(e, t, {
    ...i,
    platform: s
  });
};
var p5 = typeof document < "u", m5 = function() {
}, pd = p5 ? C.useLayoutEffect : m5;
function Ld(e, t) {
  if (e === t)
    return !0;
  if (typeof e != typeof t)
    return !1;
  if (typeof e == "function" && e.toString() === t.toString())
    return !0;
  let n, r, i;
  if (e && t && typeof e == "object") {
    if (Array.isArray(e)) {
      if (n = e.length, n !== t.length) return !1;
      for (r = n; r-- !== 0; )
        if (!Ld(e[r], t[r]))
          return !1;
      return !0;
    }
    if (i = Object.keys(e), n = i.length, n !== Object.keys(t).length)
      return !1;
    for (r = n; r-- !== 0; )
      if (!{}.hasOwnProperty.call(t, i[r]))
        return !1;
    for (r = n; r-- !== 0; ) {
      const s = i[r];
      if (!(s === "_owner" && e.$$typeof) && !Ld(e[s], t[s]))
        return !1;
    }
    return !0;
  }
  return e !== e && t !== t;
}
function lT(e) {
  return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function TA(e, t) {
  const n = lT(e);
  return Math.round(t * n) / n;
}
function um(e) {
  const t = C.useRef(e);
  return pd(() => {
    t.current = e;
  }), t;
}
function g5(e) {
  e === void 0 && (e = {});
  const {
    placement: t = "bottom",
    strategy: n = "absolute",
    middleware: r = [],
    platform: i,
    elements: {
      reference: s,
      floating: l
    } = {},
    transform: u = !0,
    whileElementsMounted: d,
    open: h
  } = e, [f, m] = C.useState({
    x: 0,
    y: 0,
    strategy: n,
    placement: t,
    middlewareData: {},
    isPositioned: !1
  }), [g, w] = C.useState(r);
  Ld(g, r) || w(r);
  const [E, b] = C.useState(null), [A, x] = C.useState(null), R = C.useCallback((S) => {
    S !== O.current && (O.current = S, b(S));
  }, []), _ = C.useCallback((S) => {
    S !== D.current && (D.current = S, x(S));
  }, []), L = s || E, V = l || A, O = C.useRef(null), D = C.useRef(null), B = C.useRef(f), H = d != null, J = um(d), ce = um(i), fe = um(h), de = C.useCallback(() => {
    if (!O.current || !D.current)
      return;
    const S = {
      placement: t,
      strategy: n,
      middleware: g
    };
    ce.current && (S.platform = ce.current), h5(O.current, D.current, S).then((T) => {
      const P = {
        ...T,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: fe.current !== !1
      };
      he.current && !Ld(B.current, P) && (B.current = P, Oy.flushSync(() => {
        m(P);
      }));
    });
  }, [g, t, n, ce, fe]);
  pd(() => {
    h === !1 && B.current.isPositioned && (B.current.isPositioned = !1, m((S) => ({
      ...S,
      isPositioned: !1
    })));
  }, [h]);
  const he = C.useRef(!1);
  pd(() => (he.current = !0, () => {
    he.current = !1;
  }), []), pd(() => {
    if (L && (O.current = L), V && (D.current = V), L && V) {
      if (J.current)
        return J.current(L, V, de);
      de();
    }
  }, [L, V, de, J, H]);
  const le = C.useMemo(() => ({
    reference: O,
    floating: D,
    setReference: R,
    setFloating: _
  }), [R, _]), Y = C.useMemo(() => ({
    reference: L,
    floating: V
  }), [L, V]), te = C.useMemo(() => {
    const S = {
      position: n,
      left: 0,
      top: 0
    };
    if (!Y.floating)
      return S;
    const T = TA(Y.floating, f.x), P = TA(Y.floating, f.y);
    return u ? {
      ...S,
      transform: "translate(" + T + "px, " + P + "px)",
      ...lT(Y.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: n,
      left: T,
      top: P
    };
  }, [n, u, Y.floating, f.x, f.y]);
  return C.useMemo(() => ({
    ...f,
    update: de,
    refs: le,
    elements: Y,
    floatingStyles: te
  }), [f, de, le, Y, te]);
}
const v5 = (e) => {
  function t(n) {
    return {}.hasOwnProperty.call(n, "current");
  }
  return {
    name: "arrow",
    options: e,
    fn(n) {
      const {
        element: r,
        padding: i
      } = typeof e == "function" ? e(n) : e;
      return r && t(r) ? r.current != null ? RA({
        element: r.current,
        padding: i
      }).fn(n) : {} : r ? RA({
        element: r,
        padding: i
      }).fn(n) : {};
    }
  };
}, y5 = (e, t) => ({
  ...a5(e),
  options: [e, t]
}), w5 = (e, t) => ({
  ...l5(e),
  options: [e, t]
}), b5 = (e, t) => ({
  ...f5(e),
  options: [e, t]
}), C5 = (e, t) => ({
  ...u5(e),
  options: [e, t]
}), E5 = (e, t) => ({
  ...c5(e),
  options: [e, t]
}), A5 = (e, t) => ({
  ...d5(e),
  options: [e, t]
}), x5 = (e, t) => ({
  ...v5(e),
  options: [e, t]
});
var S5 = "Arrow", uT = C.forwardRef((e, t) => {
  const { children: n, width: r = 10, height: i = 5, ...s } = e;
  return /* @__PURE__ */ I.jsx(
    ut.svg,
    {
      ...s,
      ref: t,
      width: r,
      height: i,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: e.asChild ? n : /* @__PURE__ */ I.jsx("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
uT.displayName = S5;
var k5 = uT;
function R5(e) {
  const [t, n] = C.useState(void 0);
  return bi(() => {
    if (e) {
      n({ width: e.offsetWidth, height: e.offsetHeight });
      const r = new ResizeObserver((i) => {
        if (!Array.isArray(i) || !i.length)
          return;
        const s = i[0];
        let l, u;
        if ("borderBoxSize" in s) {
          const d = s.borderBoxSize, h = Array.isArray(d) ? d[0] : d;
          l = h.inlineSize, u = h.blockSize;
        } else
          l = e.offsetWidth, u = e.offsetHeight;
        n({ width: l, height: u });
      });
      return r.observe(e, { box: "border-box" }), () => r.unobserve(e);
    } else
      n(void 0);
  }, [e]), t;
}
var Wy = "Popper", [cT, wf] = Ys(Wy), [T5, dT] = cT(Wy), fT = (e) => {
  const { __scopePopper: t, children: n } = e, [r, i] = C.useState(null);
  return /* @__PURE__ */ I.jsx(T5, { scope: t, anchor: r, onAnchorChange: i, children: n });
};
fT.displayName = Wy;
var hT = "PopperAnchor", pT = C.forwardRef(
  (e, t) => {
    const { __scopePopper: n, virtualRef: r, ...i } = e, s = dT(hT, n), l = C.useRef(null), u = wt(t, l), d = C.useRef(null);
    return C.useEffect(() => {
      const h = d.current;
      d.current = (r == null ? void 0 : r.current) || l.current, h !== d.current && s.onAnchorChange(d.current);
    }), r ? null : /* @__PURE__ */ I.jsx(ut.div, { ...i, ref: u });
  }
);
pT.displayName = hT;
var zy = "PopperContent", [$5, V5] = cT(zy), mT = C.forwardRef(
  (e, t) => {
    var q, re, ve, Ce, Ie, ze;
    const {
      __scopePopper: n,
      side: r = "bottom",
      sideOffset: i = 0,
      align: s = "center",
      alignOffset: l = 0,
      arrowPadding: u = 0,
      avoidCollisions: d = !0,
      collisionBoundary: h = [],
      collisionPadding: f = 0,
      sticky: m = "partial",
      hideWhenDetached: g = !1,
      updatePositionStrategy: w = "optimized",
      onPlaced: E,
      ...b
    } = e, A = dT(zy, n), [x, R] = C.useState(null), _ = wt(t, (He) => R(He)), [L, V] = C.useState(null), O = R5(L), D = (O == null ? void 0 : O.width) ?? 0, B = (O == null ? void 0 : O.height) ?? 0, H = r + (s !== "center" ? "-" + s : ""), J = typeof f == "number" ? f : { top: 0, right: 0, bottom: 0, left: 0, ...f }, ce = Array.isArray(h) ? h : [h], fe = ce.length > 0, de = {
      padding: J,
      boundary: ce.filter(I5),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: fe
    }, { refs: he, floatingStyles: le, placement: Y, isPositioned: te, middlewareData: S } = g5({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: H,
      whileElementsMounted: (...He) => s5(...He, {
        animationFrame: w === "always"
      }),
      elements: {
        reference: A.anchor
      },
      middleware: [
        y5({ mainAxis: i + B, alignmentAxis: l }),
        d && w5({
          mainAxis: !0,
          crossAxis: !1,
          limiter: m === "partial" ? b5() : void 0,
          ...de
        }),
        d && C5({ ...de }),
        E5({
          ...de,
          apply: ({ elements: He, rects: pn, availableWidth: Zn, availableHeight: tn }) => {
            const { width: mn, height: Tt } = pn.reference, Ye = He.floating.style;
            Ye.setProperty("--radix-popper-available-width", `${Zn}px`), Ye.setProperty("--radix-popper-available-height", `${tn}px`), Ye.setProperty("--radix-popper-anchor-width", `${mn}px`), Ye.setProperty("--radix-popper-anchor-height", `${Tt}px`);
          }
        }),
        L && x5({ element: L, padding: u }),
        L5({ arrowWidth: D, arrowHeight: B }),
        g && A5({ strategy: "referenceHidden", ...de })
      ]
    }), [T, P] = yT(Y), $ = Mr(E);
    bi(() => {
      te && ($ == null || $());
    }, [te, $]);
    const M = (q = S.arrow) == null ? void 0 : q.x, W = (re = S.arrow) == null ? void 0 : re.y, G = ((ve = S.arrow) == null ? void 0 : ve.centerOffset) !== 0, [ee, Q] = C.useState();
    return bi(() => {
      x && Q(window.getComputedStyle(x).zIndex);
    }, [x]), /* @__PURE__ */ I.jsx(
      "div",
      {
        ref: he.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...le,
          transform: te ? le.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: ee,
          "--radix-popper-transform-origin": [
            (Ce = S.transformOrigin) == null ? void 0 : Ce.x,
            (Ie = S.transformOrigin) == null ? void 0 : Ie.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...((ze = S.hide) == null ? void 0 : ze.referenceHidden) && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: e.dir,
        children: /* @__PURE__ */ I.jsx(
          $5,
          {
            scope: n,
            placedSide: T,
            onArrowChange: V,
            arrowX: M,
            arrowY: W,
            shouldHideArrow: G,
            children: /* @__PURE__ */ I.jsx(
              ut.div,
              {
                "data-side": T,
                "data-align": P,
                ...b,
                ref: _,
                style: {
                  ...b.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: te ? void 0 : "none"
                }
              }
            )
          }
        )
      }
    );
  }
);
mT.displayName = zy;
var gT = "PopperArrow", _5 = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
}, vT = C.forwardRef(function(t, n) {
  const { __scopePopper: r, ...i } = t, s = V5(gT, r), l = _5[s.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ I.jsx(
      "span",
      {
        ref: s.onArrowChange,
        style: {
          position: "absolute",
          left: s.arrowX,
          top: s.arrowY,
          [l]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[s.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: "rotate(180deg)",
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[s.placedSide],
          visibility: s.shouldHideArrow ? "hidden" : void 0
        },
        children: /* @__PURE__ */ I.jsx(
          k5,
          {
            ...i,
            ref: n,
            style: {
              ...i.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
vT.displayName = gT;
function I5(e) {
  return e !== null;
}
var L5 = (e) => ({
  name: "transformOrigin",
  options: e,
  fn(t) {
    var A, x, R;
    const { placement: n, rects: r, middlewareData: i } = t, l = ((A = i.arrow) == null ? void 0 : A.centerOffset) !== 0, u = l ? 0 : e.arrowWidth, d = l ? 0 : e.arrowHeight, [h, f] = yT(n), m = { start: "0%", center: "50%", end: "100%" }[f], g = (((x = i.arrow) == null ? void 0 : x.x) ?? 0) + u / 2, w = (((R = i.arrow) == null ? void 0 : R.y) ?? 0) + d / 2;
    let E = "", b = "";
    return h === "bottom" ? (E = l ? m : `${g}px`, b = `${-d}px`) : h === "top" ? (E = l ? m : `${g}px`, b = `${r.floating.height + d}px`) : h === "right" ? (E = `${-d}px`, b = l ? m : `${w}px`) : h === "left" && (E = `${r.floating.width + d}px`, b = l ? m : `${w}px`), { data: { x: E, y: b } };
  }
});
function yT(e) {
  const [t, n = "center"] = e.split("-");
  return [t, n];
}
var wT = fT, bT = pT, CT = mT, ET = vT, P5 = "Portal", bf = C.forwardRef((e, t) => {
  var u;
  const { container: n, ...r } = e, [i, s] = C.useState(!1);
  bi(() => s(!0), []);
  const l = n || i && ((u = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : u.body);
  return l ? QF.createPortal(/* @__PURE__ */ I.jsx(ut.div, { ...r, ref: t }), l) : null;
});
bf.displayName = P5;
var M5 = bf;
function O5(e, t) {
  return C.useReducer((n, r) => t[n][r] ?? n, e);
}
var Ur = (e) => {
  const { present: t, children: n } = e, r = B5(t), i = typeof n == "function" ? n({ present: r.isPresent }) : C.Children.only(n), s = wt(r.ref, N5(i));
  return typeof n == "function" || r.isPresent ? C.cloneElement(i, { ref: s }) : null;
};
Ur.displayName = "Presence";
function B5(e) {
  const [t, n] = C.useState(), r = C.useRef(null), i = C.useRef(e), s = C.useRef("none"), l = e ? "mounted" : "unmounted", [u, d] = O5(l, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return C.useEffect(() => {
    const h = zc(r.current);
    s.current = u === "mounted" ? h : "none";
  }, [u]), bi(() => {
    const h = r.current, f = i.current;
    if (f !== e) {
      const g = s.current, w = zc(h);
      e ? d("MOUNT") : w === "none" || (h == null ? void 0 : h.display) === "none" ? d("UNMOUNT") : d(f && g !== w ? "ANIMATION_OUT" : "UNMOUNT"), i.current = e;
    }
  }, [e, d]), bi(() => {
    if (t) {
      let h;
      const f = t.ownerDocument.defaultView ?? window, m = (w) => {
        const b = zc(r.current).includes(CSS.escape(w.animationName));
        if (w.target === t && b && (d("ANIMATION_END"), !i.current)) {
          const A = t.style.animationFillMode;
          t.style.animationFillMode = "forwards", h = f.setTimeout(() => {
            t.style.animationFillMode === "forwards" && (t.style.animationFillMode = A);
          });
        }
      }, g = (w) => {
        w.target === t && (s.current = zc(r.current));
      };
      return t.addEventListener("animationstart", g), t.addEventListener("animationcancel", m), t.addEventListener("animationend", m), () => {
        f.clearTimeout(h), t.removeEventListener("animationstart", g), t.removeEventListener("animationcancel", m), t.removeEventListener("animationend", m);
      };
    } else
      d("ANIMATION_END");
  }, [t, d]), {
    isPresent: ["mounted", "unmountSuspended"].includes(u),
    ref: C.useCallback((h) => {
      r.current = h ? getComputedStyle(h) : null, n(h);
    }, [])
  };
}
function zc(e) {
  return (e == null ? void 0 : e.animationName) || "none";
}
function N5(e) {
  var r, i;
  let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = (i = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : i.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var D5 = Dv[" useInsertionEffect ".trim().toString()] || bi;
function Zs({
  prop: e,
  defaultProp: t,
  onChange: n = () => {
  },
  caller: r
}) {
  const [i, s, l] = j5({
    defaultProp: t,
    onChange: n
  }), u = e !== void 0, d = u ? e : i;
  {
    const f = C.useRef(e !== void 0);
    C.useEffect(() => {
      const m = f.current;
      m !== u && console.warn(
        `${r} is changing from ${m ? "controlled" : "uncontrolled"} to ${u ? "controlled" : "uncontrolled"}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`
      ), f.current = u;
    }, [u, r]);
  }
  const h = C.useCallback(
    (f) => {
      var m;
      if (u) {
        const g = F5(f) ? f(e) : f;
        g !== e && ((m = l.current) == null || m.call(l, g));
      } else
        s(f);
    },
    [u, e, s, l]
  );
  return [d, h];
}
function j5({
  defaultProp: e,
  onChange: t
}) {
  const [n, r] = C.useState(e), i = C.useRef(n), s = C.useRef(t);
  return D5(() => {
    s.current = t;
  }, [t]), C.useEffect(() => {
    var l;
    i.current !== n && ((l = s.current) == null || l.call(s, n), i.current = n);
  }, [n, i]), [n, r, s];
}
function F5(e) {
  return typeof e == "function";
}
var U5 = Object.freeze({
  // See: https://github.com/twbs/bootstrap/blob/main/scss/mixins/_visually-hidden.scss
  position: "absolute",
  border: 0,
  width: 1,
  height: 1,
  padding: 0,
  margin: -1,
  overflow: "hidden",
  clip: "rect(0, 0, 0, 0)",
  whiteSpace: "nowrap",
  wordWrap: "normal"
}), W5 = "VisuallyHidden", AT = C.forwardRef(
  (e, t) => /* @__PURE__ */ I.jsx(
    ut.span,
    {
      ...e,
      ref: t,
      style: { ...U5, ...e.style }
    }
  )
);
AT.displayName = W5;
var z5 = AT, [Cf] = Ys("Tooltip", [
  wf
]), Ef = wf(), xT = "TooltipProvider", H5 = 700, hg = "tooltip.open", [K5, Hy] = Cf(xT), ST = (e) => {
  const {
    __scopeTooltip: t,
    delayDuration: n = H5,
    skipDelayDuration: r = 300,
    disableHoverableContent: i = !1,
    children: s
  } = e, l = C.useRef(!0), u = C.useRef(!1), d = C.useRef(0);
  return C.useEffect(() => {
    const h = d.current;
    return () => window.clearTimeout(h);
  }, []), /* @__PURE__ */ I.jsx(
    K5,
    {
      scope: t,
      isOpenDelayedRef: l,
      delayDuration: n,
      onOpen: C.useCallback(() => {
        window.clearTimeout(d.current), l.current = !1;
      }, []),
      onClose: C.useCallback(() => {
        window.clearTimeout(d.current), d.current = window.setTimeout(
          () => l.current = !0,
          r
        );
      }, [r]),
      isPointerInTransitRef: u,
      onPointerInTransitChange: C.useCallback((h) => {
        u.current = h;
      }, []),
      disableHoverableContent: i,
      children: s
    }
  );
};
ST.displayName = xT;
var Ul = "Tooltip", [G5, pu] = Cf(Ul), kT = (e) => {
  const {
    __scopeTooltip: t,
    children: n,
    open: r,
    defaultOpen: i,
    onOpenChange: s,
    disableHoverableContent: l,
    delayDuration: u
  } = e, d = Hy(Ul, e.__scopeTooltip), h = Ef(t), [f, m] = C.useState(null), g = Rl(), w = C.useRef(0), E = l ?? d.disableHoverableContent, b = u ?? d.delayDuration, A = C.useRef(!1), [x, R] = Zs({
    prop: r,
    defaultProp: i ?? !1,
    onChange: (D) => {
      D ? (d.onOpen(), document.dispatchEvent(new CustomEvent(hg))) : d.onClose(), s == null || s(D);
    },
    caller: Ul
  }), _ = C.useMemo(() => x ? A.current ? "delayed-open" : "instant-open" : "closed", [x]), L = C.useCallback(() => {
    window.clearTimeout(w.current), w.current = 0, A.current = !1, R(!0);
  }, [R]), V = C.useCallback(() => {
    window.clearTimeout(w.current), w.current = 0, R(!1);
  }, [R]), O = C.useCallback(() => {
    window.clearTimeout(w.current), w.current = window.setTimeout(() => {
      A.current = !0, R(!0), w.current = 0;
    }, b);
  }, [b, R]);
  return C.useEffect(() => () => {
    w.current && (window.clearTimeout(w.current), w.current = 0);
  }, []), /* @__PURE__ */ I.jsx(wT, { ...h, children: /* @__PURE__ */ I.jsx(
    G5,
    {
      scope: t,
      contentId: g,
      open: x,
      stateAttribute: _,
      trigger: f,
      onTriggerChange: m,
      onTriggerEnter: C.useCallback(() => {
        d.isOpenDelayedRef.current ? O() : L();
      }, [d.isOpenDelayedRef, O, L]),
      onTriggerLeave: C.useCallback(() => {
        E ? V() : (window.clearTimeout(w.current), w.current = 0);
      }, [V, E]),
      onOpen: L,
      onClose: V,
      disableHoverableContent: E,
      children: n
    }
  ) });
};
kT.displayName = Ul;
var pg = "TooltipTrigger", RT = C.forwardRef(
  (e, t) => {
    const { __scopeTooltip: n, ...r } = e, i = pu(pg, n), s = Hy(pg, n), l = Ef(n), u = C.useRef(null), d = wt(t, u, i.onTriggerChange), h = C.useRef(!1), f = C.useRef(!1), m = C.useCallback(() => h.current = !1, []);
    return C.useEffect(() => () => document.removeEventListener("pointerup", m), [m]), /* @__PURE__ */ I.jsx(bT, { asChild: !0, ...l, children: /* @__PURE__ */ I.jsx(
      ut.button,
      {
        "aria-describedby": i.open ? i.contentId : void 0,
        "data-state": i.stateAttribute,
        ...r,
        ref: d,
        onPointerMove: Le(e.onPointerMove, (g) => {
          g.pointerType !== "touch" && !f.current && !s.isPointerInTransitRef.current && (i.onTriggerEnter(), f.current = !0);
        }),
        onPointerLeave: Le(e.onPointerLeave, () => {
          i.onTriggerLeave(), f.current = !1;
        }),
        onPointerDown: Le(e.onPointerDown, () => {
          i.open && i.onClose(), h.current = !0, document.addEventListener("pointerup", m, { once: !0 });
        }),
        onFocus: Le(e.onFocus, () => {
          h.current || i.onOpen();
        }),
        onBlur: Le(e.onBlur, i.onClose),
        onClick: Le(e.onClick, i.onClose)
      }
    ) });
  }
);
RT.displayName = pg;
var Ky = "TooltipPortal", [Y5, q5] = Cf(Ky, {
  forceMount: void 0
}), TT = (e) => {
  const { __scopeTooltip: t, forceMount: n, children: r, container: i } = e, s = pu(Ky, t);
  return /* @__PURE__ */ I.jsx(Y5, { scope: t, forceMount: n, children: /* @__PURE__ */ I.jsx(Ur, { present: n || s.open, children: /* @__PURE__ */ I.jsx(bf, { asChild: !0, container: i, children: r }) }) });
};
TT.displayName = Ky;
var Ds = "TooltipContent", $T = C.forwardRef(
  (e, t) => {
    const n = q5(Ds, e.__scopeTooltip), { forceMount: r = n.forceMount, side: i = "top", ...s } = e, l = pu(Ds, e.__scopeTooltip);
    return /* @__PURE__ */ I.jsx(Ur, { present: r || l.open, children: l.disableHoverableContent ? /* @__PURE__ */ I.jsx(VT, { side: i, ...s, ref: t }) : /* @__PURE__ */ I.jsx(X5, { side: i, ...s, ref: t }) });
  }
), X5 = C.forwardRef((e, t) => {
  const n = pu(Ds, e.__scopeTooltip), r = Hy(Ds, e.__scopeTooltip), i = C.useRef(null), s = wt(t, i), [l, u] = C.useState(null), { trigger: d, onClose: h } = n, f = i.current, { onPointerInTransitChange: m } = r, g = C.useCallback(() => {
    u(null), m(!1);
  }, [m]), w = C.useCallback(
    (E, b) => {
      const A = E.currentTarget, x = { x: E.clientX, y: E.clientY }, R = tU(x, A.getBoundingClientRect()), _ = nU(x, R), L = rU(b.getBoundingClientRect()), V = oU([..._, ...L]);
      u(V), m(!0);
    },
    [m]
  );
  return C.useEffect(() => () => g(), [g]), C.useEffect(() => {
    if (d && f) {
      const E = (A) => w(A, f), b = (A) => w(A, d);
      return d.addEventListener("pointerleave", E), f.addEventListener("pointerleave", b), () => {
        d.removeEventListener("pointerleave", E), f.removeEventListener("pointerleave", b);
      };
    }
  }, [d, f, w, g]), C.useEffect(() => {
    if (l) {
      const E = (b) => {
        const A = b.target, x = { x: b.clientX, y: b.clientY }, R = (d == null ? void 0 : d.contains(A)) || (f == null ? void 0 : f.contains(A)), _ = !iU(x, l);
        R ? g() : _ && (g(), h());
      };
      return document.addEventListener("pointermove", E), () => document.removeEventListener("pointermove", E);
    }
  }, [d, f, l, h, g]), /* @__PURE__ */ I.jsx(VT, { ...e, ref: s });
}), [Z5, Q5] = Cf(Ul, { isInside: !1 }), J5 = /* @__PURE__ */ e4("TooltipContent"), VT = C.forwardRef(
  (e, t) => {
    const {
      __scopeTooltip: n,
      children: r,
      "aria-label": i,
      onEscapeKeyDown: s,
      onPointerDownOutside: l,
      ...u
    } = e, d = pu(Ds, n), h = Ef(n), { onClose: f } = d;
    return C.useEffect(() => (document.addEventListener(hg, f), () => document.removeEventListener(hg, f)), [f]), C.useEffect(() => {
      if (d.trigger) {
        const m = (g) => {
          const w = g.target;
          w != null && w.contains(d.trigger) && f();
        };
        return window.addEventListener("scroll", m, { capture: !0 }), () => window.removeEventListener("scroll", m, { capture: !0 });
      }
    }, [d.trigger, f]), /* @__PURE__ */ I.jsx(
      fu,
      {
        asChild: !0,
        disableOutsidePointerEvents: !1,
        onEscapeKeyDown: s,
        onPointerDownOutside: l,
        onFocusOutside: (m) => m.preventDefault(),
        onDismiss: f,
        children: /* @__PURE__ */ I.jsxs(
          CT,
          {
            "data-state": d.stateAttribute,
            ...h,
            ...u,
            ref: t,
            style: {
              ...u.style,
              "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
              "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
              "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
              "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
              "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
            },
            children: [
              /* @__PURE__ */ I.jsx(J5, { children: r }),
              /* @__PURE__ */ I.jsx(Z5, { scope: n, isInside: !0, children: /* @__PURE__ */ I.jsx(z5, { id: d.contentId, role: "tooltip", children: i || r }) })
            ]
          }
        )
      }
    );
  }
);
$T.displayName = Ds;
var _T = "TooltipArrow", eU = C.forwardRef(
  (e, t) => {
    const { __scopeTooltip: n, ...r } = e, i = Ef(n);
    return Q5(
      _T,
      n
    ).isInside ? null : /* @__PURE__ */ I.jsx(ET, { ...i, ...r, ref: t });
  }
);
eU.displayName = _T;
function tU(e, t) {
  const n = Math.abs(t.top - e.y), r = Math.abs(t.bottom - e.y), i = Math.abs(t.right - e.x), s = Math.abs(t.left - e.x);
  switch (Math.min(n, r, i, s)) {
    case s:
      return "left";
    case i:
      return "right";
    case n:
      return "top";
    case r:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function nU(e, t, n = 5) {
  const r = [];
  switch (t) {
    case "top":
      r.push(
        { x: e.x - n, y: e.y + n },
        { x: e.x + n, y: e.y + n }
      );
      break;
    case "bottom":
      r.push(
        { x: e.x - n, y: e.y - n },
        { x: e.x + n, y: e.y - n }
      );
      break;
    case "left":
      r.push(
        { x: e.x + n, y: e.y - n },
        { x: e.x + n, y: e.y + n }
      );
      break;
    case "right":
      r.push(
        { x: e.x - n, y: e.y - n },
        { x: e.x - n, y: e.y + n }
      );
      break;
  }
  return r;
}
function rU(e) {
  const { top: t, right: n, bottom: r, left: i } = e;
  return [
    { x: i, y: t },
    { x: n, y: t },
    { x: n, y: r },
    { x: i, y: r }
  ];
}
function iU(e, t) {
  const { x: n, y: r } = e;
  let i = !1;
  for (let s = 0, l = t.length - 1; s < t.length; l = s++) {
    const u = t[s], d = t[l], h = u.x, f = u.y, m = d.x, g = d.y;
    f > r != g > r && n < (m - h) * (r - f) / (g - f) + h && (i = !i);
  }
  return i;
}
function oU(e) {
  const t = e.slice();
  return t.sort((n, r) => n.x < r.x ? -1 : n.x > r.x ? 1 : n.y < r.y ? -1 : n.y > r.y ? 1 : 0), sU(t);
}
function sU(e) {
  if (e.length <= 1) return e.slice();
  const t = [];
  for (let r = 0; r < e.length; r++) {
    const i = e[r];
    for (; t.length >= 2; ) {
      const s = t[t.length - 1], l = t[t.length - 2];
      if ((s.x - l.x) * (i.y - l.y) >= (s.y - l.y) * (i.x - l.x)) t.pop();
      else break;
    }
    t.push(i);
  }
  t.pop();
  const n = [];
  for (let r = e.length - 1; r >= 0; r--) {
    const i = e[r];
    for (; n.length >= 2; ) {
      const s = n[n.length - 1], l = n[n.length - 2];
      if ((s.x - l.x) * (i.y - l.y) >= (s.y - l.y) * (i.x - l.x)) n.pop();
      else break;
    }
    n.push(i);
  }
  return n.pop(), t.length === 1 && n.length === 1 && t[0].x === n[0].x && t[0].y === n[0].y ? t : t.concat(n);
}
var aU = ST, lU = kT, uU = RT, cU = TT, dU = $T;
const fU = (e = {}) => {
  const [t, n] = j.useState(
    (e == null ? void 0 : e.appearanceOverride) || "light"
  ), r = t === "light" ? "dark" : "light", i = { "data-tgph-appearance": t }, s = {
    "data-tgph-appearance": r
  }, l = { "data-tgph-appearance": "light" }, u = { "data-tgph-appearance": "dark" }, d = (h) => {
    document && (n(h), document.documentElement.setAttribute(
      "data-tgph-appearance",
      h
    ));
  };
  return j.useEffect(() => {
    if (!document) return;
    const h = (g) => {
      for (const w of g)
        w.type === "attributes" && w.attributeName === "data-tgph-appearance" && n(
          document.documentElement.getAttribute(
            "data-tgph-appearance"
          )
        );
    }, f = document.documentElement.getAttribute(
      "data-tgph-appearance"
    );
    n(f);
    const m = new MutationObserver(h);
    return m.observe(document.documentElement, { attributes: !0 }), () => {
      m && m.disconnect();
    };
  }, []), {
    setAppearance: d,
    toggleAppearance: () => {
      d(t === "light" ? "dark" : "light");
    },
    appearance: t,
    invertedAppearance: r,
    appearanceProps: i,
    invertedAppearanceProps: s,
    lightAppearanceProps: l,
    darkAppearanceProps: u
  };
}, hU = ({
  appearance: e,
  asChild: t,
  ...n
}) => {
  const { lightAppearanceProps: r, darkAppearanceProps: i } = fU();
  return /* @__PURE__ */ I.jsx(t ? GR : "div", { ...e === "light" ? r : i, ...n });
}, Be = {
  display: {
    cssVar: "--display",
    value: "VARIABLE"
  },
  backgroundColor: {
    cssVar: "--background-color",
    value: "var(--tgph-VARIABLE)"
  },
  hover_backgroundColor: {
    cssVar: "--hover_backgroundColor",
    value: "var(--tgph-VARIABLE)",
    interactive: !0
  },
  focus_backgroundColor: {
    cssVar: "--focus_backgroundColor",
    value: "var(--tgph-VARIABLE)",
    interactive: !0
  },
  active_backgroundColor: {
    cssVar: "--active_backgroundColor",
    interactive: !0,
    value: "var(--tgph-VARIABLE)"
  },
  focus_within_backgroundColor: {
    cssVar: "--focus_within_backgroundColor",
    interactive: !0,
    value: "var(--tgph-VARIABLE)"
  },
  borderStyle: {
    cssVar: "--border-style",
    value: "var(--tgph-border-style-VARIABLE)"
  },
  padding: {
    cssVar: "--padding",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "all"
  },
  paddingX: {
    cssVar: "--padding",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "x"
  },
  paddingY: {
    cssVar: "--padding",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "y"
  },
  paddingTop: {
    cssVar: "--padding",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "top"
  },
  paddingBottom: {
    cssVar: "--padding",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "bottom"
  },
  paddingLeft: {
    cssVar: "--padding",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "left"
  },
  paddingRight: {
    cssVar: "--padding",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "right"
  },
  margin: {
    cssVar: "--margin",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "all"
  },
  marginX: {
    cssVar: "--margin",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "x"
  },
  marginY: {
    cssVar: "--margin",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "y"
  },
  marginTop: {
    cssVar: "--margin",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "top"
  },
  marginBottom: {
    cssVar: "--margin",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "bottom"
  },
  marginLeft: {
    cssVar: "--margin",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "left"
  },
  marginRight: {
    cssVar: "--margin",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "right"
  },
  borderColor: {
    cssVar: "--border-color",
    value: "var(--tgph-VARIABLE)"
  },
  hover_borderColor: {
    cssVar: "--hover_borderColor",
    value: "var(--tgph-VARIABLE)",
    interactive: !0
  },
  focus_borderColor: {
    cssVar: "--focus_borderColor",
    value: "var(--tgph-VARIABLE)",
    interactive: !0
  },
  focus_within_borderColor: {
    cssVar: "--focus_within_borderColor",
    interactive: !0,
    value: "var(--tgph-VARIABLE)"
  },
  active_borderColor: {
    cssVar: "--active_borderColor",
    interactive: !0,
    value: "var(--tgph-VARIABLE)"
  },
  borderTopColor: {
    cssVar: "--border-color",
    value: "var(--tgph-VARIABLE)",
    direction: "top"
  },
  borderBottomColor: {
    cssVar: "--border-color",
    value: "var(--tgph-VARIABLE)",
    direction: "bottom"
  },
  borderLeftColor: {
    cssVar: "--border-color",
    value: "var(--tgph-VARIABLE)",
    direction: "left"
  },
  borderRightColor: {
    cssVar: "--border-color",
    value: "var(--tgph-VARIABLE)",
    direction: "right"
  },
  borderWidth: {
    cssVar: "--border-width",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  borderTopWidth: {
    cssVar: "--border-width",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "top"
  },
  borderBottomWidth: {
    cssVar: "--border-width",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "bottom"
  },
  borderLeftWidth: {
    cssVar: "--border-width",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "left"
  },
  borderRightWidth: {
    cssVar: "--border-width",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "right"
  },
  borderRadius: {
    cssVar: "--border-radius",
    value: "var(--tgph-rounded-VARIABLE)"
  },
  borderTopLeftRadius: {
    cssVar: "--border-radius",
    value: "var(--tgph-rounded-VARIABLE)",
    direction: "top"
  },
  borderTopRightRadius: {
    cssVar: "--border-radius",
    value: "var(--tgph-rounded-VARIABLE)",
    direction: "right"
  },
  borderBottomLeftRadius: {
    cssVar: "--border-radius",
    value: "var(--tgph-rounded-VARIABLE)",
    direction: "left"
  },
  borderBottomRightRadius: {
    cssVar: "--border-radius",
    value: "var(--tgph-rounded-VARIABLE)",
    direction: "bottom"
  },
  borderTopRadius: {
    cssVar: "--border-radius",
    value: "var(--tgph-rounded-VARIABLE)",
    direction: "side-top"
  },
  borderBottomRadius: {
    cssVar: "--border-radius",
    value: "var(--tgph-rounded-VARIABLE)",
    direction: "side-bottom"
  },
  borderLeftRadius: {
    cssVar: "--border-radius",
    value: "var(--tgph-rounded-VARIABLE)",
    direction: "side-left"
  },
  borderRightRadius: {
    cssVar: "--border-radius",
    value: "var(--tgph-rounded-VARIABLE)",
    direction: "side-right"
  },
  boxShadow: {
    cssVar: "--box-shadow",
    value: "var(--tgph-shadow-VARIABLE)"
  },
  width: {
    cssVar: "--width",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  height: {
    cssVar: "--height",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  minWidth: {
    cssVar: "--min-width",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  minHeight: {
    cssVar: "--min-height",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  maxWidth: {
    cssVar: "--max-width",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  maxHeight: {
    cssVar: "--max-height",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  zIndex: {
    cssVar: "--z-index",
    value: "var(--tgph-zIndex-VARIABLE)"
  },
  position: {
    cssVar: "--position",
    value: "VARIABLE"
  },
  top: {
    cssVar: "--top",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  left: {
    cssVar: "--left",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  right: {
    cssVar: "--right",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  bottom: {
    cssVar: "--bottom",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  overflow: {
    cssVar: "--overflow",
    value: "VARIABLE"
  },
  overflowX: {
    cssVar: "--overflow-x",
    value: "VARIABLE"
  },
  overflowY: {
    cssVar: "--overflow-y",
    value: "VARIABLE"
  },
  alignSelf: {
    cssVar: "--align-self",
    value: "VARIABLE"
  }
}, pU = {
  border: Be.borderWidth,
  borderX: Be.borderLeftWidth,
  borderY: Be.borderTopWidth,
  bg: Be.backgroundColor,
  p: Be.padding,
  m: Be.margin,
  px: Be.paddingX,
  py: Be.paddingY,
  pt: Be.paddingTop,
  pb: Be.paddingBottom,
  pl: Be.paddingLeft,
  pr: Be.paddingRight,
  mx: Be.marginX,
  my: Be.marginY,
  mt: Be.marginTop,
  mb: Be.marginBottom,
  ml: Be.marginLeft,
  mr: Be.marginRight,
  shadow: Be.boxShadow,
  w: Be.width,
  h: Be.height,
  minW: Be.minWidth,
  minH: Be.minHeight,
  maxW: Be.maxWidth,
  maxH: Be.maxHeight,
  rounded: Be.borderRadius,
  roundedTopLeft: Be.borderTopLeftRadius,
  roundedTopRight: Be.borderTopRightRadius,
  roundedBottomLeft: Be.borderBottomLeftRadius,
  roundedBottomRight: Be.borderBottomRightRadius,
  roundedTop: Be.borderTopRadius,
  roundedBottom: Be.borderBottomRadius,
  roundedLeft: Be.borderLeftRadius,
  roundedRight: Be.borderRightRadius,
  borderTop: Be.borderTopWidth,
  borderBottom: Be.borderBottomWidth,
  borderLeft: Be.borderLeftWidth,
  borderRight: Be.borderRightWidth
}, mU = {
  ...Be,
  ...pU
}, gU = ({
  as: e,
  className: t,
  tgphRef: n,
  children: r,
  ...i
}) => {
  const s = e || "div", { styleProp: l, otherProps: u, interactive: d } = Wt({
    props: i,
    cssVars: mU
  });
  return /* @__PURE__ */ I.jsx(
    s,
    {
      className: Se(
        "tgph-box",
        d && "tgph-box--interactive",
        t
      ),
      style: l,
      ...u,
      ref: n,
      children: r
    }
  );
}, vU = {
  flexDirection: {
    cssVar: "--direction",
    value: "VARIABLE"
  },
  flexWrap: {
    cssVar: "--wrap",
    value: "VARIABLE"
  },
  justifyContent: {
    cssVar: "--justify",
    value: "VARIABLE"
  },
  alignItems: {
    cssVar: "--align",
    value: "VARIABLE"
  },
  gap: {
    cssVar: "--gap",
    value: "var(--tgph-spacing-VARIABLE)"
  }
}, yU = {
  direction: {
    cssVar: "--direction",
    value: "VARIABLE"
  },
  align: {
    cssVar: "--align",
    value: "VARIABLE"
  },
  justify: {
    cssVar: "--justify",
    value: "VARIABLE"
  },
  wrap: {
    cssVar: "--wrap",
    value: "VARIABLE"
  }
}, wU = {
  ...vU,
  ...yU
}, bU = ({
  className: e,
  ...t
}) => {
  const { styleProp: n, otherProps: r } = Wt({
    props: t,
    cssVars: wU
  });
  return /* @__PURE__ */ I.jsx(
    gU,
    {
      className: Se("tgph-stack", e),
      style: n,
      ...r
    }
  );
}, CU = C.createContext({});
function EU(e) {
  const t = C.useRef(null);
  return t.current === null && (t.current = e()), t.current;
}
const Gy = typeof window < "u", AU = Gy ? C.useLayoutEffect : C.useEffect, IT = /* @__PURE__ */ C.createContext(null);
function xU(e, t) {
  e.indexOf(t) === -1 && e.push(t);
}
function SU(e, t) {
  const n = e.indexOf(t);
  n > -1 && e.splice(n, 1);
}
const yo = (e, t, n) => n > t ? t : n < e ? e : n;
let Yy = () => {
};
const Nr = {}, LT = (e) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(e);
function kU(e) {
  return typeof e == "object" && e !== null;
}
const PT = (e) => /^0[^.\s]+$/u.test(e);
// @__NO_SIDE_EFFECTS__
function qy(e) {
  let t;
  return () => (t === void 0 && (t = e()), t);
}
const Qs = /* @__NO_SIDE_EFFECTS__ */ (e) => e, RU = (e, t) => (n) => t(e(n)), Af = (...e) => e.reduce(RU), MT = /* @__NO_SIDE_EFFECTS__ */ (e, t, n) => {
  const r = t - e;
  return r === 0 ? 1 : (n - e) / r;
};
let OT = class {
  constructor() {
    this.subscriptions = [];
  }
  add(t) {
    return xU(this.subscriptions, t), () => SU(this.subscriptions, t);
  }
  notify(t, n, r) {
    const i = this.subscriptions.length;
    if (i)
      if (i === 1)
        this.subscriptions[0](t, n, r);
      else
        for (let s = 0; s < i; s++) {
          const l = this.subscriptions[s];
          l && l(t, n, r);
        }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
};
const Sr = /* @__NO_SIDE_EFFECTS__ */ (e) => e * 1e3, kr = /* @__NO_SIDE_EFFECTS__ */ (e) => e / 1e3;
function BT(e, t) {
  return t ? e * (1e3 / t) : 0;
}
const NT = (e, t, n) => (((1 - 3 * n + 3 * t) * e + (3 * n - 6 * t)) * e + 3 * t) * e, TU = 1e-7, $U = 12;
function VU(e, t, n, r, i) {
  let s, l, u = 0;
  do
    l = t + (n - t) / 2, s = NT(l, r, i) - e, s > 0 ? n = l : t = l;
  while (Math.abs(s) > TU && ++u < $U);
  return l;
}
function mu(e, t, n, r) {
  if (e === t && n === r)
    return Qs;
  const i = (s) => VU(s, 0, 1, e, n);
  return (s) => s === 0 || s === 1 ? s : NT(i(s), t, r);
}
const DT = (e) => (t) => t <= 0.5 ? e(2 * t) / 2 : (2 - e(2 * (1 - t))) / 2, jT = (e) => (t) => 1 - e(1 - t), FT = /* @__PURE__ */ mu(0.33, 1.53, 0.69, 0.99), Xy = /* @__PURE__ */ jT(FT), UT = /* @__PURE__ */ DT(Xy), WT = (e) => (e *= 2) < 1 ? 0.5 * Xy(e) : 0.5 * (2 - Math.pow(2, -10 * (e - 1))), Zy = (e) => 1 - Math.sin(Math.acos(e)), _U = jT(Zy), zT = DT(Zy), IU = /* @__PURE__ */ mu(0.42, 0, 1, 1), LU = /* @__PURE__ */ mu(0, 0, 0.58, 1), HT = /* @__PURE__ */ mu(0.42, 0, 0.58, 1), PU = (e) => Array.isArray(e) && typeof e[0] != "number", KT = (e) => Array.isArray(e) && typeof e[0] == "number", MU = {
  linear: Qs,
  easeIn: IU,
  easeInOut: HT,
  easeOut: LU,
  circIn: Zy,
  circInOut: zT,
  circOut: _U,
  backIn: Xy,
  backInOut: UT,
  backOut: FT,
  anticipate: WT
}, OU = (e) => typeof e == "string", $A = (e) => {
  if (KT(e)) {
    Yy(e.length === 4);
    const [t, n, r, i] = e;
    return mu(t, n, r, i);
  } else if (OU(e))
    return MU[e];
  return e;
}, Hc = [
  "setup",
  // Compute
  "read",
  // Read
  "resolveKeyframes",
  // Write/Read/Write/Read
  "preUpdate",
  // Compute
  "update",
  // Compute
  "preRender",
  // Compute
  "render",
  // Write
  "postRender"
  // Compute
];
function BU(e, t) {
  let n = /* @__PURE__ */ new Set(), r = /* @__PURE__ */ new Set(), i = !1, s = !1;
  const l = /* @__PURE__ */ new WeakSet();
  let u = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  };
  function d(f) {
    l.has(f) && (h.schedule(f), e()), f(u);
  }
  const h = {
    /**
     * Schedule a process to run on the next frame.
     */
    schedule: (f, m = !1, g = !1) => {
      const w = g && i ? n : r;
      return m && l.add(f), w.has(f) || w.add(f), f;
    },
    /**
     * Cancel the provided callback from running on the next frame.
     */
    cancel: (f) => {
      r.delete(f), l.delete(f);
    },
    /**
     * Execute all schedule callbacks.
     */
    process: (f) => {
      if (u = f, i) {
        s = !0;
        return;
      }
      i = !0, [n, r] = [r, n], n.forEach(d), n.clear(), i = !1, s && (s = !1, h.process(f));
    }
  };
  return h;
}
const NU = 40;
function GT(e, t) {
  let n = !1, r = !0;
  const i = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  }, s = () => n = !0, l = Hc.reduce((x, R) => (x[R] = BU(s), x), {}), { setup: u, read: d, resolveKeyframes: h, preUpdate: f, update: m, preRender: g, render: w, postRender: E } = l, b = () => {
    const x = Nr.useManualTiming ? i.timestamp : performance.now();
    n = !1, Nr.useManualTiming || (i.delta = r ? 1e3 / 60 : Math.max(Math.min(x - i.timestamp, NU), 1)), i.timestamp = x, i.isProcessing = !0, u.process(i), d.process(i), h.process(i), f.process(i), m.process(i), g.process(i), w.process(i), E.process(i), i.isProcessing = !1, n && t && (r = !1, e(b));
  }, A = () => {
    n = !0, r = !0, i.isProcessing || e(b);
  };
  return { schedule: Hc.reduce((x, R) => {
    const _ = l[R];
    return x[R] = (L, V = !1, O = !1) => (n || A(), _.schedule(L, V, O)), x;
  }, {}), cancel: (x) => {
    for (let R = 0; R < Hc.length; R++)
      l[Hc[R]].cancel(x);
  }, state: i, steps: l };
}
const { schedule: zn, cancel: mg, state: Pd } = /* @__PURE__ */ GT(typeof requestAnimationFrame < "u" ? requestAnimationFrame : Qs, !0);
let md;
function DU() {
  md = void 0;
}
const xn = {
  now: () => (md === void 0 && xn.set(Pd.isProcessing || Nr.useManualTiming ? Pd.timestamp : performance.now()), md),
  set: (e) => {
    md = e, queueMicrotask(DU);
  }
}, YT = (e) => (t) => typeof t == "string" && t.startsWith(e), qT = /* @__PURE__ */ YT("--"), jU = /* @__PURE__ */ YT("var(--"), Qy = (e) => jU(e) ? FU.test(e.split("/*")[0].trim()) : !1, FU = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu, Js = {
  test: (e) => typeof e == "number",
  parse: parseFloat,
  transform: (e) => e
}, Wl = {
  ...Js,
  transform: (e) => yo(0, 1, e)
}, Kc = {
  ...Js,
  default: 1
}, Tl = (e) => Math.round(e * 1e5) / 1e5, Jy = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
function UU(e) {
  return e == null;
}
const WU = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu, e0 = (e, t) => (n) => !!(typeof n == "string" && WU.test(n) && n.startsWith(e) || t && !UU(n) && Object.prototype.hasOwnProperty.call(n, t)), XT = (e, t, n) => (r) => {
  if (typeof r != "string")
    return r;
  const [i, s, l, u] = r.match(Jy);
  return {
    [e]: parseFloat(i),
    [t]: parseFloat(s),
    [n]: parseFloat(l),
    alpha: u !== void 0 ? parseFloat(u) : 1
  };
}, zU = (e) => yo(0, 255, e), cm = {
  ...Js,
  transform: (e) => Math.round(zU(e))
}, Gi = {
  test: /* @__PURE__ */ e0("rgb", "red"),
  parse: /* @__PURE__ */ XT("red", "green", "blue"),
  transform: ({ red: e, green: t, blue: n, alpha: r = 1 }) => "rgba(" + cm.transform(e) + ", " + cm.transform(t) + ", " + cm.transform(n) + ", " + Tl(Wl.transform(r)) + ")"
};
function HU(e) {
  let t = "", n = "", r = "", i = "";
  return e.length > 5 ? (t = e.substring(1, 3), n = e.substring(3, 5), r = e.substring(5, 7), i = e.substring(7, 9)) : (t = e.substring(1, 2), n = e.substring(2, 3), r = e.substring(3, 4), i = e.substring(4, 5), t += t, n += n, r += r, i += i), {
    red: parseInt(t, 16),
    green: parseInt(n, 16),
    blue: parseInt(r, 16),
    alpha: i ? parseInt(i, 16) / 255 : 1
  };
}
const gg = {
  test: /* @__PURE__ */ e0("#"),
  parse: HU,
  transform: Gi.transform
}, gu = /* @__NO_SIDE_EFFECTS__ */ (e) => ({
  test: (t) => typeof t == "string" && t.endsWith(e) && t.split(" ").length === 1,
  parse: parseFloat,
  transform: (t) => `${t}${e}`
}), fi = /* @__PURE__ */ gu("deg"), gs = /* @__PURE__ */ gu("%"), Re = /* @__PURE__ */ gu("px"), KU = /* @__PURE__ */ gu("vh"), GU = /* @__PURE__ */ gu("vw"), VA = {
  ...gs,
  parse: (e) => gs.parse(e) / 100,
  transform: (e) => gs.transform(e * 100)
}, ls = {
  test: /* @__PURE__ */ e0("hsl", "hue"),
  parse: /* @__PURE__ */ XT("hue", "saturation", "lightness"),
  transform: ({ hue: e, saturation: t, lightness: n, alpha: r = 1 }) => "hsla(" + Math.round(e) + ", " + gs.transform(Tl(t)) + ", " + gs.transform(Tl(n)) + ", " + Tl(Wl.transform(r)) + ")"
}, dt = {
  test: (e) => Gi.test(e) || gg.test(e) || ls.test(e),
  parse: (e) => Gi.test(e) ? Gi.parse(e) : ls.test(e) ? ls.parse(e) : gg.parse(e),
  transform: (e) => typeof e == "string" ? e : e.hasOwnProperty("red") ? Gi.transform(e) : ls.transform(e),
  getAnimatableNone: (e) => {
    const t = dt.parse(e);
    return t.alpha = 0, dt.transform(t);
  }
}, YU = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
function qU(e) {
  var t, n;
  return isNaN(e) && typeof e == "string" && (((t = e.match(Jy)) == null ? void 0 : t.length) || 0) + (((n = e.match(YU)) == null ? void 0 : n.length) || 0) > 0;
}
const ZT = "number", QT = "color", XU = "var", ZU = "var(", _A = "${}", QU = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function zl(e) {
  const t = e.toString(), n = [], r = {
    color: [],
    number: [],
    var: []
  }, i = [];
  let s = 0;
  const l = t.replace(QU, (u) => (dt.test(u) ? (r.color.push(s), i.push(QT), n.push(dt.parse(u))) : u.startsWith(ZU) ? (r.var.push(s), i.push(XU), n.push(u)) : (r.number.push(s), i.push(ZT), n.push(parseFloat(u))), ++s, _A)).split(_A);
  return { values: n, split: l, indexes: r, types: i };
}
function JT(e) {
  return zl(e).values;
}
function e$(e) {
  const { split: t, types: n } = zl(e), r = t.length;
  return (i) => {
    let s = "";
    for (let l = 0; l < r; l++)
      if (s += t[l], i[l] !== void 0) {
        const u = n[l];
        u === ZT ? s += Tl(i[l]) : u === QT ? s += dt.transform(i[l]) : s += i[l];
      }
    return s;
  };
}
const JU = (e) => typeof e == "number" ? 0 : dt.test(e) ? dt.getAnimatableNone(e) : e;
function eW(e) {
  const t = JT(e);
  return e$(e)(t.map(JU));
}
const ea = {
  test: qU,
  parse: JT,
  createTransformer: e$,
  getAnimatableNone: eW
};
function dm(e, t, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + (t - e) * 6 * n : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e;
}
function tW({ hue: e, saturation: t, lightness: n, alpha: r }) {
  e /= 360, t /= 100, n /= 100;
  let i = 0, s = 0, l = 0;
  if (!t)
    i = s = l = n;
  else {
    const u = n < 0.5 ? n * (1 + t) : n + t - n * t, d = 2 * n - u;
    i = dm(d, u, e + 1 / 3), s = dm(d, u, e), l = dm(d, u, e - 1 / 3);
  }
  return {
    red: Math.round(i * 255),
    green: Math.round(s * 255),
    blue: Math.round(l * 255),
    alpha: r
  };
}
function Md(e, t) {
  return (n) => n > 0 ? t : e;
}
const xf = (e, t, n) => e + (t - e) * n, fm = (e, t, n) => {
  const r = e * e, i = n * (t * t - r) + r;
  return i < 0 ? 0 : Math.sqrt(i);
}, nW = [gg, Gi, ls], rW = (e) => nW.find((t) => t.test(e));
function IA(e) {
  const t = rW(e);
  if (!t)
    return !1;
  let n = t.parse(e);
  return t === ls && (n = tW(n)), n;
}
const LA = (e, t) => {
  const n = IA(e), r = IA(t);
  if (!n || !r)
    return Md(e, t);
  const i = { ...n };
  return (s) => (i.red = fm(n.red, r.red, s), i.green = fm(n.green, r.green, s), i.blue = fm(n.blue, r.blue, s), i.alpha = xf(n.alpha, r.alpha, s), Gi.transform(i));
}, vg = /* @__PURE__ */ new Set(["none", "hidden"]);
function iW(e, t) {
  return vg.has(e) ? (n) => n <= 0 ? e : t : (n) => n >= 1 ? t : e;
}
function oW(e, t) {
  return (n) => xf(e, t, n);
}
function t0(e) {
  return typeof e == "number" ? oW : typeof e == "string" ? Qy(e) ? Md : dt.test(e) ? LA : lW : Array.isArray(e) ? t$ : typeof e == "object" ? dt.test(e) ? LA : sW : Md;
}
function t$(e, t) {
  const n = [...e], r = n.length, i = e.map((s, l) => t0(s)(s, t[l]));
  return (s) => {
    for (let l = 0; l < r; l++)
      n[l] = i[l](s);
    return n;
  };
}
function sW(e, t) {
  const n = { ...e, ...t }, r = {};
  for (const i in n)
    e[i] !== void 0 && t[i] !== void 0 && (r[i] = t0(e[i])(e[i], t[i]));
  return (i) => {
    for (const s in r)
      n[s] = r[s](i);
    return n;
  };
}
function aW(e, t) {
  const n = [], r = { color: 0, var: 0, number: 0 };
  for (let i = 0; i < t.values.length; i++) {
    const s = t.types[i], l = e.indexes[s][r[s]], u = e.values[l] ?? 0;
    n[i] = u, r[s]++;
  }
  return n;
}
const lW = (e, t) => {
  const n = ea.createTransformer(t), r = zl(e), i = zl(t);
  return r.indexes.var.length === i.indexes.var.length && r.indexes.color.length === i.indexes.color.length && r.indexes.number.length >= i.indexes.number.length ? vg.has(e) && !i.values.length || vg.has(t) && !r.values.length ? iW(e, t) : Af(t$(aW(r, i), i.values), n) : Md(e, t);
};
function n$(e, t, n) {
  return typeof e == "number" && typeof t == "number" && typeof n == "number" ? xf(e, t, n) : t0(e)(e, t);
}
const uW = (e) => {
  const t = ({ timestamp: n }) => e(n);
  return {
    start: (n = !0) => zn.update(t, n),
    stop: () => mg(t),
    /**
     * If we're processing this frame we can use the
     * framelocked timestamp to keep things in sync.
     */
    now: () => Pd.isProcessing ? Pd.timestamp : xn.now()
  };
}, r$ = (e, t, n = 10) => {
  let r = "";
  const i = Math.max(Math.round(t / n), 2);
  for (let s = 0; s < i; s++)
    r += Math.round(e(s / (i - 1)) * 1e4) / 1e4 + ", ";
  return `linear(${r.substring(0, r.length - 2)})`;
}, Od = 2e4;
function n0(e) {
  let t = 0;
  const n = 50;
  let r = e.next(t);
  for (; !r.done && t < Od; )
    t += n, r = e.next(t);
  return t >= Od ? 1 / 0 : t;
}
function cW(e, t = 100, n) {
  const r = n({ ...e, keyframes: [0, t] }), i = Math.min(n0(r), Od);
  return {
    type: "keyframes",
    ease: (s) => r.next(i * s).value / t,
    duration: /* @__PURE__ */ kr(i)
  };
}
const dW = 5;
function i$(e, t, n) {
  const r = Math.max(t - dW, 0);
  return BT(n - e(r), t - r);
}
const nt = {
  // Default spring physics
  stiffness: 100,
  damping: 10,
  mass: 1,
  velocity: 0,
  // Default duration/bounce-based options
  duration: 800,
  // in ms
  bounce: 0.3,
  visualDuration: 0.3,
  // in seconds
  // Rest thresholds
  restSpeed: {
    granular: 0.01,
    default: 2
  },
  restDelta: {
    granular: 5e-3,
    default: 0.5
  },
  // Limits
  minDuration: 0.01,
  // in seconds
  maxDuration: 10,
  // in seconds
  minDamping: 0.05,
  maxDamping: 1
}, hm = 1e-3;
function fW({ duration: e = nt.duration, bounce: t = nt.bounce, velocity: n = nt.velocity, mass: r = nt.mass }) {
  let i, s, l = 1 - t;
  l = yo(nt.minDamping, nt.maxDamping, l), e = yo(nt.minDuration, nt.maxDuration, /* @__PURE__ */ kr(e)), l < 1 ? (i = (h) => {
    const f = h * l, m = f * e, g = f - n, w = yg(h, l), E = Math.exp(-m);
    return hm - g / w * E;
  }, s = (h) => {
    const f = h * l * e, m = f * n + n, g = Math.pow(l, 2) * Math.pow(h, 2) * e, w = Math.exp(-f), E = yg(Math.pow(h, 2), l);
    return (-i(h) + hm > 0 ? -1 : 1) * ((m - g) * w) / E;
  }) : (i = (h) => {
    const f = Math.exp(-h * e), m = (h - n) * e + 1;
    return -hm + f * m;
  }, s = (h) => {
    const f = Math.exp(-h * e), m = (n - h) * (e * e);
    return f * m;
  });
  const u = 5 / e, d = pW(i, s, u);
  if (e = /* @__PURE__ */ Sr(e), isNaN(d))
    return {
      stiffness: nt.stiffness,
      damping: nt.damping,
      duration: e
    };
  {
    const h = Math.pow(d, 2) * r;
    return {
      stiffness: h,
      damping: l * 2 * Math.sqrt(r * h),
      duration: e
    };
  }
}
const hW = 12;
function pW(e, t, n) {
  let r = n;
  for (let i = 1; i < hW; i++)
    r = r - e(r) / t(r);
  return r;
}
function yg(e, t) {
  return e * Math.sqrt(1 - t * t);
}
const mW = ["duration", "bounce"], gW = ["stiffness", "damping", "mass"];
function PA(e, t) {
  return t.some((n) => e[n] !== void 0);
}
function vW(e) {
  let t = {
    velocity: nt.velocity,
    stiffness: nt.stiffness,
    damping: nt.damping,
    mass: nt.mass,
    isResolvedFromDuration: !1,
    ...e
  };
  if (!PA(e, gW) && PA(e, mW))
    if (e.visualDuration) {
      const n = e.visualDuration, r = 2 * Math.PI / (n * 1.2), i = r * r, s = 2 * yo(0.05, 1, 1 - (e.bounce || 0)) * Math.sqrt(i);
      t = {
        ...t,
        mass: nt.mass,
        stiffness: i,
        damping: s
      };
    } else {
      const n = fW(e);
      t = {
        ...t,
        ...n,
        mass: nt.mass
      }, t.isResolvedFromDuration = !0;
    }
  return t;
}
function Bd(e = nt.visualDuration, t = nt.bounce) {
  const n = typeof e != "object" ? {
    visualDuration: e,
    keyframes: [0, 1],
    bounce: t
  } : e;
  let { restSpeed: r, restDelta: i } = n;
  const s = n.keyframes[0], l = n.keyframes[n.keyframes.length - 1], u = { done: !1, value: s }, { stiffness: d, damping: h, mass: f, duration: m, velocity: g, isResolvedFromDuration: w } = vW({
    ...n,
    velocity: -/* @__PURE__ */ kr(n.velocity || 0)
  }), E = g || 0, b = h / (2 * Math.sqrt(d * f)), A = l - s, x = /* @__PURE__ */ kr(Math.sqrt(d / f)), R = Math.abs(A) < 5;
  r || (r = R ? nt.restSpeed.granular : nt.restSpeed.default), i || (i = R ? nt.restDelta.granular : nt.restDelta.default);
  let _;
  if (b < 1) {
    const V = yg(x, b);
    _ = (O) => {
      const D = Math.exp(-b * x * O);
      return l - D * ((E + b * x * A) / V * Math.sin(V * O) + A * Math.cos(V * O));
    };
  } else if (b === 1)
    _ = (V) => l - Math.exp(-x * V) * (A + (E + x * A) * V);
  else {
    const V = x * Math.sqrt(b * b - 1);
    _ = (O) => {
      const D = Math.exp(-b * x * O), B = Math.min(V * O, 300);
      return l - D * ((E + b * x * A) * Math.sinh(B) + V * A * Math.cosh(B)) / V;
    };
  }
  const L = {
    calculatedDuration: w && m || null,
    next: (V) => {
      const O = _(V);
      if (w)
        u.done = V >= m;
      else {
        let D = V === 0 ? E : 0;
        b < 1 && (D = V === 0 ? /* @__PURE__ */ Sr(E) : i$(_, V, O));
        const B = Math.abs(D) <= r, H = Math.abs(l - O) <= i;
        u.done = B && H;
      }
      return u.value = u.done ? l : O, u;
    },
    toString: () => {
      const V = Math.min(n0(L), Od), O = r$((D) => L.next(V * D).value, V, 30);
      return V + "ms " + O;
    },
    toTransition: () => {
    }
  };
  return L;
}
Bd.applyToOptions = (e) => {
  const t = cW(e, 100, Bd);
  return e.ease = t.ease, e.duration = /* @__PURE__ */ Sr(t.duration), e.type = "keyframes", e;
};
function wg({ keyframes: e, velocity: t = 0, power: n = 0.8, timeConstant: r = 325, bounceDamping: i = 10, bounceStiffness: s = 500, modifyTarget: l, min: u, max: d, restDelta: h = 0.5, restSpeed: f }) {
  const m = e[0], g = {
    done: !1,
    value: m
  }, w = (B) => u !== void 0 && B < u || d !== void 0 && B > d, E = (B) => u === void 0 ? d : d === void 0 || Math.abs(u - B) < Math.abs(d - B) ? u : d;
  let b = n * t;
  const A = m + b, x = l === void 0 ? A : l(A);
  x !== A && (b = x - m);
  const R = (B) => -b * Math.exp(-B / r), _ = (B) => x + R(B), L = (B) => {
    const H = R(B), J = _(B);
    g.done = Math.abs(H) <= h, g.value = g.done ? x : J;
  };
  let V, O;
  const D = (B) => {
    w(g.value) && (V = B, O = Bd({
      keyframes: [g.value, E(g.value)],
      velocity: i$(_, B, g.value),
      // TODO: This should be passing * 1000
      damping: i,
      stiffness: s,
      restDelta: h,
      restSpeed: f
    }));
  };
  return D(0), {
    calculatedDuration: null,
    next: (B) => {
      let H = !1;
      return !O && V === void 0 && (H = !0, L(B), D(B)), V !== void 0 && B >= V ? O.next(B - V) : (!H && L(B), g);
    }
  };
}
function yW(e, t, n) {
  const r = [], i = n || Nr.mix || n$, s = e.length - 1;
  for (let l = 0; l < s; l++) {
    let u = i(e[l], e[l + 1]);
    if (t) {
      const d = Array.isArray(t) ? t[l] || Qs : t;
      u = Af(d, u);
    }
    r.push(u);
  }
  return r;
}
function wW(e, t, { clamp: n = !0, ease: r, mixer: i } = {}) {
  const s = e.length;
  if (Yy(s === t.length), s === 1)
    return () => t[0];
  if (s === 2 && t[0] === t[1])
    return () => t[1];
  const l = e[0] === e[1];
  e[0] > e[s - 1] && (e = [...e].reverse(), t = [...t].reverse());
  const u = yW(t, r, i), d = u.length, h = (f) => {
    if (l && f < e[0])
      return t[0];
    let m = 0;
    if (d > 1)
      for (; m < e.length - 2 && !(f < e[m + 1]); m++)
        ;
    const g = /* @__PURE__ */ MT(e[m], e[m + 1], f);
    return u[m](g);
  };
  return n ? (f) => h(yo(e[0], e[s - 1], f)) : h;
}
function bW(e, t) {
  const n = e[e.length - 1];
  for (let r = 1; r <= t; r++) {
    const i = /* @__PURE__ */ MT(0, t, r);
    e.push(xf(n, 1, i));
  }
}
function CW(e) {
  const t = [0];
  return bW(t, e.length - 1), t;
}
function EW(e, t) {
  return e.map((n) => n * t);
}
function AW(e, t) {
  return e.map(() => t || HT).splice(0, e.length - 1);
}
function $l({ duration: e = 300, keyframes: t, times: n, ease: r = "easeInOut" }) {
  const i = PU(r) ? r.map($A) : $A(r), s = {
    done: !1,
    value: t[0]
  }, l = EW(
    // Only use the provided offsets if they're the correct length
    // TODO Maybe we should warn here if there's a length mismatch
    n && n.length === t.length ? n : CW(t),
    e
  ), u = wW(l, t, {
    ease: Array.isArray(i) ? i : AW(t, i)
  });
  return {
    calculatedDuration: e,
    next: (d) => (s.value = u(d), s.done = d >= e, s)
  };
}
const xW = (e) => e !== null;
function r0(e, { repeat: t, repeatType: n = "loop" }, r, i = 1) {
  const s = e.filter(xW), l = i < 0 || t && n !== "loop" && t % 2 === 1 ? 0 : s.length - 1;
  return !l || r === void 0 ? s[l] : r;
}
const SW = {
  decay: wg,
  inertia: wg,
  tween: $l,
  keyframes: $l,
  spring: Bd
};
function o$(e) {
  typeof e.type == "string" && (e.type = SW[e.type]);
}
let i0 = class {
  constructor() {
    this.updateFinished();
  }
  get finished() {
    return this._finished;
  }
  updateFinished() {
    this._finished = new Promise((t) => {
      this.resolve = t;
    });
  }
  notifyFinished() {
    this.resolve();
  }
  /**
   * Allows the animation to be awaited.
   *
   * @deprecated Use `finished` instead.
   */
  then(t, n) {
    return this.finished.then(t, n);
  }
};
const kW = (e) => e / 100;
let o0 = class extends i0 {
  constructor(t) {
    super(), this.state = "idle", this.startTime = null, this.isStopped = !1, this.currentTime = 0, this.holdTime = null, this.playbackSpeed = 1, this.stop = () => {
      var n, r;
      const { motionValue: i } = this.options;
      i && i.updatedAt !== xn.now() && this.tick(xn.now()), this.isStopped = !0, this.state !== "idle" && (this.teardown(), (r = (n = this.options).onStop) == null || r.call(n));
    }, this.options = t, this.initAnimation(), this.play(), t.autoplay === !1 && this.pause();
  }
  initAnimation() {
    const { options: t } = this;
    o$(t);
    const { type: n = $l, repeat: r = 0, repeatDelay: i = 0, repeatType: s, velocity: l = 0 } = t;
    let { keyframes: u } = t;
    const d = n || $l;
    d !== $l && typeof u[0] != "number" && (this.mixKeyframes = Af(kW, n$(u[0], u[1])), u = [0, 100]);
    const h = d({ ...t, keyframes: u });
    s === "mirror" && (this.mirroredGenerator = d({
      ...t,
      keyframes: [...u].reverse(),
      velocity: -l
    })), h.calculatedDuration === null && (h.calculatedDuration = n0(h));
    const { calculatedDuration: f } = h;
    this.calculatedDuration = f, this.resolvedDuration = f + i, this.totalDuration = this.resolvedDuration * (r + 1) - i, this.generator = h;
  }
  updateTime(t) {
    const n = Math.round(t - this.startTime) * this.playbackSpeed;
    this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = n;
  }
  tick(t, n = !1) {
    const { generator: r, totalDuration: i, mixKeyframes: s, mirroredGenerator: l, resolvedDuration: u, calculatedDuration: d } = this;
    if (this.startTime === null)
      return r.next(0);
    const { delay: h = 0, keyframes: f, repeat: m, repeatType: g, repeatDelay: w, type: E, onUpdate: b, finalKeyframe: A } = this.options;
    this.speed > 0 ? this.startTime = Math.min(this.startTime, t) : this.speed < 0 && (this.startTime = Math.min(t - i / this.speed, this.startTime)), n ? this.currentTime = t : this.updateTime(t);
    const x = this.currentTime - h * (this.playbackSpeed >= 0 ? 1 : -1), R = this.playbackSpeed >= 0 ? x < 0 : x > i;
    this.currentTime = Math.max(x, 0), this.state === "finished" && this.holdTime === null && (this.currentTime = i);
    let _ = this.currentTime, L = r;
    if (m) {
      const B = Math.min(this.currentTime, i) / u;
      let H = Math.floor(B), J = B % 1;
      !J && B >= 1 && (J = 1), J === 1 && H--, H = Math.min(H, m + 1), H % 2 && (g === "reverse" ? (J = 1 - J, w && (J -= w / u)) : g === "mirror" && (L = l)), _ = yo(0, 1, J) * u;
    }
    const V = R ? { done: !1, value: f[0] } : L.next(_);
    s && (V.value = s(V.value));
    let { done: O } = V;
    !R && d !== null && (O = this.playbackSpeed >= 0 ? this.currentTime >= i : this.currentTime <= 0);
    const D = this.holdTime === null && (this.state === "finished" || this.state === "running" && O);
    return D && E !== wg && (V.value = r0(f, this.options, A, this.speed)), b && b(V.value), D && this.finish(), V;
  }
  /**
   * Allows the returned animation to be awaited or promise-chained. Currently
   * resolves when the animation finishes at all but in a future update could/should
   * reject if its cancels.
   */
  then(t, n) {
    return this.finished.then(t, n);
  }
  get duration() {
    return /* @__PURE__ */ kr(this.calculatedDuration);
  }
  get time() {
    return /* @__PURE__ */ kr(this.currentTime);
  }
  set time(t) {
    var n;
    t = /* @__PURE__ */ Sr(t), this.currentTime = t, this.startTime === null || this.holdTime !== null || this.playbackSpeed === 0 ? this.holdTime = t : this.driver && (this.startTime = this.driver.now() - t / this.playbackSpeed), (n = this.driver) == null || n.start(!1);
  }
  get speed() {
    return this.playbackSpeed;
  }
  set speed(t) {
    this.updateTime(xn.now());
    const n = this.playbackSpeed !== t;
    this.playbackSpeed = t, n && (this.time = /* @__PURE__ */ kr(this.currentTime));
  }
  play() {
    var t, n;
    if (this.isStopped)
      return;
    const { driver: r = uW, startTime: i } = this.options;
    this.driver || (this.driver = r((l) => this.tick(l))), (n = (t = this.options).onPlay) == null || n.call(t);
    const s = this.driver.now();
    this.state === "finished" ? (this.updateFinished(), this.startTime = s) : this.holdTime !== null ? this.startTime = s - this.holdTime : this.startTime || (this.startTime = i ?? s), this.state === "finished" && this.speed < 0 && (this.startTime += this.calculatedDuration), this.holdTime = null, this.state = "running", this.driver.start();
  }
  pause() {
    this.state = "paused", this.updateTime(xn.now()), this.holdTime = this.currentTime;
  }
  complete() {
    this.state !== "running" && this.play(), this.state = "finished", this.holdTime = null;
  }
  finish() {
    var t, n;
    this.notifyFinished(), this.teardown(), this.state = "finished", (n = (t = this.options).onComplete) == null || n.call(t);
  }
  cancel() {
    var t, n;
    this.holdTime = null, this.startTime = 0, this.tick(0), this.teardown(), (n = (t = this.options).onCancel) == null || n.call(t);
  }
  teardown() {
    this.state = "idle", this.stopDriver(), this.startTime = this.holdTime = null;
  }
  stopDriver() {
    this.driver && (this.driver.stop(), this.driver = void 0);
  }
  sample(t) {
    return this.startTime = 0, this.tick(t, !0);
  }
  attachTimeline(t) {
    var n;
    return this.options.allowFlatten && (this.options.type = "keyframes", this.options.ease = "linear", this.initAnimation()), (n = this.driver) == null || n.stop(), t.observe(this);
  }
};
function RW(e) {
  for (let t = 1; t < e.length; t++)
    e[t] ?? (e[t] = e[t - 1]);
}
const Yi = (e) => e * 180 / Math.PI, bg = (e) => {
  const t = Yi(Math.atan2(e[1], e[0]));
  return Cg(t);
}, TW = {
  x: 4,
  y: 5,
  translateX: 4,
  translateY: 5,
  scaleX: 0,
  scaleY: 3,
  scale: (e) => (Math.abs(e[0]) + Math.abs(e[3])) / 2,
  rotate: bg,
  rotateZ: bg,
  skewX: (e) => Yi(Math.atan(e[1])),
  skewY: (e) => Yi(Math.atan(e[2])),
  skew: (e) => (Math.abs(e[1]) + Math.abs(e[2])) / 2
}, Cg = (e) => (e = e % 360, e < 0 && (e += 360), e), MA = bg, OA = (e) => Math.sqrt(e[0] * e[0] + e[1] * e[1]), BA = (e) => Math.sqrt(e[4] * e[4] + e[5] * e[5]), $W = {
  x: 12,
  y: 13,
  z: 14,
  translateX: 12,
  translateY: 13,
  translateZ: 14,
  scaleX: OA,
  scaleY: BA,
  scale: (e) => (OA(e) + BA(e)) / 2,
  rotateX: (e) => Cg(Yi(Math.atan2(e[6], e[5]))),
  rotateY: (e) => Cg(Yi(Math.atan2(-e[2], e[0]))),
  rotateZ: MA,
  rotate: MA,
  skewX: (e) => Yi(Math.atan(e[4])),
  skewY: (e) => Yi(Math.atan(e[1])),
  skew: (e) => (Math.abs(e[1]) + Math.abs(e[4])) / 2
};
function Eg(e) {
  return e.includes("scale") ? 1 : 0;
}
function Ag(e, t) {
  if (!e || e === "none")
    return Eg(t);
  const n = e.match(/^matrix3d\(([-\d.e\s,]+)\)$/u);
  let r, i;
  if (n)
    r = $W, i = n;
  else {
    const u = e.match(/^matrix\(([-\d.e\s,]+)\)$/u);
    r = TW, i = u;
  }
  if (!i)
    return Eg(t);
  const s = r[t], l = i[1].split(",").map(_W);
  return typeof s == "function" ? s(l) : l[s];
}
const VW = (e, t) => {
  const { transform: n = "none" } = getComputedStyle(e);
  return Ag(n, t);
};
function _W(e) {
  return parseFloat(e.trim());
}
const ta = [
  "transformPerspective",
  "x",
  "y",
  "z",
  "translateX",
  "translateY",
  "translateZ",
  "scale",
  "scaleX",
  "scaleY",
  "rotate",
  "rotateX",
  "rotateY",
  "rotateZ",
  "skew",
  "skewX",
  "skewY"
], na = new Set(ta), NA = (e) => e === Js || e === Re, IW = /* @__PURE__ */ new Set(["x", "y", "z"]), LW = ta.filter((e) => !IW.has(e));
function PW(e) {
  const t = [];
  return LW.forEach((n) => {
    const r = e.getValue(n);
    r !== void 0 && (t.push([n, r.get()]), r.set(n.startsWith("scale") ? 1 : 0));
  }), t;
}
const so = {
  // Dimensions
  width: ({ x: e }, { paddingLeft: t = "0", paddingRight: n = "0" }) => e.max - e.min - parseFloat(t) - parseFloat(n),
  height: ({ y: e }, { paddingTop: t = "0", paddingBottom: n = "0" }) => e.max - e.min - parseFloat(t) - parseFloat(n),
  top: (e, { top: t }) => parseFloat(t),
  left: (e, { left: t }) => parseFloat(t),
  bottom: ({ y: e }, { top: t }) => parseFloat(t) + (e.max - e.min),
  right: ({ x: e }, { left: t }) => parseFloat(t) + (e.max - e.min),
  // Transform
  x: (e, { transform: t }) => Ag(t, "x"),
  y: (e, { transform: t }) => Ag(t, "y")
};
so.translateX = so.x;
so.translateY = so.y;
const ao = /* @__PURE__ */ new Set();
let xg = !1, Sg = !1, kg = !1;
function s$() {
  if (Sg) {
    const e = Array.from(ao).filter((r) => r.needsMeasurement), t = new Set(e.map((r) => r.element)), n = /* @__PURE__ */ new Map();
    t.forEach((r) => {
      const i = PW(r);
      i.length && (n.set(r, i), r.render());
    }), e.forEach((r) => r.measureInitialState()), t.forEach((r) => {
      r.render();
      const i = n.get(r);
      i && i.forEach(([s, l]) => {
        var u;
        (u = r.getValue(s)) == null || u.set(l);
      });
    }), e.forEach((r) => r.measureEndState()), e.forEach((r) => {
      r.suspendedScrollY !== void 0 && window.scrollTo(0, r.suspendedScrollY);
    });
  }
  Sg = !1, xg = !1, ao.forEach((e) => e.complete(kg)), ao.clear();
}
function a$() {
  ao.forEach((e) => {
    e.readKeyframes(), e.needsMeasurement && (Sg = !0);
  });
}
function MW() {
  kg = !0, a$(), s$(), kg = !1;
}
let s0 = class {
  constructor(t, n, r, i, s, l = !1) {
    this.state = "pending", this.isAsync = !1, this.needsMeasurement = !1, this.unresolvedKeyframes = [...t], this.onComplete = n, this.name = r, this.motionValue = i, this.element = s, this.isAsync = l;
  }
  scheduleResolve() {
    this.state = "scheduled", this.isAsync ? (ao.add(this), xg || (xg = !0, zn.read(a$), zn.resolveKeyframes(s$))) : (this.readKeyframes(), this.complete());
  }
  readKeyframes() {
    const { unresolvedKeyframes: t, name: n, element: r, motionValue: i } = this;
    if (t[0] === null) {
      const s = i == null ? void 0 : i.get(), l = t[t.length - 1];
      if (s !== void 0)
        t[0] = s;
      else if (r && n) {
        const u = r.readValue(n, l);
        u != null && (t[0] = u);
      }
      t[0] === void 0 && (t[0] = l), i && s === void 0 && i.set(t[0]);
    }
    RW(t);
  }
  setFinalKeyframe() {
  }
  measureInitialState() {
  }
  renderEndStyles() {
  }
  measureEndState() {
  }
  complete(t = !1) {
    this.state = "complete", this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, t), ao.delete(this);
  }
  cancel() {
    this.state === "scheduled" && (ao.delete(this), this.state = "pending");
  }
  resume() {
    this.state === "pending" && this.scheduleResolve();
  }
};
const OW = (e) => e.startsWith("--");
function BW(e, t, n) {
  OW(t) ? e.style.setProperty(t, n) : e.style[t] = n;
}
const NW = /* @__PURE__ */ qy(() => window.ScrollTimeline !== void 0), DW = {};
function jW(e, t) {
  const n = /* @__PURE__ */ qy(e);
  return () => DW[t] ?? n();
}
const l$ = /* @__PURE__ */ jW(() => {
  try {
    document.createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" });
  } catch {
    return !1;
  }
  return !0;
}, "linearEasing"), yl = ([e, t, n, r]) => `cubic-bezier(${e}, ${t}, ${n}, ${r})`, DA = {
  linear: "linear",
  ease: "ease",
  easeIn: "ease-in",
  easeOut: "ease-out",
  easeInOut: "ease-in-out",
  circIn: /* @__PURE__ */ yl([0, 0.65, 0.55, 1]),
  circOut: /* @__PURE__ */ yl([0.55, 0, 1, 0.45]),
  backIn: /* @__PURE__ */ yl([0.31, 0.01, 0.66, -0.59]),
  backOut: /* @__PURE__ */ yl([0.33, 1.53, 0.69, 0.99])
};
function u$(e, t) {
  if (e)
    return typeof e == "function" ? l$() ? r$(e, t) : "ease-out" : KT(e) ? yl(e) : Array.isArray(e) ? e.map((n) => u$(n, t) || DA.easeOut) : DA[e];
}
function FW(e, t, n, { delay: r = 0, duration: i = 300, repeat: s = 0, repeatType: l = "loop", ease: u = "easeOut", times: d } = {}, h = void 0) {
  const f = {
    [t]: n
  };
  d && (f.offset = d);
  const m = u$(u, i);
  Array.isArray(m) && (f.easing = m);
  const g = {
    delay: r,
    duration: i,
    easing: Array.isArray(m) ? "linear" : m,
    fill: "both",
    iterations: s + 1,
    direction: l === "reverse" ? "alternate" : "normal"
  };
  return h && (g.pseudoElement = h), e.animate(f, g);
}
function c$(e) {
  return typeof e == "function" && "applyToOptions" in e;
}
function UW({ type: e, ...t }) {
  return c$(e) && l$() ? e.applyToOptions(t) : (t.duration ?? (t.duration = 300), t.ease ?? (t.ease = "easeOut"), t);
}
let WW = class extends i0 {
  constructor(t) {
    if (super(), this.finishedTime = null, this.isStopped = !1, !t)
      return;
    const { element: n, name: r, keyframes: i, pseudoElement: s, allowFlatten: l = !1, finalKeyframe: u, onComplete: d } = t;
    this.isPseudoElement = !!s, this.allowFlatten = l, this.options = t, Yy(typeof t.type != "string");
    const h = UW(t);
    this.animation = FW(n, r, i, h, s), h.autoplay === !1 && this.animation.pause(), this.animation.onfinish = () => {
      if (this.finishedTime = this.time, !s) {
        const f = r0(i, this.options, u, this.speed);
        this.updateMotionValue ? this.updateMotionValue(f) : BW(n, r, f), this.animation.cancel();
      }
      d == null || d(), this.notifyFinished();
    };
  }
  play() {
    this.isStopped || (this.animation.play(), this.state === "finished" && this.updateFinished());
  }
  pause() {
    this.animation.pause();
  }
  complete() {
    var t, n;
    (n = (t = this.animation).finish) == null || n.call(t);
  }
  cancel() {
    try {
      this.animation.cancel();
    } catch {
    }
  }
  stop() {
    if (this.isStopped)
      return;
    this.isStopped = !0;
    const { state: t } = this;
    t === "idle" || t === "finished" || (this.updateMotionValue ? this.updateMotionValue() : this.commitStyles(), this.isPseudoElement || this.cancel());
  }
  /**
   * WAAPI doesn't natively have any interruption capabilities.
   *
   * In this method, we commit styles back to the DOM before cancelling
   * the animation.
   *
   * This is designed to be overridden by NativeAnimationExtended, which
   * will create a renderless JS animation and sample it twice to calculate
   * its current value, "previous" value, and therefore allow
   * Motion to also correctly calculate velocity for any subsequent animation
   * while deferring the commit until the next animation frame.
   */
  commitStyles() {
    var t, n;
    this.isPseudoElement || (n = (t = this.animation).commitStyles) == null || n.call(t);
  }
  get duration() {
    var t, n;
    const r = ((n = (t = this.animation.effect) == null ? void 0 : t.getComputedTiming) == null ? void 0 : n.call(t).duration) || 0;
    return /* @__PURE__ */ kr(Number(r));
  }
  get time() {
    return /* @__PURE__ */ kr(Number(this.animation.currentTime) || 0);
  }
  set time(t) {
    this.finishedTime = null, this.animation.currentTime = /* @__PURE__ */ Sr(t);
  }
  /**
   * The playback speed of the animation.
   * 1 = normal speed, 2 = double speed, 0.5 = half speed.
   */
  get speed() {
    return this.animation.playbackRate;
  }
  set speed(t) {
    t < 0 && (this.finishedTime = null), this.animation.playbackRate = t;
  }
  get state() {
    return this.finishedTime !== null ? "finished" : this.animation.playState;
  }
  get startTime() {
    return Number(this.animation.startTime);
  }
  set startTime(t) {
    this.animation.startTime = t;
  }
  /**
   * Attaches a timeline to the animation, for instance the `ScrollTimeline`.
   */
  attachTimeline({ timeline: t, observe: n }) {
    var r;
    return this.allowFlatten && ((r = this.animation.effect) == null || r.updateTiming({ easing: "linear" })), this.animation.onfinish = null, t && NW() ? (this.animation.timeline = t, Qs) : n(this);
  }
};
const d$ = {
  anticipate: WT,
  backInOut: UT,
  circInOut: zT
};
function zW(e) {
  return e in d$;
}
function HW(e) {
  typeof e.ease == "string" && zW(e.ease) && (e.ease = d$[e.ease]);
}
const jA = 10;
let KW = class extends WW {
  constructor(t) {
    HW(t), o$(t), super(t), t.startTime && (this.startTime = t.startTime), this.options = t;
  }
  /**
   * WAAPI doesn't natively have any interruption capabilities.
   *
   * Rather than read commited styles back out of the DOM, we can
   * create a renderless JS animation and sample it twice to calculate
   * its current value, "previous" value, and therefore allow
   * Motion to calculate velocity for any subsequent animation.
   */
  updateMotionValue(t) {
    const { motionValue: n, onUpdate: r, onComplete: i, element: s, ...l } = this.options;
    if (!n)
      return;
    if (t !== void 0) {
      n.set(t);
      return;
    }
    const u = new o0({
      ...l,
      autoplay: !1
    }), d = /* @__PURE__ */ Sr(this.finishedTime ?? this.time);
    n.setWithVelocity(u.sample(d - jA).value, u.sample(d).value, jA), u.stop();
  }
};
const FA = (e, t) => t === "zIndex" ? !1 : !!(typeof e == "number" || Array.isArray(e) || typeof e == "string" && // It's animatable if we have a string
(ea.test(e) || e === "0") && // And it contains numbers and/or colors
!e.startsWith("url("));
function GW(e) {
  const t = e[0];
  if (e.length === 1)
    return !0;
  for (let n = 0; n < e.length; n++)
    if (e[n] !== t)
      return !0;
}
function YW(e, t, n, r) {
  const i = e[0];
  if (i === null)
    return !1;
  if (t === "display" || t === "visibility")
    return !0;
  const s = e[e.length - 1], l = FA(i, t), u = FA(s, t);
  return !l || !u ? !1 : GW(e) || (n === "spring" || c$(n)) && r;
}
function Rg(e) {
  e.duration = 0, e.type;
}
const qW = /* @__PURE__ */ new Set([
  "opacity",
  "clipPath",
  "filter",
  "transform"
  // TODO: Could be re-enabled now we have support for linear() easing
  // "background-color"
]), XW = /* @__PURE__ */ qy(() => Object.hasOwnProperty.call(Element.prototype, "animate"));
function ZW(e) {
  var t;
  const { motionValue: n, name: r, repeatDelay: i, repeatType: s, damping: l, type: u } = e;
  if (!(((t = n == null ? void 0 : n.owner) == null ? void 0 : t.current) instanceof HTMLElement))
    return !1;
  const { onUpdate: d, transformTemplate: h } = n.owner.getProps();
  return XW() && r && qW.has(r) && (r !== "transform" || !h) && /**
  * If we're outputting values to onUpdate then we can't use WAAPI as there's
  * no way to read the value from WAAPI every frame.
  */
  !d && !i && s !== "mirror" && l !== 0 && u !== "inertia";
}
const QW = 40;
let JW = class extends i0 {
  constructor({ autoplay: t = !0, delay: n = 0, type: r = "keyframes", repeat: i = 0, repeatDelay: s = 0, repeatType: l = "loop", keyframes: u, name: d, motionValue: h, element: f, ...m }) {
    var g;
    super(), this.stop = () => {
      var b, A;
      this._animation && (this._animation.stop(), (b = this.stopTimeline) == null || b.call(this)), (A = this.keyframeResolver) == null || A.cancel();
    }, this.createdAt = xn.now();
    const w = {
      autoplay: t,
      delay: n,
      type: r,
      repeat: i,
      repeatDelay: s,
      repeatType: l,
      name: d,
      motionValue: h,
      element: f,
      ...m
    }, E = (f == null ? void 0 : f.KeyframeResolver) || s0;
    this.keyframeResolver = new E(u, (b, A, x) => this.onKeyframesResolved(b, A, w, !x), d, h, f), (g = this.keyframeResolver) == null || g.scheduleResolve();
  }
  onKeyframesResolved(t, n, r, i) {
    this.keyframeResolver = void 0;
    const { name: s, type: l, velocity: u, delay: d, isHandoff: h, onUpdate: f } = r;
    this.resolvedAt = xn.now(), YW(t, s, l, u) || ((Nr.instantAnimations || !d) && (f == null || f(r0(t, r, n))), t[0] = t[t.length - 1], Rg(r), r.repeat = 0);
    const m = {
      startTime: i ? this.resolvedAt ? this.resolvedAt - this.createdAt > QW ? this.resolvedAt : this.createdAt : this.createdAt : void 0,
      finalKeyframe: n,
      ...r,
      keyframes: t
    }, g = !h && ZW(m) ? new KW({
      ...m,
      element: m.motionValue.owner.current
    }) : new o0(m);
    g.finished.then(() => this.notifyFinished()).catch(Qs), this.pendingTimeline && (this.stopTimeline = g.attachTimeline(this.pendingTimeline), this.pendingTimeline = void 0), this._animation = g;
  }
  get finished() {
    return this._animation ? this.animation.finished : this._finished;
  }
  then(t, n) {
    return this.finished.finally(t).then(() => {
    });
  }
  get animation() {
    var t;
    return this._animation || ((t = this.keyframeResolver) == null || t.resume(), MW()), this._animation;
  }
  get duration() {
    return this.animation.duration;
  }
  get time() {
    return this.animation.time;
  }
  set time(t) {
    this.animation.time = t;
  }
  get speed() {
    return this.animation.speed;
  }
  get state() {
    return this.animation.state;
  }
  set speed(t) {
    this.animation.speed = t;
  }
  get startTime() {
    return this.animation.startTime;
  }
  attachTimeline(t) {
    return this._animation ? this.stopTimeline = this.animation.attachTimeline(t) : this.pendingTimeline = t, () => this.stop();
  }
  play() {
    this.animation.play();
  }
  pause() {
    this.animation.pause();
  }
  complete() {
    this.animation.complete();
  }
  cancel() {
    var t;
    this._animation && this.animation.cancel(), (t = this.keyframeResolver) == null || t.cancel();
  }
};
const e6 = (
  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words
  /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u
);
function t6(e) {
  const t = e6.exec(e);
  if (!t)
    return [,];
  const [, n, r, i] = t;
  return [`--${n ?? r}`, i];
}
function f$(e, t, n = 1) {
  const [r, i] = t6(e);
  if (!r)
    return;
  const s = window.getComputedStyle(t).getPropertyValue(r);
  if (s) {
    const l = s.trim();
    return LT(l) ? parseFloat(l) : l;
  }
  return Qy(i) ? f$(i, t, n + 1) : i;
}
function h$(e, t) {
  return (e == null ? void 0 : e[t]) ?? (e == null ? void 0 : e.default) ?? e;
}
const p$ = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  ...ta
]), n6 = {
  test: (e) => e === "auto",
  parse: (e) => e
}, m$ = (e) => (t) => t.test(e), g$ = [Js, Re, gs, fi, GU, KU, n6], UA = (e) => g$.find(m$(e));
function r6(e) {
  return typeof e == "number" ? e === 0 : e !== null ? e === "none" || e === "0" || PT(e) : !0;
}
const i6 = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
function o6(e) {
  const [t, n] = e.slice(0, -1).split("(");
  if (t === "drop-shadow")
    return e;
  const [r] = n.match(Jy) || [];
  if (!r)
    return e;
  const i = n.replace(r, "");
  let s = i6.has(t) ? 1 : 0;
  return r !== n && (s *= 100), t + "(" + s + i + ")";
}
const s6 = /\b([a-z-]*)\(.*?\)/gu, Tg = {
  ...ea,
  getAnimatableNone: (e) => {
    const t = e.match(s6);
    return t ? t.map(o6).join(" ") : e;
  }
}, WA = {
  ...Js,
  transform: Math.round
}, a6 = {
  rotate: fi,
  rotateX: fi,
  rotateY: fi,
  rotateZ: fi,
  scale: Kc,
  scaleX: Kc,
  scaleY: Kc,
  scaleZ: Kc,
  skew: fi,
  skewX: fi,
  skewY: fi,
  distance: Re,
  translateX: Re,
  translateY: Re,
  translateZ: Re,
  x: Re,
  y: Re,
  z: Re,
  perspective: Re,
  transformPerspective: Re,
  opacity: Wl,
  originX: VA,
  originY: VA,
  originZ: Re
}, a0 = {
  // Border props
  borderWidth: Re,
  borderTopWidth: Re,
  borderRightWidth: Re,
  borderBottomWidth: Re,
  borderLeftWidth: Re,
  borderRadius: Re,
  radius: Re,
  borderTopLeftRadius: Re,
  borderTopRightRadius: Re,
  borderBottomRightRadius: Re,
  borderBottomLeftRadius: Re,
  // Positioning props
  width: Re,
  maxWidth: Re,
  height: Re,
  maxHeight: Re,
  top: Re,
  right: Re,
  bottom: Re,
  left: Re,
  // Spacing props
  padding: Re,
  paddingTop: Re,
  paddingRight: Re,
  paddingBottom: Re,
  paddingLeft: Re,
  margin: Re,
  marginTop: Re,
  marginRight: Re,
  marginBottom: Re,
  marginLeft: Re,
  // Misc
  backgroundPositionX: Re,
  backgroundPositionY: Re,
  ...a6,
  zIndex: WA,
  // SVG
  fillOpacity: Wl,
  strokeOpacity: Wl,
  numOctaves: WA
}, l6 = {
  ...a0,
  // Color props
  color: dt,
  backgroundColor: dt,
  outlineColor: dt,
  fill: dt,
  stroke: dt,
  // Border props
  borderColor: dt,
  borderTopColor: dt,
  borderRightColor: dt,
  borderBottomColor: dt,
  borderLeftColor: dt,
  filter: Tg,
  WebkitFilter: Tg
}, v$ = (e) => l6[e];
function y$(e, t) {
  let n = v$(e);
  return n !== Tg && (n = ea), n.getAnimatableNone ? n.getAnimatableNone(t) : void 0;
}
const u6 = /* @__PURE__ */ new Set(["auto", "none", "0"]);
function c6(e, t, n) {
  let r = 0, i;
  for (; r < e.length && !i; ) {
    const s = e[r];
    typeof s == "string" && !u6.has(s) && zl(s).values.length && (i = e[r]), r++;
  }
  if (i && n)
    for (const s of t)
      e[s] = y$(n, i);
}
let d6 = class extends s0 {
  constructor(t, n, r, i, s) {
    super(t, n, r, i, s, !0);
  }
  readKeyframes() {
    const { unresolvedKeyframes: t, element: n, name: r } = this;
    if (!n || !n.current)
      return;
    super.readKeyframes();
    for (let d = 0; d < t.length; d++) {
      let h = t[d];
      if (typeof h == "string" && (h = h.trim(), Qy(h))) {
        const f = f$(h, n.current);
        f !== void 0 && (t[d] = f), d === t.length - 1 && (this.finalKeyframe = h);
      }
    }
    if (this.resolveNoneKeyframes(), !p$.has(r) || t.length !== 2)
      return;
    const [i, s] = t, l = UA(i), u = UA(s);
    if (l !== u)
      if (NA(l) && NA(u))
        for (let d = 0; d < t.length; d++) {
          const h = t[d];
          typeof h == "string" && (t[d] = parseFloat(h));
        }
      else so[r] && (this.needsMeasurement = !0);
  }
  resolveNoneKeyframes() {
    const { unresolvedKeyframes: t, name: n } = this, r = [];
    for (let i = 0; i < t.length; i++)
      (t[i] === null || r6(t[i])) && r.push(i);
    r.length && c6(t, r, n);
  }
  measureInitialState() {
    const { element: t, unresolvedKeyframes: n, name: r } = this;
    if (!t || !t.current)
      return;
    r === "height" && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = so[r](t.measureViewportBox(), window.getComputedStyle(t.current)), n[0] = this.measuredOrigin;
    const i = n[n.length - 1];
    i !== void 0 && t.getValue(r, i).jump(i, !1);
  }
  measureEndState() {
    var t;
    const { element: n, name: r, unresolvedKeyframes: i } = this;
    if (!n || !n.current)
      return;
    const s = n.getValue(r);
    s && s.jump(this.measuredOrigin, !1);
    const l = i.length - 1, u = i[l];
    i[l] = so[r](n.measureViewportBox(), window.getComputedStyle(n.current)), u !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = u), (t = this.removedTransforms) != null && t.length && this.removedTransforms.forEach(([d, h]) => {
      n.getValue(d).set(h);
    }), this.resolveNoneKeyframes();
  }
};
function f6(e, t, n) {
  if (e instanceof EventTarget)
    return [e];
  if (typeof e == "string") {
    const i = document.querySelectorAll(e);
    return i ? Array.from(i) : [];
  }
  return Array.from(e);
}
const w$ = (e, t) => t && typeof e == "number" ? t.transform(e) : e;
function h6(e) {
  return kU(e) && "offsetHeight" in e;
}
const zA = 30, p6 = (e) => !isNaN(parseFloat(e));
let m6 = class {
  /**
   * @param init - The initiating value
   * @param config - Optional configuration options
   *
   * -  `transformer`: A function to transform incoming values with.
   */
  constructor(t, n = {}) {
    this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = (r) => {
      var i;
      const s = xn.now();
      if (this.updatedAt !== s && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(r), this.current !== this.prev && ((i = this.events.change) == null || i.notify(this.current), this.dependents))
        for (const l of this.dependents)
          l.dirty();
    }, this.hasAnimated = !1, this.setCurrent(t), this.owner = n.owner;
  }
  setCurrent(t) {
    this.current = t, this.updatedAt = xn.now(), this.canTrackVelocity === null && t !== void 0 && (this.canTrackVelocity = p6(this.current));
  }
  setPrevFrameValue(t = this.current) {
    this.prevFrameValue = t, this.prevUpdatedAt = this.updatedAt;
  }
  /**
   * Adds a function that will be notified when the `MotionValue` is updated.
   *
   * It returns a function that, when called, will cancel the subscription.
   *
   * When calling `onChange` inside a React component, it should be wrapped with the
   * `useEffect` hook. As it returns an unsubscribe function, this should be returned
   * from the `useEffect` function to ensure you don't add duplicate subscribers..
   *
   * ```jsx
   * export const MyComponent = () => {
   *   const x = useMotionValue(0)
   *   const y = useMotionValue(0)
   *   const opacity = useMotionValue(1)
   *
   *   useEffect(() => {
   *     function updateOpacity() {
   *       const maxXY = Math.max(x.get(), y.get())
   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
   *       opacity.set(newOpacity)
   *     }
   *
   *     const unsubscribeX = x.on("change", updateOpacity)
   *     const unsubscribeY = y.on("change", updateOpacity)
   *
   *     return () => {
   *       unsubscribeX()
   *       unsubscribeY()
   *     }
   *   }, [])
   *
   *   return <motion.div style={{ x }} />
   * }
   * ```
   *
   * @param subscriber - A function that receives the latest value.
   * @returns A function that, when called, will cancel this subscription.
   *
   * @deprecated
   */
  onChange(t) {
    return this.on("change", t);
  }
  on(t, n) {
    this.events[t] || (this.events[t] = new OT());
    const r = this.events[t].add(n);
    return t === "change" ? () => {
      r(), zn.read(() => {
        this.events.change.getSize() || this.stop();
      });
    } : r;
  }
  clearListeners() {
    for (const t in this.events)
      this.events[t].clear();
  }
  /**
   * Attaches a passive effect to the `MotionValue`.
   */
  attach(t, n) {
    this.passiveEffect = t, this.stopPassiveEffect = n;
  }
  /**
   * Sets the state of the `MotionValue`.
   *
   * @remarks
   *
   * ```jsx
   * const x = useMotionValue(0)
   * x.set(10)
   * ```
   *
   * @param latest - Latest value to set.
   * @param render - Whether to notify render subscribers. Defaults to `true`
   *
   * @public
   */
  set(t) {
    this.passiveEffect ? this.passiveEffect(t, this.updateAndNotify) : this.updateAndNotify(t);
  }
  setWithVelocity(t, n, r) {
    this.set(n), this.prev = void 0, this.prevFrameValue = t, this.prevUpdatedAt = this.updatedAt - r;
  }
  /**
   * Set the state of the `MotionValue`, stopping any active animations,
   * effects, and resets velocity to `0`.
   */
  jump(t, n = !0) {
    this.updateAndNotify(t), this.prev = t, this.prevUpdatedAt = this.prevFrameValue = void 0, n && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
  dirty() {
    var t;
    (t = this.events.change) == null || t.notify(this.current);
  }
  addDependent(t) {
    this.dependents || (this.dependents = /* @__PURE__ */ new Set()), this.dependents.add(t);
  }
  removeDependent(t) {
    this.dependents && this.dependents.delete(t);
  }
  /**
   * Returns the latest state of `MotionValue`
   *
   * @returns - The latest state of `MotionValue`
   *
   * @public
   */
  get() {
    return this.current;
  }
  /**
   * @public
   */
  getPrevious() {
    return this.prev;
  }
  /**
   * Returns the latest velocity of `MotionValue`
   *
   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
   *
   * @public
   */
  getVelocity() {
    const t = xn.now();
    if (!this.canTrackVelocity || this.prevFrameValue === void 0 || t - this.updatedAt > zA)
      return 0;
    const n = Math.min(this.updatedAt - this.prevUpdatedAt, zA);
    return BT(parseFloat(this.current) - parseFloat(this.prevFrameValue), n);
  }
  /**
   * Registers a new animation to control this `MotionValue`. Only one
   * animation can drive a `MotionValue` at one time.
   *
   * ```jsx
   * value.start()
   * ```
   *
   * @param animation - A function that starts the provided animation
   */
  start(t) {
    return this.stop(), new Promise((n) => {
      this.hasAnimated = !0, this.animation = t(n), this.events.animationStart && this.events.animationStart.notify();
    }).then(() => {
      this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation();
    });
  }
  /**
   * Stop the currently active animation.
   *
   * @public
   */
  stop() {
    this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation();
  }
  /**
   * Returns `true` if this value is currently animating.
   *
   * @public
   */
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  /**
   * Destroy and clean up subscribers to this `MotionValue`.
   *
   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
   * created a `MotionValue` via the `motionValue` function.
   *
   * @public
   */
  destroy() {
    var t, n;
    (t = this.dependents) == null || t.clear(), (n = this.events.destroy) == null || n.notify(), this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
};
function Nd(e, t) {
  return new m6(e, t);
}
const { schedule: g6 } = /* @__PURE__ */ GT(queueMicrotask, !1), v6 = {
  y: !1
};
function y6() {
  return v6.y;
}
function b$(e, t) {
  const n = f6(e), r = new AbortController(), i = {
    passive: !0,
    ...t,
    signal: r.signal
  };
  return [n, i, () => r.abort()];
}
function HA(e) {
  return !(e.pointerType === "touch" || y6());
}
function w6(e, t, n = {}) {
  const [r, i, s] = b$(e, n), l = (u) => {
    if (!HA(u))
      return;
    const { target: d } = u, h = t(d, u);
    if (typeof h != "function" || !d)
      return;
    const f = (m) => {
      HA(m) && (h(m), d.removeEventListener("pointerleave", f));
    };
    d.addEventListener("pointerleave", f, i);
  };
  return r.forEach((u) => {
    u.addEventListener("pointerenter", l, i);
  }), s;
}
const C$ = (e, t) => t ? e === t ? !0 : C$(e, t.parentElement) : !1, b6 = (e) => e.pointerType === "mouse" ? typeof e.button != "number" || e.button <= 0 : e.isPrimary !== !1, C6 = /* @__PURE__ */ new Set([
  "BUTTON",
  "INPUT",
  "SELECT",
  "TEXTAREA",
  "A"
]);
function E6(e) {
  return C6.has(e.tagName) || e.tabIndex !== -1;
}
const gd = /* @__PURE__ */ new WeakSet();
function KA(e) {
  return (t) => {
    t.key === "Enter" && e(t);
  };
}
function pm(e, t) {
  e.dispatchEvent(new PointerEvent("pointer" + t, { isPrimary: !0, bubbles: !0 }));
}
const A6 = (e, t) => {
  const n = e.currentTarget;
  if (!n)
    return;
  const r = KA(() => {
    if (gd.has(n))
      return;
    pm(n, "down");
    const i = KA(() => {
      pm(n, "up");
    }), s = () => pm(n, "cancel");
    n.addEventListener("keyup", i, t), n.addEventListener("blur", s, t);
  });
  n.addEventListener("keydown", r, t), n.addEventListener("blur", () => n.removeEventListener("keydown", r), t);
};
function GA(e) {
  return b6(e) && !0;
}
function x6(e, t, n = {}) {
  const [r, i, s] = b$(e, n), l = (u) => {
    const d = u.currentTarget;
    if (!GA(u))
      return;
    gd.add(d);
    const h = t(d, u), f = (w, E) => {
      window.removeEventListener("pointerup", m), window.removeEventListener("pointercancel", g), gd.has(d) && gd.delete(d), GA(w) && typeof h == "function" && h(w, { success: E });
    }, m = (w) => {
      f(w, d === window || d === document || n.useGlobalTarget || C$(d, w.target));
    }, g = (w) => {
      f(w, !1);
    };
    window.addEventListener("pointerup", m, i), window.addEventListener("pointercancel", g, i);
  };
  return r.forEach((u) => {
    (n.useGlobalTarget ? window : u).addEventListener("pointerdown", l, i), h6(u) && (u.addEventListener("focus", (d) => A6(d, i)), !E6(u) && !u.hasAttribute("tabindex") && (u.tabIndex = 0));
  }), s;
}
const Nt = (e) => !!(e && e.getVelocity), S6 = [...g$, dt, ea], k6 = (e) => S6.find(m$(e)), E$ = C.createContext({
  transformPagePoint: (e) => e,
  isStatic: !1,
  reducedMotion: "never"
}), l0 = C.createContext({ strict: !1 }), YA = {
  animation: [
    "animate",
    "variants",
    "whileHover",
    "whileTap",
    "exit",
    "whileInView",
    "whileFocus",
    "whileDrag"
  ],
  exit: ["exit"],
  drag: ["drag", "dragControls"],
  focus: ["whileFocus"],
  hover: ["whileHover", "onHoverStart", "onHoverEnd"],
  tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
  pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
  inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
  layout: ["layout", "layoutId"]
}, js = {};
for (const e in YA)
  js[e] = {
    isEnabled: (t) => YA[e].some((n) => !!t[n])
  };
function qA(e) {
  for (const t in e)
    js[t] = {
      ...js[t],
      ...e[t]
    };
}
function R6({ children: e, features: t, strict: n = !1 }) {
  const [, r] = C.useState(!mm(t)), i = C.useRef(void 0);
  if (!mm(t)) {
    const { renderer: s, ...l } = t;
    i.current = s, qA(l);
  }
  return C.useEffect(() => {
    mm(t) && t().then(({ renderer: s, ...l }) => {
      qA(l), i.current = s, r(!0);
    });
  }, []), I.jsx(l0.Provider, { value: { renderer: i.current, strict: n }, children: e });
}
function mm(e) {
  return typeof e == "function";
}
const T6 = /* @__PURE__ */ new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "custom",
  "inherit",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "globalTapTarget",
  "ignoreStrict",
  "viewport"
]);
function u0(e) {
  return e.startsWith("while") || e.startsWith("drag") && e !== "draggable" || e.startsWith("layout") || e.startsWith("onTap") || e.startsWith("onPan") || e.startsWith("onLayout") || T6.has(e);
}
let A$ = (e) => !u0(e);
function $6(e) {
  typeof e == "function" && (A$ = (t) => t.startsWith("on") ? !u0(t) : e(t));
}
try {
  $6(require("@emotion/is-prop-valid").default);
} catch {
}
function V6(e, t, n) {
  const r = {};
  for (const i in e)
    i === "values" && typeof e.values == "object" || (A$(i) || n === !0 && u0(i) || // If trying to use native HTML drag events, forward drag listeners
    e.draggable && i.startsWith("onDrag")) && (r[i] = e[i]);
  return r;
}
const Sf = /* @__PURE__ */ C.createContext({});
function kf(e) {
  return e !== null && typeof e == "object" && typeof e.start == "function";
}
function Hl(e) {
  return typeof e == "string" || Array.isArray(e);
}
const c0 = [
  "animate",
  "whileInView",
  "whileFocus",
  "whileHover",
  "whileTap",
  "whileDrag",
  "exit"
], d0 = ["initial", ...c0];
function Rf(e) {
  return kf(e.animate) || d0.some((t) => Hl(e[t]));
}
function x$(e) {
  return !!(Rf(e) || e.variants);
}
function _6(e, t) {
  if (Rf(e)) {
    const { initial: n, animate: r } = e;
    return {
      initial: n === !1 || Hl(n) ? n : void 0,
      animate: Hl(r) ? r : void 0
    };
  }
  return e.inherit !== !1 ? t : {};
}
function I6(e) {
  const { initial: t, animate: n } = _6(e, C.useContext(Sf));
  return C.useMemo(() => ({ initial: t, animate: n }), [XA(t), XA(n)]);
}
function XA(e) {
  return Array.isArray(e) ? e.join(" ") : e;
}
const L6 = {};
function S$(e, { layout: t, layoutId: n }) {
  return na.has(e) || e.startsWith("origin") || (t || n !== void 0) && (!!L6[e] || e === "opacity");
}
const P6 = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
}, M6 = ta.length;
function O6(e, t, n) {
  let r = "", i = !0;
  for (let s = 0; s < M6; s++) {
    const l = ta[s], u = e[l];
    if (u === void 0)
      continue;
    let d = !0;
    if (typeof u == "number" ? d = u === (l.startsWith("scale") ? 1 : 0) : d = parseFloat(u) === 0, !d || n) {
      const h = w$(u, a0[l]);
      if (!d) {
        i = !1;
        const f = P6[l] || l;
        r += `${f}(${h}) `;
      }
      n && (t[l] = h);
    }
  }
  return r = r.trim(), n ? r = n(t, i ? "" : r) : i && (r = "none"), r;
}
function f0(e, t, n) {
  const { style: r, vars: i, transformOrigin: s } = e;
  let l = !1, u = !1;
  for (const d in t) {
    const h = t[d];
    if (na.has(d)) {
      l = !0;
      continue;
    } else if (qT(d)) {
      i[d] = h;
      continue;
    } else {
      const f = w$(h, a0[d]);
      d.startsWith("origin") ? (u = !0, s[d] = f) : r[d] = f;
    }
  }
  if (t.transform || (l || n ? r.transform = O6(t, e.transform, n) : r.transform && (r.transform = "none")), u) {
    const { originX: d = "50%", originY: h = "50%", originZ: f = 0 } = s;
    r.transformOrigin = `${d} ${h} ${f}`;
  }
}
const h0 = () => ({
  style: {},
  transform: {},
  transformOrigin: {},
  vars: {}
});
function k$(e, t, n) {
  for (const r in t)
    !Nt(t[r]) && !S$(r, n) && (e[r] = t[r]);
}
function B6({ transformTemplate: e }, t) {
  return C.useMemo(() => {
    const n = h0();
    return f0(n, t, e), Object.assign({}, n.vars, n.style);
  }, [t]);
}
function N6(e, t) {
  const n = e.style || {}, r = {};
  return k$(r, n, e), Object.assign(r, B6(e, t)), r;
}
function D6(e, t) {
  const n = {}, r = N6(e, t);
  return e.drag && e.dragListener !== !1 && (n.draggable = !1, r.userSelect = r.WebkitUserSelect = r.WebkitTouchCallout = "none", r.touchAction = e.drag === !0 ? "none" : `pan-${e.drag === "x" ? "y" : "x"}`), e.tabIndex === void 0 && (e.onTap || e.onTapStart || e.whileTap) && (n.tabIndex = 0), n.style = r, n;
}
const j6 = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
}, F6 = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function U6(e, t, n = 1, r = 0, i = !0) {
  e.pathLength = 1;
  const s = i ? j6 : F6;
  e[s.offset] = Re.transform(-r);
  const l = Re.transform(t), u = Re.transform(n);
  e[s.array] = `${l} ${u}`;
}
function R$(e, {
  attrX: t,
  attrY: n,
  attrScale: r,
  pathLength: i,
  pathSpacing: s = 1,
  pathOffset: l = 0,
  // This is object creation, which we try to avoid per-frame.
  ...u
}, d, h, f) {
  if (f0(e, u, h), d) {
    e.style.viewBox && (e.attrs.viewBox = e.style.viewBox);
    return;
  }
  e.attrs = e.style, e.style = {};
  const { attrs: m, style: g } = e;
  m.transform && (g.transform = m.transform, delete m.transform), (g.transform || m.transformOrigin) && (g.transformOrigin = m.transformOrigin ?? "50% 50%", delete m.transformOrigin), g.transform && (g.transformBox = (f == null ? void 0 : f.transformBox) ?? "fill-box", delete m.transformBox), t !== void 0 && (m.x = t), n !== void 0 && (m.y = n), r !== void 0 && (m.scale = r), i !== void 0 && U6(m, i, s, l, !1);
}
const T$ = () => ({
  ...h0(),
  attrs: {}
}), $$ = (e) => typeof e == "string" && e.toLowerCase() === "svg";
function W6(e, t, n, r) {
  const i = C.useMemo(() => {
    const s = T$();
    return R$(s, t, $$(r), e.transformTemplate, e.style), {
      ...s.attrs,
      style: { ...s.style }
    };
  }, [t]);
  if (e.style) {
    const s = {};
    k$(s, e.style, e), i.style = { ...s, ...i.style };
  }
  return i;
}
const z6 = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view"
];
function p0(e) {
  return (
    /**
     * If it's not a string, it's a custom React component. Currently we only support
     * HTML custom React components.
     */
    typeof e != "string" || /**
    * If it contains a dash, the element is a custom HTML webcomponent.
    */
    e.includes("-") ? !1 : (
      /**
       * If it's in our list of lowercase SVG tags, it's an SVG component
       */
      !!(z6.indexOf(e) > -1 || /**
      * If it contains a capital letter, it's an SVG component
      */
      /[A-Z]/u.test(e))
    )
  );
}
function H6(e, t, n, { latestValues: r }, i, s = !1) {
  const l = (p0(e) ? W6 : D6)(t, r, i, e), u = V6(t, typeof e == "string", s), d = e !== C.Fragment ? { ...u, ...l, ref: n } : {}, { children: h } = t, f = C.useMemo(() => Nt(h) ? h.get() : h, [h]);
  return C.createElement(e, {
    ...d,
    children: f
  });
}
function ZA(e) {
  const t = [{}, {}];
  return e == null || e.values.forEach((n, r) => {
    t[0][r] = n.get(), t[1][r] = n.getVelocity();
  }), t;
}
function m0(e, t, n, r) {
  if (typeof t == "function") {
    const [i, s] = ZA(r);
    t = t(n !== void 0 ? n : e.custom, i, s);
  }
  if (typeof t == "string" && (t = e.variants && e.variants[t]), typeof t == "function") {
    const [i, s] = ZA(r);
    t = t(n !== void 0 ? n : e.custom, i, s);
  }
  return t;
}
function K6(e) {
  return Nt(e) ? e.get() : e;
}
function G6({ scrapeMotionValuesFromProps: e, createRenderState: t }, n, r, i) {
  return {
    latestValues: Y6(n, r, i, e),
    renderState: t()
  };
}
function Y6(e, t, n, r) {
  const i = {}, s = r(e, {});
  for (const g in s)
    i[g] = K6(s[g]);
  let { initial: l, animate: u } = e;
  const d = Rf(e), h = x$(e);
  t && h && !d && e.inherit !== !1 && (l === void 0 && (l = t.initial), u === void 0 && (u = t.animate));
  let f = n ? n.initial === !1 : !1;
  f = f || l === !1;
  const m = f ? u : l;
  if (m && typeof m != "boolean" && !kf(m)) {
    const g = Array.isArray(m) ? m : [m];
    for (let w = 0; w < g.length; w++) {
      const E = m0(e, g[w]);
      if (E) {
        const { transitionEnd: b, transition: A, ...x } = E;
        for (const R in x) {
          let _ = x[R];
          if (Array.isArray(_)) {
            const L = f ? _.length - 1 : 0;
            _ = _[L];
          }
          _ !== null && (i[R] = _);
        }
        for (const R in b)
          i[R] = b[R];
      }
    }
  }
  return i;
}
const V$ = (e) => (t, n) => {
  const r = C.useContext(Sf), i = C.useContext(IT), s = () => G6(e, t, r, i);
  return n ? s() : EU(s);
};
function g0(e, t, n) {
  var r;
  const { style: i } = e, s = {};
  for (const l in i)
    (Nt(i[l]) || t.style && Nt(t.style[l]) || S$(l, e) || ((r = n == null ? void 0 : n.getValue(l)) == null ? void 0 : r.liveStyle) !== void 0) && (s[l] = i[l]);
  return s;
}
const q6 = /* @__PURE__ */ V$({
  scrapeMotionValuesFromProps: g0,
  createRenderState: h0
});
function _$(e, t, n) {
  const r = g0(e, t, n);
  for (const i in e)
    if (Nt(e[i]) || Nt(t[i])) {
      const s = ta.indexOf(i) !== -1 ? "attr" + i.charAt(0).toUpperCase() + i.substring(1) : i;
      r[s] = e[i];
    }
  return r;
}
const X6 = /* @__PURE__ */ V$({
  scrapeMotionValuesFromProps: _$,
  createRenderState: T$
}), Z6 = Symbol.for("motionComponentSymbol");
function I$(e) {
  return e && typeof e == "object" && Object.prototype.hasOwnProperty.call(e, "current");
}
function Q6(e, t, n) {
  return C.useCallback(
    (r) => {
      r && e.onMount && e.onMount(r), t && (r ? t.mount(r) : t.unmount()), n && (typeof n == "function" ? n(r) : I$(n) && (n.current = r));
    },
    /**
     * Only pass a new ref callback to React if we've received a visual element
     * factory. Otherwise we'll be mounting/remounting every time externalRef
     * or other dependencies change.
     */
    [t]
  );
}
const v0 = (e) => e.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(), J6 = "framerAppearId", L$ = "data-" + v0(J6), ez = C.createContext({});
function tz(e, t, n, r, i) {
  var s, l;
  const { visualElement: u } = C.useContext(Sf), d = C.useContext(l0), h = C.useContext(IT), f = C.useContext(E$).reducedMotion, m = C.useRef(null);
  r = r || d.renderer, !m.current && r && (m.current = r(e, {
    visualState: t,
    parent: u,
    props: n,
    presenceContext: h,
    blockInitialAnimation: h ? h.initial === !1 : !1,
    reducedMotionConfig: f
  }));
  const g = m.current, w = C.useContext(ez);
  g && !g.projection && i && (g.type === "html" || g.type === "svg") && nz(m.current, n, i, w);
  const E = C.useRef(!1);
  C.useInsertionEffect(() => {
    g && E.current && g.update(n, h);
  });
  const b = n[L$], A = C.useRef(!!b && !((s = window.MotionHandoffIsComplete) != null && s.call(window, b)) && ((l = window.MotionHasOptimisedAnimation) == null ? void 0 : l.call(window, b)));
  return AU(() => {
    g && (E.current = !0, window.MotionIsMounted = !0, g.updateFeatures(), g.scheduleRenderMicrotask(), A.current && g.animationState && g.animationState.animateChanges());
  }), C.useEffect(() => {
    g && (!A.current && g.animationState && g.animationState.animateChanges(), A.current && (queueMicrotask(() => {
      var x;
      (x = window.MotionHandoffMarkAsComplete) == null || x.call(window, b);
    }), A.current = !1), g.enteringChildren = void 0);
  }), g;
}
function nz(e, t, n, r) {
  const { layoutId: i, layout: s, drag: l, dragConstraints: u, layoutScroll: d, layoutRoot: h, layoutCrossfade: f } = t;
  e.projection = new n(e.latestValues, t["data-framer-portal-id"] ? void 0 : P$(e.parent)), e.projection.setOptions({
    layoutId: i,
    layout: s,
    alwaysMeasureLayout: !!l || u && I$(u),
    visualElement: e,
    /**
     * TODO: Update options in an effect. This could be tricky as it'll be too late
     * to update by the time layout animations run.
     * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
     * ensuring it gets called if there's no potential layout animations.
     *
     */
    animationType: typeof s == "string" ? s : "both",
    initialPromotionConfig: r,
    crossfade: f,
    layoutScroll: d,
    layoutRoot: h
  });
}
function P$(e) {
  if (e)
    return e.options.allowProjection !== !1 ? e.projection : P$(e.parent);
}
function rz(e, { forwardMotionProps: t = !1 } = {}, n, r) {
  const i = p0(e) ? X6 : q6;
  function s(u, d) {
    let h;
    const f = {
      ...C.useContext(E$),
      ...u,
      layoutId: iz(u)
    }, { isStatic: m } = f, g = I6(u), w = i(u, m);
    if (!m && Gy) {
      oz();
      const E = sz(f);
      h = E.MeasureLayout, g.visualElement = tz(e, w, f, r, E.ProjectionNode);
    }
    return I.jsxs(Sf.Provider, { value: g, children: [h && g.visualElement ? I.jsx(h, { visualElement: g.visualElement, ...f }) : null, H6(e, u, Q6(w, g.visualElement, d), w, m, t)] });
  }
  s.displayName = `motion.${e}`;
  const l = C.forwardRef(s);
  return l[Z6] = e, l;
}
function iz({ layoutId: e }) {
  const t = C.useContext(CU).id;
  return t && e !== void 0 ? t + "-" + e : e;
}
function oz(e, t) {
  C.useContext(l0).strict;
}
function sz(e) {
  const { drag: t, layout: n } = js;
  if (!t && !n)
    return {};
  const r = { ...t, ...n };
  return {
    MeasureLayout: t != null && t.isEnabled(e) || n != null && n.isEnabled(e) ? r.MeasureLayout : void 0,
    ProjectionNode: r.ProjectionNode
  };
}
function az({ top: e, left: t, right: n, bottom: r }) {
  return {
    x: { min: t, max: n },
    y: { min: e, max: r }
  };
}
function lz(e, t) {
  if (!t)
    return e;
  const n = t({ x: e.left, y: e.top }), r = t({ x: e.right, y: e.bottom });
  return {
    top: n.y,
    left: n.x,
    bottom: r.y,
    right: r.x
  };
}
function uz(e, t) {
  return az(lz(e.getBoundingClientRect(), t));
}
const QA = () => ({ min: 0, max: 0 }), M$ = () => ({
  x: QA(),
  y: QA()
}), $g = { current: null }, O$ = { current: !1 };
function cz() {
  if (O$.current = !0, !!Gy)
    if (window.matchMedia) {
      const e = window.matchMedia("(prefers-reduced-motion)"), t = () => $g.current = e.matches;
      e.addEventListener("change", t), t();
    } else
      $g.current = !1;
}
const dz = /* @__PURE__ */ new WeakMap();
function fz(e, t, n) {
  for (const r in t) {
    const i = t[r], s = n[r];
    if (Nt(i))
      e.addValue(r, i);
    else if (Nt(s))
      e.addValue(r, Nd(i, { owner: e }));
    else if (s !== i)
      if (e.hasValue(r)) {
        const l = e.getValue(r);
        l.liveStyle === !0 ? l.jump(i) : l.hasAnimated || l.set(i);
      } else {
        const l = e.getStaticValue(r);
        e.addValue(r, Nd(l !== void 0 ? l : i, { owner: e }));
      }
  }
  for (const r in n)
    t[r] === void 0 && e.removeValue(r);
  return t;
}
const JA = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete"
];
let hz = class {
  /**
   * This method takes React props and returns found MotionValues. For example, HTML
   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
   *
   * This isn't an abstract method as it needs calling in the constructor, but it is
   * intended to be one.
   */
  scrapeMotionValuesFromProps(t, n, r) {
    return {};
  }
  constructor({ parent: t, props: n, presenceContext: r, reducedMotionConfig: i, blockInitialAnimation: s, visualState: l }, u = {}) {
    this.current = null, this.children = /* @__PURE__ */ new Set(), this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = /* @__PURE__ */ new Map(), this.KeyframeResolver = s0, this.features = {}, this.valueSubscriptions = /* @__PURE__ */ new Map(), this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => {
      this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection));
    }, this.renderScheduledAt = 0, this.scheduleRender = () => {
      const g = xn.now();
      this.renderScheduledAt < g && (this.renderScheduledAt = g, zn.render(this.render, !1, !0));
    };
    const { latestValues: d, renderState: h } = l;
    this.latestValues = d, this.baseTarget = { ...d }, this.initialValues = n.initial ? { ...d } : {}, this.renderState = h, this.parent = t, this.props = n, this.presenceContext = r, this.depth = t ? t.depth + 1 : 0, this.reducedMotionConfig = i, this.options = u, this.blockInitialAnimation = !!s, this.isControllingVariants = Rf(n), this.isVariantNode = x$(n), this.isVariantNode && (this.variantChildren = /* @__PURE__ */ new Set()), this.manuallyAnimateOnMount = !!(t && t.current);
    const { willChange: f, ...m } = this.scrapeMotionValuesFromProps(n, {}, this);
    for (const g in m) {
      const w = m[g];
      d[g] !== void 0 && Nt(w) && w.set(d[g]);
    }
  }
  mount(t) {
    var n;
    this.current = t, dz.set(t, this), this.projection && !this.projection.instance && this.projection.mount(t), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((r, i) => this.bindToMotionValue(i, r)), O$.current || cz(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : $g.current, (n = this.parent) == null || n.addChild(this), this.update(this.props, this.presenceContext);
  }
  unmount() {
    var t;
    this.projection && this.projection.unmount(), mg(this.notifyUpdate), mg(this.render), this.valueSubscriptions.forEach((n) => n()), this.valueSubscriptions.clear(), this.removeFromVariantTree && this.removeFromVariantTree(), (t = this.parent) == null || t.removeChild(this);
    for (const n in this.events)
      this.events[n].clear();
    for (const n in this.features) {
      const r = this.features[n];
      r && (r.unmount(), r.isMounted = !1);
    }
    this.current = null;
  }
  addChild(t) {
    this.children.add(t), this.enteringChildren ?? (this.enteringChildren = /* @__PURE__ */ new Set()), this.enteringChildren.add(t);
  }
  removeChild(t) {
    this.children.delete(t), this.enteringChildren && this.enteringChildren.delete(t);
  }
  bindToMotionValue(t, n) {
    this.valueSubscriptions.has(t) && this.valueSubscriptions.get(t)();
    const r = na.has(t);
    r && this.onBindTransform && this.onBindTransform();
    const i = n.on("change", (l) => {
      this.latestValues[t] = l, this.props.onUpdate && zn.preRender(this.notifyUpdate), r && this.projection && (this.projection.isTransformDirty = !0), this.scheduleRender();
    });
    let s;
    window.MotionCheckAppearSync && (s = window.MotionCheckAppearSync(this, t, n)), this.valueSubscriptions.set(t, () => {
      i(), s && s(), n.owner && n.stop();
    });
  }
  sortNodePosition(t) {
    return !this.current || !this.sortInstanceNodePosition || this.type !== t.type ? 0 : this.sortInstanceNodePosition(this.current, t.current);
  }
  updateFeatures() {
    let t = "animation";
    for (t in js) {
      const n = js[t];
      if (!n)
        continue;
      const { isEnabled: r, Feature: i } = n;
      if (!this.features[t] && i && r(this.props) && (this.features[t] = new i(this)), this.features[t]) {
        const s = this.features[t];
        s.isMounted ? s.update() : (s.mount(), s.isMounted = !0);
      }
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.props);
  }
  /**
   * Measure the current viewport box with or without transforms.
   * Only measures axis-aligned boxes, rotate and skew must be manually
   * removed with a re-render to work.
   */
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : M$();
  }
  getStaticValue(t) {
    return this.latestValues[t];
  }
  setStaticValue(t, n) {
    this.latestValues[t] = n;
  }
  /**
   * Update the provided props. Ensure any newly-added motion values are
   * added to our map, old ones removed, and listeners updated.
   */
  update(t, n) {
    (t.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = t, this.prevPresenceContext = this.presenceContext, this.presenceContext = n;
    for (let r = 0; r < JA.length; r++) {
      const i = JA[r];
      this.propEventSubscriptions[i] && (this.propEventSubscriptions[i](), delete this.propEventSubscriptions[i]);
      const s = "on" + i, l = t[s];
      l && (this.propEventSubscriptions[i] = this.on(i, l));
    }
    this.prevMotionValues = fz(this, this.scrapeMotionValuesFromProps(t, this.prevProps, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue();
  }
  getProps() {
    return this.props;
  }
  /**
   * Returns the variant definition with a given name.
   */
  getVariant(t) {
    return this.props.variants ? this.props.variants[t] : void 0;
  }
  /**
   * Returns the defined default transition on this component.
   */
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
  }
  /**
   * Add a child visual element to our set of children.
   */
  addVariantChild(t) {
    const n = this.getClosestVariantNode();
    if (n)
      return n.variantChildren && n.variantChildren.add(t), () => n.variantChildren.delete(t);
  }
  /**
   * Add a motion value and bind it to this visual element.
   */
  addValue(t, n) {
    const r = this.values.get(t);
    n !== r && (r && this.removeValue(t), this.bindToMotionValue(t, n), this.values.set(t, n), this.latestValues[t] = n.get());
  }
  /**
   * Remove a motion value and unbind any active subscriptions.
   */
  removeValue(t) {
    this.values.delete(t);
    const n = this.valueSubscriptions.get(t);
    n && (n(), this.valueSubscriptions.delete(t)), delete this.latestValues[t], this.removeValueFromRenderState(t, this.renderState);
  }
  /**
   * Check whether we have a motion value for this key
   */
  hasValue(t) {
    return this.values.has(t);
  }
  getValue(t, n) {
    if (this.props.values && this.props.values[t])
      return this.props.values[t];
    let r = this.values.get(t);
    return r === void 0 && n !== void 0 && (r = Nd(n === null ? void 0 : n, { owner: this }), this.addValue(t, r)), r;
  }
  /**
   * If we're trying to animate to a previously unencountered value,
   * we need to check for it in our state and as a last resort read it
   * directly from the instance (which might have performance implications).
   */
  readValue(t, n) {
    let r = this.latestValues[t] !== void 0 || !this.current ? this.latestValues[t] : this.getBaseTargetFromProps(this.props, t) ?? this.readValueFromInstance(this.current, t, this.options);
    return r != null && (typeof r == "string" && (LT(r) || PT(r)) ? r = parseFloat(r) : !k6(r) && ea.test(n) && (r = y$(t, n)), this.setBaseTarget(t, Nt(r) ? r.get() : r)), Nt(r) ? r.get() : r;
  }
  /**
   * Set the base target to later animate back to. This is currently
   * only hydrated on creation and when we first read a value.
   */
  setBaseTarget(t, n) {
    this.baseTarget[t] = n;
  }
  /**
   * Find the base target for a value thats been removed from all animation
   * props.
   */
  getBaseTarget(t) {
    var n;
    const { initial: r } = this.props;
    let i;
    if (typeof r == "string" || typeof r == "object") {
      const l = m0(this.props, r, (n = this.presenceContext) == null ? void 0 : n.custom);
      l && (i = l[t]);
    }
    if (r && i !== void 0)
      return i;
    const s = this.getBaseTargetFromProps(this.props, t);
    return s !== void 0 && !Nt(s) ? s : this.initialValues[t] !== void 0 && i === void 0 ? void 0 : this.baseTarget[t];
  }
  on(t, n) {
    return this.events[t] || (this.events[t] = new OT()), this.events[t].add(n);
  }
  notify(t, ...n) {
    this.events[t] && this.events[t].notify(...n);
  }
  scheduleRenderMicrotask() {
    g6.render(this.render);
  }
}, B$ = class extends hz {
  constructor() {
    super(...arguments), this.KeyframeResolver = d6;
  }
  sortInstanceNodePosition(t, n) {
    return t.compareDocumentPosition(n) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(t, n) {
    return t.style ? t.style[n] : void 0;
  }
  removeValueFromRenderState(t, { vars: n, style: r }) {
    delete n[t], delete r[t];
  }
  handleChildMotionValue() {
    this.childSubscription && (this.childSubscription(), delete this.childSubscription);
    const { children: t } = this.props;
    Nt(t) && (this.childSubscription = t.on("change", (n) => {
      this.current && (this.current.textContent = `${n}`);
    }));
  }
};
function N$(e, { style: t, vars: n }, r, i) {
  const s = e.style;
  let l;
  for (l in t)
    s[l] = t[l];
  i == null || i.applyProjectionStyles(s, r);
  for (l in n)
    s.setProperty(l, n[l]);
}
function pz(e) {
  return window.getComputedStyle(e);
}
let mz = class extends B$ {
  constructor() {
    super(...arguments), this.type = "html", this.renderInstance = N$;
  }
  readValueFromInstance(t, n) {
    var r;
    if (na.has(n))
      return (r = this.projection) != null && r.isProjecting ? Eg(n) : VW(t, n);
    {
      const i = pz(t), s = (qT(n) ? i.getPropertyValue(n) : i[n]) || 0;
      return typeof s == "string" ? s.trim() : s;
    }
  }
  measureInstanceViewportBox(t, { transformPagePoint: n }) {
    return uz(t, n);
  }
  build(t, n, r) {
    f0(t, n, r.transformTemplate);
  }
  scrapeMotionValuesFromProps(t, n, r) {
    return g0(t, n, r);
  }
};
const D$ = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust"
]);
function gz(e, t, n, r) {
  N$(e, t, void 0, r);
  for (const i in t.attrs)
    e.setAttribute(D$.has(i) ? i : v0(i), t.attrs[i]);
}
let vz = class extends B$ {
  constructor() {
    super(...arguments), this.type = "svg", this.isSVGTag = !1, this.measureInstanceViewportBox = M$;
  }
  getBaseTargetFromProps(t, n) {
    return t[n];
  }
  readValueFromInstance(t, n) {
    if (na.has(n)) {
      const r = v$(n);
      return r && r.default || 0;
    }
    return n = D$.has(n) ? n : v0(n), t.getAttribute(n);
  }
  scrapeMotionValuesFromProps(t, n, r) {
    return _$(t, n, r);
  }
  build(t, n, r) {
    R$(t, n, this.isSVGTag, r.transformTemplate, r.style);
  }
  renderInstance(t, n, r, i) {
    gz(t, n, r, i);
  }
  mount(t) {
    this.isSVGTag = $$(t.tagName), super.mount(t);
  }
};
const yz = (e, t) => p0(e) ? new vz(t) : new mz(t, {
  allowProjection: e !== C.Fragment
});
function vs(e, t, n) {
  const r = e.getProps();
  return m0(r, t, n !== void 0 ? n : r.custom, e);
}
const Vg = (e) => Array.isArray(e);
function wz(e, t, n) {
  e.hasValue(t) ? e.getValue(t).set(n) : e.addValue(t, Nd(n));
}
function bz(e) {
  return Vg(e) ? e[e.length - 1] || 0 : e;
}
function Cz(e, t) {
  const n = vs(e, t);
  let { transitionEnd: r = {}, transition: i = {}, ...s } = n || {};
  s = { ...s, ...r };
  for (const l in s) {
    const u = bz(s[l]);
    wz(e, l, u);
  }
}
function Ez(e) {
  return !!(Nt(e) && e.add);
}
function Az(e, t) {
  const n = e.getValue("willChange");
  if (Ez(n))
    return n.add(t);
  if (!n && Nr.WillChange) {
    const r = new Nr.WillChange("auto");
    e.addValue("willChange", r), r.add(t);
  }
}
function xz(e) {
  return e.props[L$];
}
const Sz = (e) => e !== null;
function kz(e, { repeat: t, repeatType: n = "loop" }, r) {
  const i = e.filter(Sz), s = t && n !== "loop" && t % 2 === 1 ? 0 : i.length - 1;
  return i[s];
}
const Rz = {
  type: "spring",
  stiffness: 500,
  damping: 25,
  restSpeed: 10
}, Tz = (e) => ({
  type: "spring",
  stiffness: 550,
  damping: e === 0 ? 2 * Math.sqrt(550) : 30,
  restSpeed: 10
}), $z = {
  type: "keyframes",
  duration: 0.8
}, Vz = {
  type: "keyframes",
  ease: [0.25, 0.1, 0.35, 1],
  duration: 0.3
}, _z = (e, { keyframes: t }) => t.length > 2 ? $z : na.has(e) ? e.startsWith("scale") ? Tz(t[1]) : Rz : Vz;
function Iz({ when: e, delay: t, delayChildren: n, staggerChildren: r, staggerDirection: i, repeat: s, repeatType: l, repeatDelay: u, from: d, elapsed: h, ...f }) {
  return !!Object.keys(f).length;
}
const Lz = (e, t, n, r = {}, i, s) => (l) => {
  const u = h$(r, e) || {}, d = u.delay || r.delay || 0;
  let { elapsed: h = 0 } = r;
  h = h - /* @__PURE__ */ Sr(d);
  const f = {
    keyframes: Array.isArray(n) ? n : [null, n],
    ease: "easeOut",
    velocity: t.getVelocity(),
    ...u,
    delay: -h,
    onUpdate: (g) => {
      t.set(g), u.onUpdate && u.onUpdate(g);
    },
    onComplete: () => {
      l(), u.onComplete && u.onComplete();
    },
    name: e,
    motionValue: t,
    element: s ? void 0 : i
  };
  Iz(u) || Object.assign(f, _z(e, f)), f.duration && (f.duration = /* @__PURE__ */ Sr(f.duration)), f.repeatDelay && (f.repeatDelay = /* @__PURE__ */ Sr(f.repeatDelay)), f.from !== void 0 && (f.keyframes[0] = f.from);
  let m = !1;
  if ((f.type === !1 || f.duration === 0 && !f.repeatDelay) && (Rg(f), f.delay === 0 && (m = !0)), (Nr.instantAnimations || Nr.skipAnimations) && (m = !0, Rg(f), f.delay = 0), f.allowFlatten = !u.type && !u.ease, m && !s && t.get() !== void 0) {
    const g = kz(f.keyframes, u);
    if (g !== void 0) {
      zn.update(() => {
        f.onUpdate(g), f.onComplete();
      });
      return;
    }
  }
  return u.isSync ? new o0(f) : new JW(f);
};
function Pz({ protectedKeys: e, needsAnimating: t }, n) {
  const r = e.hasOwnProperty(n) && t[n] !== !0;
  return t[n] = !1, r;
}
function j$(e, t, { delay: n = 0, transitionOverride: r, type: i } = {}) {
  let { transition: s = e.getDefaultTransition(), transitionEnd: l, ...u } = t;
  r && (s = r);
  const d = [], h = i && e.animationState && e.animationState.getState()[i];
  for (const f in u) {
    const m = e.getValue(f, e.latestValues[f] ?? null), g = u[f];
    if (g === void 0 || h && Pz(h, f))
      continue;
    const w = {
      delay: n,
      ...h$(s || {}, f)
    }, E = m.get();
    if (E !== void 0 && !m.isAnimating && !Array.isArray(g) && g === E && !w.velocity)
      continue;
    let b = !1;
    if (window.MotionHandoffAnimation) {
      const x = xz(e);
      if (x) {
        const R = window.MotionHandoffAnimation(x, f, zn);
        R !== null && (w.startTime = R, b = !0);
      }
    }
    Az(e, f), m.start(Lz(f, m, g, e.shouldReduceMotion && p$.has(f) ? { type: !1 } : w, e, b));
    const A = m.animation;
    A && d.push(A);
  }
  return l && Promise.all(d).then(() => {
    zn.update(() => {
      l && Cz(e, l);
    });
  }), d;
}
function F$(e, t, n, r = 0, i = 1) {
  const s = Array.from(e).sort((d, h) => d.sortNodePosition(h)).indexOf(t), l = e.size, u = (l - 1) * r;
  return typeof n == "function" ? n(s, l) : i === 1 ? s * r : u - s * r;
}
function _g(e, t, n = {}) {
  var r;
  const i = vs(e, t, n.type === "exit" ? (r = e.presenceContext) == null ? void 0 : r.custom : void 0);
  let { transition: s = e.getDefaultTransition() || {} } = i || {};
  n.transitionOverride && (s = n.transitionOverride);
  const l = i ? () => Promise.all(j$(e, i, n)) : () => Promise.resolve(), u = e.variantChildren && e.variantChildren.size ? (h = 0) => {
    const { delayChildren: f = 0, staggerChildren: m, staggerDirection: g } = s;
    return Mz(e, t, h, f, m, g, n);
  } : () => Promise.resolve(), { when: d } = s;
  if (d) {
    const [h, f] = d === "beforeChildren" ? [l, u] : [u, l];
    return h().then(() => f());
  } else
    return Promise.all([l(), u(n.delay)]);
}
function Mz(e, t, n = 0, r = 0, i = 0, s = 1, l) {
  const u = [];
  for (const d of e.variantChildren)
    d.notify("AnimationStart", t), u.push(_g(d, t, {
      ...l,
      delay: n + (typeof r == "function" ? 0 : r) + F$(e.variantChildren, d, r, i, s)
    }).then(() => d.notify("AnimationComplete", t)));
  return Promise.all(u);
}
function Oz(e, t, n = {}) {
  e.notify("AnimationStart", t);
  let r;
  if (Array.isArray(t)) {
    const i = t.map((s) => _g(e, s, n));
    r = Promise.all(i);
  } else if (typeof t == "string")
    r = _g(e, t, n);
  else {
    const i = typeof t == "function" ? vs(e, t, n.custom) : t;
    r = Promise.all(j$(e, i, n));
  }
  return r.then(() => {
    e.notify("AnimationComplete", t);
  });
}
function U$(e, t) {
  if (!Array.isArray(t))
    return !1;
  const n = t.length;
  if (n !== e.length)
    return !1;
  for (let r = 0; r < n; r++)
    if (t[r] !== e[r])
      return !1;
  return !0;
}
const Bz = d0.length;
function W$(e) {
  if (!e)
    return;
  if (!e.isControllingVariants) {
    const n = e.parent ? W$(e.parent) || {} : {};
    return e.props.initial !== void 0 && (n.initial = e.props.initial), n;
  }
  const t = {};
  for (let n = 0; n < Bz; n++) {
    const r = d0[n], i = e.props[r];
    (Hl(i) || i === !1) && (t[r] = i);
  }
  return t;
}
const Nz = [...c0].reverse(), Dz = c0.length;
function jz(e) {
  return (t) => Promise.all(t.map(({ animation: n, options: r }) => Oz(e, n, r)));
}
function Fz(e) {
  let t = jz(e), n = ex(), r = !0;
  const i = (d) => (h, f) => {
    var m;
    const g = vs(e, f, d === "exit" ? (m = e.presenceContext) == null ? void 0 : m.custom : void 0);
    if (g) {
      const { transition: w, transitionEnd: E, ...b } = g;
      h = { ...h, ...b, ...E };
    }
    return h;
  };
  function s(d) {
    t = d(e);
  }
  function l(d) {
    const { props: h } = e, f = W$(e.parent) || {}, m = [], g = /* @__PURE__ */ new Set();
    let w = {}, E = 1 / 0;
    for (let A = 0; A < Dz; A++) {
      const x = Nz[A], R = n[x], _ = h[x] !== void 0 ? h[x] : f[x], L = Hl(_), V = x === d ? R.isActive : null;
      V === !1 && (E = A);
      let O = _ === f[x] && _ !== h[x] && L;
      if (O && r && e.manuallyAnimateOnMount && (O = !1), R.protectedKeys = { ...w }, // If it isn't active and hasn't *just* been set as inactive
      !R.isActive && V === null || // If we didn't and don't have any defined prop for this animation type
      !_ && !R.prevProp || // Or if the prop doesn't define an animation
      kf(_) || typeof _ == "boolean")
        continue;
      const D = Uz(R.prevProp, _);
      let B = D || // If we're making this variant active, we want to always make it active
      x === d && R.isActive && !O && L || // If we removed a higher-priority variant (i is in reverse order)
      A > E && L, H = !1;
      const J = Array.isArray(_) ? _ : [_];
      let ce = J.reduce(i(x), {});
      V === !1 && (ce = {});
      const { prevResolvedValues: fe = {} } = R, de = {
        ...fe,
        ...ce
      }, he = (Y) => {
        B = !0, g.has(Y) && (H = !0, g.delete(Y)), R.needsAnimating[Y] = !0;
        const te = e.getValue(Y);
        te && (te.liveStyle = !1);
      };
      for (const Y in de) {
        const te = ce[Y], S = fe[Y];
        if (w.hasOwnProperty(Y))
          continue;
        let T = !1;
        Vg(te) && Vg(S) ? T = !U$(te, S) : T = te !== S, T ? te != null ? he(Y) : g.add(Y) : te !== void 0 && g.has(Y) ? he(Y) : R.protectedKeys[Y] = !0;
      }
      R.prevProp = _, R.prevResolvedValues = ce, R.isActive && (w = { ...w, ...ce }), r && e.blockInitialAnimation && (B = !1);
      const le = O && D;
      B && (!le || H) && m.push(...J.map((Y) => {
        const te = { type: x };
        if (typeof Y == "string" && r && !le && e.manuallyAnimateOnMount && e.parent) {
          const { parent: S } = e, T = vs(S, Y);
          if (S.enteringChildren && T) {
            const { delayChildren: P } = T.transition || {};
            te.delay = F$(S.enteringChildren, e, P);
          }
        }
        return {
          animation: Y,
          options: te
        };
      }));
    }
    if (g.size) {
      const A = {};
      if (typeof h.initial != "boolean") {
        const x = vs(e, Array.isArray(h.initial) ? h.initial[0] : h.initial);
        x && x.transition && (A.transition = x.transition);
      }
      g.forEach((x) => {
        const R = e.getBaseTarget(x), _ = e.getValue(x);
        _ && (_.liveStyle = !0), A[x] = R ?? null;
      }), m.push({ animation: A });
    }
    let b = !!m.length;
    return r && (h.initial === !1 || h.initial === h.animate) && !e.manuallyAnimateOnMount && (b = !1), r = !1, b ? t(m) : Promise.resolve();
  }
  function u(d, h) {
    var f;
    if (n[d].isActive === h)
      return Promise.resolve();
    (f = e.variantChildren) == null || f.forEach((g) => {
      var w;
      return (w = g.animationState) == null ? void 0 : w.setActive(d, h);
    }), n[d].isActive = h;
    const m = l(d);
    for (const g in n)
      n[g].protectedKeys = {};
    return m;
  }
  return {
    animateChanges: l,
    setActive: u,
    setAnimateFunction: s,
    getState: () => n,
    reset: () => {
      n = ex(), r = !0;
    }
  };
}
function Uz(e, t) {
  return typeof t == "string" ? t !== e : Array.isArray(t) ? !U$(t, e) : !1;
}
function Di(e = !1) {
  return {
    isActive: e,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function ex() {
  return {
    animate: Di(!0),
    whileInView: Di(),
    whileHover: Di(),
    whileTap: Di(),
    whileDrag: Di(),
    whileFocus: Di(),
    exit: Di()
  };
}
let ra = class {
  constructor(t) {
    this.isMounted = !1, this.node = t;
  }
  update() {
  }
}, Wz = class extends ra {
  /**
   * We dynamically generate the AnimationState manager as it contains a reference
   * to the underlying animation library. We only want to load that if we load this,
   * so people can optionally code split it out using the `m` component.
   */
  constructor(t) {
    super(t), t.animationState || (t.animationState = Fz(t));
  }
  updateAnimationControlsSubscription() {
    const { animate: t } = this.node.getProps();
    kf(t) && (this.unmountControls = t.subscribe(this.node));
  }
  /**
   * Subscribe any provided AnimationControls to the component's VisualElement
   */
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate: t } = this.node.getProps(), { animate: n } = this.node.prevProps || {};
    t !== n && this.updateAnimationControlsSubscription();
  }
  unmount() {
    var t;
    this.node.animationState.reset(), (t = this.unmountControls) == null || t.call(this);
  }
}, zz = 0, Hz = class extends ra {
  constructor() {
    super(...arguments), this.id = zz++;
  }
  update() {
    if (!this.node.presenceContext)
      return;
    const { isPresent: t, onExitComplete: n } = this.node.presenceContext, { isPresent: r } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || t === r)
      return;
    const i = this.node.animationState.setActive("exit", !t);
    n && !t && i.then(() => {
      n(this.id);
    });
  }
  mount() {
    const { register: t, onExitComplete: n } = this.node.presenceContext || {};
    n && n(this.id), t && (this.unmount = t(this.id));
  }
  unmount() {
  }
};
const Kz = {
  animation: {
    Feature: Wz
  },
  exit: {
    Feature: Hz
  }
};
function tx(e, t, n, r = { passive: !0 }) {
  return e.addEventListener(t, n, r), () => e.removeEventListener(t, n);
}
function z$(e) {
  return {
    point: {
      x: e.pageX,
      y: e.pageY
    }
  };
}
function nx(e, t, n) {
  const { props: r } = e;
  e.animationState && r.whileHover && e.animationState.setActive("whileHover", n === "Start");
  const i = "onHover" + n, s = r[i];
  s && zn.postRender(() => s(t, z$(t)));
}
let Gz = class extends ra {
  mount() {
    const { current: t } = this.node;
    t && (this.unmount = w6(t, (n, r) => (nx(this.node, r, "Start"), (i) => nx(this.node, i, "End"))));
  }
  unmount() {
  }
}, Yz = class extends ra {
  constructor() {
    super(...arguments), this.isActive = !1;
  }
  onFocus() {
    let t = !1;
    try {
      t = this.node.current.matches(":focus-visible");
    } catch {
      t = !0;
    }
    !t || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0);
  }
  onBlur() {
    !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1);
  }
  mount() {
    this.unmount = Af(tx(this.node.current, "focus", () => this.onFocus()), tx(this.node.current, "blur", () => this.onBlur()));
  }
  unmount() {
  }
};
function rx(e, t, n) {
  const { props: r } = e;
  if (e.current instanceof HTMLButtonElement && e.current.disabled)
    return;
  e.animationState && r.whileTap && e.animationState.setActive("whileTap", n === "Start");
  const i = "onTap" + (n === "End" ? "" : n), s = r[i];
  s && zn.postRender(() => s(t, z$(t)));
}
let qz = class extends ra {
  mount() {
    const { current: t } = this.node;
    t && (this.unmount = x6(t, (n, r) => (rx(this.node, r, "Start"), (i, { success: s }) => rx(this.node, i, s ? "End" : "Cancel")), { useGlobalTarget: this.node.props.globalTapTarget }));
  }
  unmount() {
  }
};
const Ig = /* @__PURE__ */ new WeakMap(), gm = /* @__PURE__ */ new WeakMap(), Xz = (e) => {
  const t = Ig.get(e.target);
  t && t(e);
}, Zz = (e) => {
  e.forEach(Xz);
};
function Qz({ root: e, ...t }) {
  const n = e || document;
  gm.has(n) || gm.set(n, {});
  const r = gm.get(n), i = JSON.stringify(t);
  return r[i] || (r[i] = new IntersectionObserver(Zz, { root: e, ...t })), r[i];
}
function Jz(e, t, n) {
  const r = Qz(t);
  return Ig.set(e, n), r.observe(e), () => {
    Ig.delete(e), r.unobserve(e);
  };
}
const e9 = {
  some: 0,
  all: 1
};
let t9 = class extends ra {
  constructor() {
    super(...arguments), this.hasEnteredView = !1, this.isInView = !1;
  }
  startObserver() {
    this.unmount();
    const { viewport: t = {} } = this.node.getProps(), { root: n, margin: r, amount: i = "some", once: s } = t, l = {
      root: n ? n.current : void 0,
      rootMargin: r,
      threshold: typeof i == "number" ? i : e9[i]
    }, u = (d) => {
      const { isIntersecting: h } = d;
      if (this.isInView === h || (this.isInView = h, s && !h && this.hasEnteredView))
        return;
      h && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", h);
      const { onViewportEnter: f, onViewportLeave: m } = this.node.getProps(), g = h ? f : m;
      g && g(d);
    };
    return Jz(this.node.current, l, u);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver > "u")
      return;
    const { props: t, prevProps: n } = this.node;
    ["amount", "margin", "root"].some(n9(t, n)) && this.startObserver();
  }
  unmount() {
  }
};
function n9({ viewport: e = {} }, { viewport: t = {} } = {}) {
  return (n) => e[n] !== t[n];
}
const r9 = {
  inView: {
    Feature: t9
  },
  tap: {
    Feature: qz
  },
  focus: {
    Feature: Yz
  },
  hover: {
    Feature: Gz
  }
}, i9 = {
  renderer: yz,
  ...Kz,
  ...r9
};
function o9(e, t) {
  return rz(e, t);
}
const s9 = /* @__PURE__ */ o9("div"), a9 = {
  light: {
    border: "px",
    shadow: "2"
  },
  dark: {}
}, l9 = j.createContext({
  groupOpen: !1,
  setGroupOpen: () => {
  }
}), u9 = ({ open: e, delay: t = 600 }) => {
  const n = j.useContext(l9);
  return j.useEffect(() => {
    let r = null;
    return n.setGroupOpen && (e === !0 && n.setGroupOpen(!0), e === !1 && (r = setTimeout(() => {
      n.setGroupOpen && n.setGroupOpen(!1);
    }, t))), () => {
      r && clearTimeout(r);
    };
  }, [e, n, t]), {
    groupOpen: n.groupOpen
  };
}, y0 = ({
  // Radix Tooltip Provider Props
  delayDuration: e = 400,
  skipDelayDuration: t,
  disableHoverableContent: n,
  // Radix Tooltip Root Props
  defaultOpen: r,
  open: i,
  onOpenChange: s,
  // Radix Tooltip Content Props
  "aria-label": l,
  onEscapeKeyDown: u,
  onPointerDownOutside: d,
  forceMount: h,
  side: f = "bottom",
  sideOffset: m = 4,
  align: g = "center",
  alignOffset: w,
  avoidCollisions: E,
  collisionBoundary: b,
  collisionPadding: A,
  arrowPadding: x,
  sticky: R,
  hideWhenDetached: _,
  skipAnimation: L,
  // Label Props
  label: V,
  labelProps: O,
  // Telegraph Props
  enabled: D = !0,
  appearance: B = "dark",
  triggerRef: H,
  children: J
}) => {
  const [ce, fe] = Zs({
    prop: i,
    onChange: s,
    defaultProp: r ?? !1
  }), { groupOpen: de } = u9({ open: !!ce, delay: e }), he = j.Children.toArray(J).some(
    (S) => j.isValidElement(S) ? S.props.disabled : !1
  ), le = de || he ? 0 : e, Y = !de, te = (S) => {
    if (S === "top")
      return {
        y: -5
      };
    if (S === "bottom")
      return {
        y: 5
      };
    if (S === "left")
      return {
        x: -5
      };
    if (S === "right")
      return {
        x: 5
      };
  };
  return /* @__PURE__ */ I.jsx(R6, { features: i9, children: /* @__PURE__ */ I.jsx(
    aU,
    {
      delayDuration: le,
      skipDelayDuration: t,
      disableHoverableContent: n,
      children: /* @__PURE__ */ I.jsxs(
        lU,
        {
          open: D === !1 ? !1 : ce,
          onOpenChange: fe,
          children: [
            /* @__PURE__ */ I.jsx(uU, { asChild: !0, ref: H, children: /* @__PURE__ */ I.jsx(Gs, { children: J }) }),
            /* @__PURE__ */ I.jsx(cU, { children: /* @__PURE__ */ I.jsx(
              dU,
              {
                "aria-label": l,
                onEscapeKeyDown: u,
                onPointerDownOutside: d,
                forceMount: h,
                side: f,
                sideOffset: m,
                align: g,
                alignOffset: w,
                avoidCollisions: E,
                collisionBoundary: b,
                collisionPadding: A,
                arrowPadding: x,
                sticky: R,
                hideWhenDetached: _,
                style: {
                  zIndex: "var(--tgph-zIndex-tooltip)"
                },
                children: /* @__PURE__ */ I.jsx(hU, { appearance: B, asChild: !0, children: /* @__PURE__ */ I.jsx(
                  bU,
                  {
                    as: s9,
                    className: "tgph",
                    initial: Y && !L ? {
                      opacity: 0,
                      scale: 0.5,
                      ...te(f)
                    } : {},
                    animate: {
                      opacity: 1,
                      scale: 1,
                      x: 0,
                      y: 0
                    },
                    transition: {
                      duration: 0.1,
                      type: "spring",
                      bounce: 0
                    },
                    bg: "gray-1",
                    rounded: "3",
                    py: "2",
                    px: "3",
                    align: "center",
                    justify: "center",
                    style: {
                      transformOrigin: "var(--radix-tooltip-content-transform-origin)"
                    },
                    ...O ? { labelProps: O } : {},
                    ...a9[B],
                    children: typeof V == "string" ? /* @__PURE__ */ I.jsx(qn, { as: "span", size: "1", children: V }) : V
                  }
                ) })
              }
            ) })
          ]
        }
      )
    }
  ) });
}, c9 = C.createContext({});
function d9(e) {
  const t = C.useRef(null);
  return t.current === null && (t.current = e()), t.current;
}
const w0 = typeof window < "u", f9 = w0 ? C.useLayoutEffect : C.useEffect, H$ = /* @__PURE__ */ C.createContext(null);
function h9(e, t) {
  e.indexOf(t) === -1 && e.push(t);
}
function p9(e, t) {
  const n = e.indexOf(t);
  n > -1 && e.splice(n, 1);
}
const wo = (e, t, n) => n > t ? t : n < e ? e : n;
let b0 = () => {
};
const Dr = {}, K$ = (e) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(e);
function m9(e) {
  return typeof e == "object" && e !== null;
}
const G$ = (e) => /^0[^.\s]+$/u.test(e);
// @__NO_SIDE_EFFECTS__
function C0(e) {
  let t;
  return () => (t === void 0 && (t = e()), t);
}
const ia = /* @__NO_SIDE_EFFECTS__ */ (e) => e, g9 = (e, t) => (n) => t(e(n)), Tf = (...e) => e.reduce(g9), Y$ = /* @__NO_SIDE_EFFECTS__ */ (e, t, n) => {
  const r = t - e;
  return r === 0 ? 1 : (n - e) / r;
};
let q$ = class {
  constructor() {
    this.subscriptions = [];
  }
  add(t) {
    return h9(this.subscriptions, t), () => p9(this.subscriptions, t);
  }
  notify(t, n, r) {
    const i = this.subscriptions.length;
    if (i)
      if (i === 1)
        this.subscriptions[0](t, n, r);
      else
        for (let s = 0; s < i; s++) {
          const l = this.subscriptions[s];
          l && l(t, n, r);
        }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
};
const Rr = /* @__NO_SIDE_EFFECTS__ */ (e) => e * 1e3, Tr = /* @__NO_SIDE_EFFECTS__ */ (e) => e / 1e3;
function X$(e, t) {
  return t ? e * (1e3 / t) : 0;
}
const Z$ = (e, t, n) => (((1 - 3 * n + 3 * t) * e + (3 * n - 6 * t)) * e + 3 * t) * e, v9 = 1e-7, y9 = 12;
function w9(e, t, n, r, i) {
  let s, l, u = 0;
  do
    l = t + (n - t) / 2, s = Z$(l, r, i) - e, s > 0 ? n = l : t = l;
  while (Math.abs(s) > v9 && ++u < y9);
  return l;
}
function vu(e, t, n, r) {
  if (e === t && n === r)
    return ia;
  const i = (s) => w9(s, 0, 1, e, n);
  return (s) => s === 0 || s === 1 ? s : Z$(i(s), t, r);
}
const Q$ = (e) => (t) => t <= 0.5 ? e(2 * t) / 2 : (2 - e(2 * (1 - t))) / 2, J$ = (e) => (t) => 1 - e(1 - t), eV = /* @__PURE__ */ vu(0.33, 1.53, 0.69, 0.99), E0 = /* @__PURE__ */ J$(eV), tV = /* @__PURE__ */ Q$(E0), nV = (e) => (e *= 2) < 1 ? 0.5 * E0(e) : 0.5 * (2 - Math.pow(2, -10 * (e - 1))), A0 = (e) => 1 - Math.sin(Math.acos(e)), b9 = J$(A0), rV = Q$(A0), C9 = /* @__PURE__ */ vu(0.42, 0, 1, 1), E9 = /* @__PURE__ */ vu(0, 0, 0.58, 1), iV = /* @__PURE__ */ vu(0.42, 0, 0.58, 1), A9 = (e) => Array.isArray(e) && typeof e[0] != "number", oV = (e) => Array.isArray(e) && typeof e[0] == "number", x9 = {
  linear: ia,
  easeIn: C9,
  easeInOut: iV,
  easeOut: E9,
  circIn: A0,
  circInOut: rV,
  circOut: b9,
  backIn: E0,
  backInOut: tV,
  backOut: eV,
  anticipate: nV
}, S9 = (e) => typeof e == "string", ix = (e) => {
  if (oV(e)) {
    b0(e.length === 4);
    const [t, n, r, i] = e;
    return vu(t, n, r, i);
  } else if (S9(e))
    return x9[e];
  return e;
}, Gc = [
  "setup",
  // Compute
  "read",
  // Read
  "resolveKeyframes",
  // Write/Read/Write/Read
  "preUpdate",
  // Compute
  "update",
  // Compute
  "preRender",
  // Compute
  "render",
  // Write
  "postRender"
  // Compute
];
function k9(e, t) {
  let n = /* @__PURE__ */ new Set(), r = /* @__PURE__ */ new Set(), i = !1, s = !1;
  const l = /* @__PURE__ */ new WeakSet();
  let u = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  };
  function d(f) {
    l.has(f) && (h.schedule(f), e()), f(u);
  }
  const h = {
    /**
     * Schedule a process to run on the next frame.
     */
    schedule: (f, m = !1, g = !1) => {
      const w = g && i ? n : r;
      return m && l.add(f), w.has(f) || w.add(f), f;
    },
    /**
     * Cancel the provided callback from running on the next frame.
     */
    cancel: (f) => {
      r.delete(f), l.delete(f);
    },
    /**
     * Execute all schedule callbacks.
     */
    process: (f) => {
      if (u = f, i) {
        s = !0;
        return;
      }
      i = !0, [n, r] = [r, n], n.forEach(d), n.clear(), i = !1, s && (s = !1, h.process(f));
    }
  };
  return h;
}
const R9 = 40;
function sV(e, t) {
  let n = !1, r = !0;
  const i = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  }, s = () => n = !0, l = Gc.reduce((x, R) => (x[R] = k9(s), x), {}), { setup: u, read: d, resolveKeyframes: h, preUpdate: f, update: m, preRender: g, render: w, postRender: E } = l, b = () => {
    const x = Dr.useManualTiming ? i.timestamp : performance.now();
    n = !1, Dr.useManualTiming || (i.delta = r ? 1e3 / 60 : Math.max(Math.min(x - i.timestamp, R9), 1)), i.timestamp = x, i.isProcessing = !0, u.process(i), d.process(i), h.process(i), f.process(i), m.process(i), g.process(i), w.process(i), E.process(i), i.isProcessing = !1, n && t && (r = !1, e(b));
  }, A = () => {
    n = !0, r = !0, i.isProcessing || e(b);
  };
  return { schedule: Gc.reduce((x, R) => {
    const _ = l[R];
    return x[R] = (L, V = !1, O = !1) => (n || A(), _.schedule(L, V, O)), x;
  }, {}), cancel: (x) => {
    for (let R = 0; R < Gc.length; R++)
      l[Gc[R]].cancel(x);
  }, state: i, steps: l };
}
const { schedule: Hn, cancel: Lg, state: Dd } = /* @__PURE__ */ sV(typeof requestAnimationFrame < "u" ? requestAnimationFrame : ia, !0);
let vd;
function T9() {
  vd = void 0;
}
const Sn = {
  now: () => (vd === void 0 && Sn.set(Dd.isProcessing || Dr.useManualTiming ? Dd.timestamp : performance.now()), vd),
  set: (e) => {
    vd = e, queueMicrotask(T9);
  }
}, aV = (e) => (t) => typeof t == "string" && t.startsWith(e), lV = /* @__PURE__ */ aV("--"), $9 = /* @__PURE__ */ aV("var(--"), x0 = (e) => $9(e) ? V9.test(e.split("/*")[0].trim()) : !1, V9 = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu, oa = {
  test: (e) => typeof e == "number",
  parse: parseFloat,
  transform: (e) => e
}, Kl = {
  ...oa,
  transform: (e) => wo(0, 1, e)
}, Yc = {
  ...oa,
  default: 1
}, Vl = (e) => Math.round(e * 1e5) / 1e5, S0 = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
function _9(e) {
  return e == null;
}
const I9 = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu, k0 = (e, t) => (n) => !!(typeof n == "string" && I9.test(n) && n.startsWith(e) || t && !_9(n) && Object.prototype.hasOwnProperty.call(n, t)), uV = (e, t, n) => (r) => {
  if (typeof r != "string")
    return r;
  const [i, s, l, u] = r.match(S0);
  return {
    [e]: parseFloat(i),
    [t]: parseFloat(s),
    [n]: parseFloat(l),
    alpha: u !== void 0 ? parseFloat(u) : 1
  };
}, L9 = (e) => wo(0, 255, e), vm = {
  ...oa,
  transform: (e) => Math.round(L9(e))
}, qi = {
  test: /* @__PURE__ */ k0("rgb", "red"),
  parse: /* @__PURE__ */ uV("red", "green", "blue"),
  transform: ({ red: e, green: t, blue: n, alpha: r = 1 }) => "rgba(" + vm.transform(e) + ", " + vm.transform(t) + ", " + vm.transform(n) + ", " + Vl(Kl.transform(r)) + ")"
};
function P9(e) {
  let t = "", n = "", r = "", i = "";
  return e.length > 5 ? (t = e.substring(1, 3), n = e.substring(3, 5), r = e.substring(5, 7), i = e.substring(7, 9)) : (t = e.substring(1, 2), n = e.substring(2, 3), r = e.substring(3, 4), i = e.substring(4, 5), t += t, n += n, r += r, i += i), {
    red: parseInt(t, 16),
    green: parseInt(n, 16),
    blue: parseInt(r, 16),
    alpha: i ? parseInt(i, 16) / 255 : 1
  };
}
const Pg = {
  test: /* @__PURE__ */ k0("#"),
  parse: P9,
  transform: qi.transform
}, yu = /* @__NO_SIDE_EFFECTS__ */ (e) => ({
  test: (t) => typeof t == "string" && t.endsWith(e) && t.split(" ").length === 1,
  parse: parseFloat,
  transform: (t) => `${t}${e}`
}), hi = /* @__PURE__ */ yu("deg"), ys = /* @__PURE__ */ yu("%"), Te = /* @__PURE__ */ yu("px"), M9 = /* @__PURE__ */ yu("vh"), O9 = /* @__PURE__ */ yu("vw"), ox = {
  ...ys,
  parse: (e) => ys.parse(e) / 100,
  transform: (e) => ys.transform(e * 100)
}, us = {
  test: /* @__PURE__ */ k0("hsl", "hue"),
  parse: /* @__PURE__ */ uV("hue", "saturation", "lightness"),
  transform: ({ hue: e, saturation: t, lightness: n, alpha: r = 1 }) => "hsla(" + Math.round(e) + ", " + ys.transform(Vl(t)) + ", " + ys.transform(Vl(n)) + ", " + Vl(Kl.transform(r)) + ")"
}, ft = {
  test: (e) => qi.test(e) || Pg.test(e) || us.test(e),
  parse: (e) => qi.test(e) ? qi.parse(e) : us.test(e) ? us.parse(e) : Pg.parse(e),
  transform: (e) => typeof e == "string" ? e : e.hasOwnProperty("red") ? qi.transform(e) : us.transform(e),
  getAnimatableNone: (e) => {
    const t = ft.parse(e);
    return t.alpha = 0, ft.transform(t);
  }
}, B9 = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
function N9(e) {
  var t, n;
  return isNaN(e) && typeof e == "string" && (((t = e.match(S0)) == null ? void 0 : t.length) || 0) + (((n = e.match(B9)) == null ? void 0 : n.length) || 0) > 0;
}
const cV = "number", dV = "color", D9 = "var", j9 = "var(", sx = "${}", F9 = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function Gl(e) {
  const t = e.toString(), n = [], r = {
    color: [],
    number: [],
    var: []
  }, i = [];
  let s = 0;
  const l = t.replace(F9, (u) => (ft.test(u) ? (r.color.push(s), i.push(dV), n.push(ft.parse(u))) : u.startsWith(j9) ? (r.var.push(s), i.push(D9), n.push(u)) : (r.number.push(s), i.push(cV), n.push(parseFloat(u))), ++s, sx)).split(sx);
  return { values: n, split: l, indexes: r, types: i };
}
function fV(e) {
  return Gl(e).values;
}
function hV(e) {
  const { split: t, types: n } = Gl(e), r = t.length;
  return (i) => {
    let s = "";
    for (let l = 0; l < r; l++)
      if (s += t[l], i[l] !== void 0) {
        const u = n[l];
        u === cV ? s += Vl(i[l]) : u === dV ? s += ft.transform(i[l]) : s += i[l];
      }
    return s;
  };
}
const U9 = (e) => typeof e == "number" ? 0 : ft.test(e) ? ft.getAnimatableNone(e) : e;
function W9(e) {
  const t = fV(e);
  return hV(e)(t.map(U9));
}
const sa = {
  test: N9,
  parse: fV,
  createTransformer: hV,
  getAnimatableNone: W9
};
function ym(e, t, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + (t - e) * 6 * n : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e;
}
function z9({ hue: e, saturation: t, lightness: n, alpha: r }) {
  e /= 360, t /= 100, n /= 100;
  let i = 0, s = 0, l = 0;
  if (!t)
    i = s = l = n;
  else {
    const u = n < 0.5 ? n * (1 + t) : n + t - n * t, d = 2 * n - u;
    i = ym(d, u, e + 1 / 3), s = ym(d, u, e), l = ym(d, u, e - 1 / 3);
  }
  return {
    red: Math.round(i * 255),
    green: Math.round(s * 255),
    blue: Math.round(l * 255),
    alpha: r
  };
}
function jd(e, t) {
  return (n) => n > 0 ? t : e;
}
const $f = (e, t, n) => e + (t - e) * n, wm = (e, t, n) => {
  const r = e * e, i = n * (t * t - r) + r;
  return i < 0 ? 0 : Math.sqrt(i);
}, H9 = [Pg, qi, us], K9 = (e) => H9.find((t) => t.test(e));
function ax(e) {
  const t = K9(e);
  if (!t)
    return !1;
  let n = t.parse(e);
  return t === us && (n = z9(n)), n;
}
const lx = (e, t) => {
  const n = ax(e), r = ax(t);
  if (!n || !r)
    return jd(e, t);
  const i = { ...n };
  return (s) => (i.red = wm(n.red, r.red, s), i.green = wm(n.green, r.green, s), i.blue = wm(n.blue, r.blue, s), i.alpha = $f(n.alpha, r.alpha, s), qi.transform(i));
}, Mg = /* @__PURE__ */ new Set(["none", "hidden"]);
function G9(e, t) {
  return Mg.has(e) ? (n) => n <= 0 ? e : t : (n) => n >= 1 ? t : e;
}
function Y9(e, t) {
  return (n) => $f(e, t, n);
}
function R0(e) {
  return typeof e == "number" ? Y9 : typeof e == "string" ? x0(e) ? jd : ft.test(e) ? lx : Z9 : Array.isArray(e) ? pV : typeof e == "object" ? ft.test(e) ? lx : q9 : jd;
}
function pV(e, t) {
  const n = [...e], r = n.length, i = e.map((s, l) => R0(s)(s, t[l]));
  return (s) => {
    for (let l = 0; l < r; l++)
      n[l] = i[l](s);
    return n;
  };
}
function q9(e, t) {
  const n = { ...e, ...t }, r = {};
  for (const i in n)
    e[i] !== void 0 && t[i] !== void 0 && (r[i] = R0(e[i])(e[i], t[i]));
  return (i) => {
    for (const s in r)
      n[s] = r[s](i);
    return n;
  };
}
function X9(e, t) {
  const n = [], r = { color: 0, var: 0, number: 0 };
  for (let i = 0; i < t.values.length; i++) {
    const s = t.types[i], l = e.indexes[s][r[s]], u = e.values[l] ?? 0;
    n[i] = u, r[s]++;
  }
  return n;
}
const Z9 = (e, t) => {
  const n = sa.createTransformer(t), r = Gl(e), i = Gl(t);
  return r.indexes.var.length === i.indexes.var.length && r.indexes.color.length === i.indexes.color.length && r.indexes.number.length >= i.indexes.number.length ? Mg.has(e) && !i.values.length || Mg.has(t) && !r.values.length ? G9(e, t) : Tf(pV(X9(r, i), i.values), n) : jd(e, t);
};
function mV(e, t, n) {
  return typeof e == "number" && typeof t == "number" && typeof n == "number" ? $f(e, t, n) : R0(e)(e, t);
}
const Q9 = (e) => {
  const t = ({ timestamp: n }) => e(n);
  return {
    start: (n = !0) => Hn.update(t, n),
    stop: () => Lg(t),
    /**
     * If we're processing this frame we can use the
     * framelocked timestamp to keep things in sync.
     */
    now: () => Dd.isProcessing ? Dd.timestamp : Sn.now()
  };
}, gV = (e, t, n = 10) => {
  let r = "";
  const i = Math.max(Math.round(t / n), 2);
  for (let s = 0; s < i; s++)
    r += Math.round(e(s / (i - 1)) * 1e4) / 1e4 + ", ";
  return `linear(${r.substring(0, r.length - 2)})`;
}, Fd = 2e4;
function T0(e) {
  let t = 0;
  const n = 50;
  let r = e.next(t);
  for (; !r.done && t < Fd; )
    t += n, r = e.next(t);
  return t >= Fd ? 1 / 0 : t;
}
function J9(e, t = 100, n) {
  const r = n({ ...e, keyframes: [0, t] }), i = Math.min(T0(r), Fd);
  return {
    type: "keyframes",
    ease: (s) => r.next(i * s).value / t,
    duration: /* @__PURE__ */ Tr(i)
  };
}
const e8 = 5;
function vV(e, t, n) {
  const r = Math.max(t - e8, 0);
  return X$(n - e(r), t - r);
}
const rt = {
  // Default spring physics
  stiffness: 100,
  damping: 10,
  mass: 1,
  velocity: 0,
  // Default duration/bounce-based options
  duration: 800,
  // in ms
  bounce: 0.3,
  visualDuration: 0.3,
  // in seconds
  // Rest thresholds
  restSpeed: {
    granular: 0.01,
    default: 2
  },
  restDelta: {
    granular: 5e-3,
    default: 0.5
  },
  // Limits
  minDuration: 0.01,
  // in seconds
  maxDuration: 10,
  // in seconds
  minDamping: 0.05,
  maxDamping: 1
}, bm = 1e-3;
function t8({ duration: e = rt.duration, bounce: t = rt.bounce, velocity: n = rt.velocity, mass: r = rt.mass }) {
  let i, s, l = 1 - t;
  l = wo(rt.minDamping, rt.maxDamping, l), e = wo(rt.minDuration, rt.maxDuration, /* @__PURE__ */ Tr(e)), l < 1 ? (i = (h) => {
    const f = h * l, m = f * e, g = f - n, w = Og(h, l), E = Math.exp(-m);
    return bm - g / w * E;
  }, s = (h) => {
    const f = h * l * e, m = f * n + n, g = Math.pow(l, 2) * Math.pow(h, 2) * e, w = Math.exp(-f), E = Og(Math.pow(h, 2), l);
    return (-i(h) + bm > 0 ? -1 : 1) * ((m - g) * w) / E;
  }) : (i = (h) => {
    const f = Math.exp(-h * e), m = (h - n) * e + 1;
    return -bm + f * m;
  }, s = (h) => {
    const f = Math.exp(-h * e), m = (n - h) * (e * e);
    return f * m;
  });
  const u = 5 / e, d = r8(i, s, u);
  if (e = /* @__PURE__ */ Rr(e), isNaN(d))
    return {
      stiffness: rt.stiffness,
      damping: rt.damping,
      duration: e
    };
  {
    const h = Math.pow(d, 2) * r;
    return {
      stiffness: h,
      damping: l * 2 * Math.sqrt(r * h),
      duration: e
    };
  }
}
const n8 = 12;
function r8(e, t, n) {
  let r = n;
  for (let i = 1; i < n8; i++)
    r = r - e(r) / t(r);
  return r;
}
function Og(e, t) {
  return e * Math.sqrt(1 - t * t);
}
const i8 = ["duration", "bounce"], o8 = ["stiffness", "damping", "mass"];
function ux(e, t) {
  return t.some((n) => e[n] !== void 0);
}
function s8(e) {
  let t = {
    velocity: rt.velocity,
    stiffness: rt.stiffness,
    damping: rt.damping,
    mass: rt.mass,
    isResolvedFromDuration: !1,
    ...e
  };
  if (!ux(e, o8) && ux(e, i8))
    if (e.visualDuration) {
      const n = e.visualDuration, r = 2 * Math.PI / (n * 1.2), i = r * r, s = 2 * wo(0.05, 1, 1 - (e.bounce || 0)) * Math.sqrt(i);
      t = {
        ...t,
        mass: rt.mass,
        stiffness: i,
        damping: s
      };
    } else {
      const n = t8(e);
      t = {
        ...t,
        ...n,
        mass: rt.mass
      }, t.isResolvedFromDuration = !0;
    }
  return t;
}
function Ud(e = rt.visualDuration, t = rt.bounce) {
  const n = typeof e != "object" ? {
    visualDuration: e,
    keyframes: [0, 1],
    bounce: t
  } : e;
  let { restSpeed: r, restDelta: i } = n;
  const s = n.keyframes[0], l = n.keyframes[n.keyframes.length - 1], u = { done: !1, value: s }, { stiffness: d, damping: h, mass: f, duration: m, velocity: g, isResolvedFromDuration: w } = s8({
    ...n,
    velocity: -/* @__PURE__ */ Tr(n.velocity || 0)
  }), E = g || 0, b = h / (2 * Math.sqrt(d * f)), A = l - s, x = /* @__PURE__ */ Tr(Math.sqrt(d / f)), R = Math.abs(A) < 5;
  r || (r = R ? rt.restSpeed.granular : rt.restSpeed.default), i || (i = R ? rt.restDelta.granular : rt.restDelta.default);
  let _;
  if (b < 1) {
    const V = Og(x, b);
    _ = (O) => {
      const D = Math.exp(-b * x * O);
      return l - D * ((E + b * x * A) / V * Math.sin(V * O) + A * Math.cos(V * O));
    };
  } else if (b === 1)
    _ = (V) => l - Math.exp(-x * V) * (A + (E + x * A) * V);
  else {
    const V = x * Math.sqrt(b * b - 1);
    _ = (O) => {
      const D = Math.exp(-b * x * O), B = Math.min(V * O, 300);
      return l - D * ((E + b * x * A) * Math.sinh(B) + V * A * Math.cosh(B)) / V;
    };
  }
  const L = {
    calculatedDuration: w && m || null,
    next: (V) => {
      const O = _(V);
      if (w)
        u.done = V >= m;
      else {
        let D = V === 0 ? E : 0;
        b < 1 && (D = V === 0 ? /* @__PURE__ */ Rr(E) : vV(_, V, O));
        const B = Math.abs(D) <= r, H = Math.abs(l - O) <= i;
        u.done = B && H;
      }
      return u.value = u.done ? l : O, u;
    },
    toString: () => {
      const V = Math.min(T0(L), Fd), O = gV((D) => L.next(V * D).value, V, 30);
      return V + "ms " + O;
    },
    toTransition: () => {
    }
  };
  return L;
}
Ud.applyToOptions = (e) => {
  const t = J9(e, 100, Ud);
  return e.ease = t.ease, e.duration = /* @__PURE__ */ Rr(t.duration), e.type = "keyframes", e;
};
function Bg({ keyframes: e, velocity: t = 0, power: n = 0.8, timeConstant: r = 325, bounceDamping: i = 10, bounceStiffness: s = 500, modifyTarget: l, min: u, max: d, restDelta: h = 0.5, restSpeed: f }) {
  const m = e[0], g = {
    done: !1,
    value: m
  }, w = (B) => u !== void 0 && B < u || d !== void 0 && B > d, E = (B) => u === void 0 ? d : d === void 0 || Math.abs(u - B) < Math.abs(d - B) ? u : d;
  let b = n * t;
  const A = m + b, x = l === void 0 ? A : l(A);
  x !== A && (b = x - m);
  const R = (B) => -b * Math.exp(-B / r), _ = (B) => x + R(B), L = (B) => {
    const H = R(B), J = _(B);
    g.done = Math.abs(H) <= h, g.value = g.done ? x : J;
  };
  let V, O;
  const D = (B) => {
    w(g.value) && (V = B, O = Ud({
      keyframes: [g.value, E(g.value)],
      velocity: vV(_, B, g.value),
      // TODO: This should be passing * 1000
      damping: i,
      stiffness: s,
      restDelta: h,
      restSpeed: f
    }));
  };
  return D(0), {
    calculatedDuration: null,
    next: (B) => {
      let H = !1;
      return !O && V === void 0 && (H = !0, L(B), D(B)), V !== void 0 && B >= V ? O.next(B - V) : (!H && L(B), g);
    }
  };
}
function a8(e, t, n) {
  const r = [], i = n || Dr.mix || mV, s = e.length - 1;
  for (let l = 0; l < s; l++) {
    let u = i(e[l], e[l + 1]);
    if (t) {
      const d = Array.isArray(t) ? t[l] || ia : t;
      u = Tf(d, u);
    }
    r.push(u);
  }
  return r;
}
function l8(e, t, { clamp: n = !0, ease: r, mixer: i } = {}) {
  const s = e.length;
  if (b0(s === t.length), s === 1)
    return () => t[0];
  if (s === 2 && t[0] === t[1])
    return () => t[1];
  const l = e[0] === e[1];
  e[0] > e[s - 1] && (e = [...e].reverse(), t = [...t].reverse());
  const u = a8(t, r, i), d = u.length, h = (f) => {
    if (l && f < e[0])
      return t[0];
    let m = 0;
    if (d > 1)
      for (; m < e.length - 2 && !(f < e[m + 1]); m++)
        ;
    const g = /* @__PURE__ */ Y$(e[m], e[m + 1], f);
    return u[m](g);
  };
  return n ? (f) => h(wo(e[0], e[s - 1], f)) : h;
}
function u8(e, t) {
  const n = e[e.length - 1];
  for (let r = 1; r <= t; r++) {
    const i = /* @__PURE__ */ Y$(0, t, r);
    e.push($f(n, 1, i));
  }
}
function c8(e) {
  const t = [0];
  return u8(t, e.length - 1), t;
}
function d8(e, t) {
  return e.map((n) => n * t);
}
function f8(e, t) {
  return e.map(() => t || iV).splice(0, e.length - 1);
}
function _l({ duration: e = 300, keyframes: t, times: n, ease: r = "easeInOut" }) {
  const i = A9(r) ? r.map(ix) : ix(r), s = {
    done: !1,
    value: t[0]
  }, l = d8(
    // Only use the provided offsets if they're the correct length
    // TODO Maybe we should warn here if there's a length mismatch
    n && n.length === t.length ? n : c8(t),
    e
  ), u = l8(l, t, {
    ease: Array.isArray(i) ? i : f8(t, i)
  });
  return {
    calculatedDuration: e,
    next: (d) => (s.value = u(d), s.done = d >= e, s)
  };
}
const h8 = (e) => e !== null;
function $0(e, { repeat: t, repeatType: n = "loop" }, r, i = 1) {
  const s = e.filter(h8), l = i < 0 || t && n !== "loop" && t % 2 === 1 ? 0 : s.length - 1;
  return !l || r === void 0 ? s[l] : r;
}
const p8 = {
  decay: Bg,
  inertia: Bg,
  tween: _l,
  keyframes: _l,
  spring: Ud
};
function yV(e) {
  typeof e.type == "string" && (e.type = p8[e.type]);
}
let V0 = class {
  constructor() {
    this.updateFinished();
  }
  get finished() {
    return this._finished;
  }
  updateFinished() {
    this._finished = new Promise((t) => {
      this.resolve = t;
    });
  }
  notifyFinished() {
    this.resolve();
  }
  /**
   * Allows the animation to be awaited.
   *
   * @deprecated Use `finished` instead.
   */
  then(t, n) {
    return this.finished.then(t, n);
  }
};
const m8 = (e) => e / 100;
let _0 = class extends V0 {
  constructor(t) {
    super(), this.state = "idle", this.startTime = null, this.isStopped = !1, this.currentTime = 0, this.holdTime = null, this.playbackSpeed = 1, this.stop = () => {
      var n, r;
      const { motionValue: i } = this.options;
      i && i.updatedAt !== Sn.now() && this.tick(Sn.now()), this.isStopped = !0, this.state !== "idle" && (this.teardown(), (r = (n = this.options).onStop) == null || r.call(n));
    }, this.options = t, this.initAnimation(), this.play(), t.autoplay === !1 && this.pause();
  }
  initAnimation() {
    const { options: t } = this;
    yV(t);
    const { type: n = _l, repeat: r = 0, repeatDelay: i = 0, repeatType: s, velocity: l = 0 } = t;
    let { keyframes: u } = t;
    const d = n || _l;
    d !== _l && typeof u[0] != "number" && (this.mixKeyframes = Tf(m8, mV(u[0], u[1])), u = [0, 100]);
    const h = d({ ...t, keyframes: u });
    s === "mirror" && (this.mirroredGenerator = d({
      ...t,
      keyframes: [...u].reverse(),
      velocity: -l
    })), h.calculatedDuration === null && (h.calculatedDuration = T0(h));
    const { calculatedDuration: f } = h;
    this.calculatedDuration = f, this.resolvedDuration = f + i, this.totalDuration = this.resolvedDuration * (r + 1) - i, this.generator = h;
  }
  updateTime(t) {
    const n = Math.round(t - this.startTime) * this.playbackSpeed;
    this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = n;
  }
  tick(t, n = !1) {
    const { generator: r, totalDuration: i, mixKeyframes: s, mirroredGenerator: l, resolvedDuration: u, calculatedDuration: d } = this;
    if (this.startTime === null)
      return r.next(0);
    const { delay: h = 0, keyframes: f, repeat: m, repeatType: g, repeatDelay: w, type: E, onUpdate: b, finalKeyframe: A } = this.options;
    this.speed > 0 ? this.startTime = Math.min(this.startTime, t) : this.speed < 0 && (this.startTime = Math.min(t - i / this.speed, this.startTime)), n ? this.currentTime = t : this.updateTime(t);
    const x = this.currentTime - h * (this.playbackSpeed >= 0 ? 1 : -1), R = this.playbackSpeed >= 0 ? x < 0 : x > i;
    this.currentTime = Math.max(x, 0), this.state === "finished" && this.holdTime === null && (this.currentTime = i);
    let _ = this.currentTime, L = r;
    if (m) {
      const B = Math.min(this.currentTime, i) / u;
      let H = Math.floor(B), J = B % 1;
      !J && B >= 1 && (J = 1), J === 1 && H--, H = Math.min(H, m + 1), H % 2 && (g === "reverse" ? (J = 1 - J, w && (J -= w / u)) : g === "mirror" && (L = l)), _ = wo(0, 1, J) * u;
    }
    const V = R ? { done: !1, value: f[0] } : L.next(_);
    s && (V.value = s(V.value));
    let { done: O } = V;
    !R && d !== null && (O = this.playbackSpeed >= 0 ? this.currentTime >= i : this.currentTime <= 0);
    const D = this.holdTime === null && (this.state === "finished" || this.state === "running" && O);
    return D && E !== Bg && (V.value = $0(f, this.options, A, this.speed)), b && b(V.value), D && this.finish(), V;
  }
  /**
   * Allows the returned animation to be awaited or promise-chained. Currently
   * resolves when the animation finishes at all but in a future update could/should
   * reject if its cancels.
   */
  then(t, n) {
    return this.finished.then(t, n);
  }
  get duration() {
    return /* @__PURE__ */ Tr(this.calculatedDuration);
  }
  get time() {
    return /* @__PURE__ */ Tr(this.currentTime);
  }
  set time(t) {
    var n;
    t = /* @__PURE__ */ Rr(t), this.currentTime = t, this.startTime === null || this.holdTime !== null || this.playbackSpeed === 0 ? this.holdTime = t : this.driver && (this.startTime = this.driver.now() - t / this.playbackSpeed), (n = this.driver) == null || n.start(!1);
  }
  get speed() {
    return this.playbackSpeed;
  }
  set speed(t) {
    this.updateTime(Sn.now());
    const n = this.playbackSpeed !== t;
    this.playbackSpeed = t, n && (this.time = /* @__PURE__ */ Tr(this.currentTime));
  }
  play() {
    var t, n;
    if (this.isStopped)
      return;
    const { driver: r = Q9, startTime: i } = this.options;
    this.driver || (this.driver = r((l) => this.tick(l))), (n = (t = this.options).onPlay) == null || n.call(t);
    const s = this.driver.now();
    this.state === "finished" ? (this.updateFinished(), this.startTime = s) : this.holdTime !== null ? this.startTime = s - this.holdTime : this.startTime || (this.startTime = i ?? s), this.state === "finished" && this.speed < 0 && (this.startTime += this.calculatedDuration), this.holdTime = null, this.state = "running", this.driver.start();
  }
  pause() {
    this.state = "paused", this.updateTime(Sn.now()), this.holdTime = this.currentTime;
  }
  complete() {
    this.state !== "running" && this.play(), this.state = "finished", this.holdTime = null;
  }
  finish() {
    var t, n;
    this.notifyFinished(), this.teardown(), this.state = "finished", (n = (t = this.options).onComplete) == null || n.call(t);
  }
  cancel() {
    var t, n;
    this.holdTime = null, this.startTime = 0, this.tick(0), this.teardown(), (n = (t = this.options).onCancel) == null || n.call(t);
  }
  teardown() {
    this.state = "idle", this.stopDriver(), this.startTime = this.holdTime = null;
  }
  stopDriver() {
    this.driver && (this.driver.stop(), this.driver = void 0);
  }
  sample(t) {
    return this.startTime = 0, this.tick(t, !0);
  }
  attachTimeline(t) {
    var n;
    return this.options.allowFlatten && (this.options.type = "keyframes", this.options.ease = "linear", this.initAnimation()), (n = this.driver) == null || n.stop(), t.observe(this);
  }
};
function g8(e) {
  for (let t = 1; t < e.length; t++)
    e[t] ?? (e[t] = e[t - 1]);
}
const Xi = (e) => e * 180 / Math.PI, Ng = (e) => {
  const t = Xi(Math.atan2(e[1], e[0]));
  return Dg(t);
}, v8 = {
  x: 4,
  y: 5,
  translateX: 4,
  translateY: 5,
  scaleX: 0,
  scaleY: 3,
  scale: (e) => (Math.abs(e[0]) + Math.abs(e[3])) / 2,
  rotate: Ng,
  rotateZ: Ng,
  skewX: (e) => Xi(Math.atan(e[1])),
  skewY: (e) => Xi(Math.atan(e[2])),
  skew: (e) => (Math.abs(e[1]) + Math.abs(e[2])) / 2
}, Dg = (e) => (e = e % 360, e < 0 && (e += 360), e), cx = Ng, dx = (e) => Math.sqrt(e[0] * e[0] + e[1] * e[1]), fx = (e) => Math.sqrt(e[4] * e[4] + e[5] * e[5]), y8 = {
  x: 12,
  y: 13,
  z: 14,
  translateX: 12,
  translateY: 13,
  translateZ: 14,
  scaleX: dx,
  scaleY: fx,
  scale: (e) => (dx(e) + fx(e)) / 2,
  rotateX: (e) => Dg(Xi(Math.atan2(e[6], e[5]))),
  rotateY: (e) => Dg(Xi(Math.atan2(-e[2], e[0]))),
  rotateZ: cx,
  rotate: cx,
  skewX: (e) => Xi(Math.atan(e[4])),
  skewY: (e) => Xi(Math.atan(e[1])),
  skew: (e) => (Math.abs(e[1]) + Math.abs(e[4])) / 2
};
function jg(e) {
  return e.includes("scale") ? 1 : 0;
}
function Fg(e, t) {
  if (!e || e === "none")
    return jg(t);
  const n = e.match(/^matrix3d\(([-\d.e\s,]+)\)$/u);
  let r, i;
  if (n)
    r = y8, i = n;
  else {
    const u = e.match(/^matrix\(([-\d.e\s,]+)\)$/u);
    r = v8, i = u;
  }
  if (!i)
    return jg(t);
  const s = r[t], l = i[1].split(",").map(b8);
  return typeof s == "function" ? s(l) : l[s];
}
const w8 = (e, t) => {
  const { transform: n = "none" } = getComputedStyle(e);
  return Fg(n, t);
};
function b8(e) {
  return parseFloat(e.trim());
}
const aa = [
  "transformPerspective",
  "x",
  "y",
  "z",
  "translateX",
  "translateY",
  "translateZ",
  "scale",
  "scaleX",
  "scaleY",
  "rotate",
  "rotateX",
  "rotateY",
  "rotateZ",
  "skew",
  "skewX",
  "skewY"
], la = new Set(aa), hx = (e) => e === oa || e === Te, C8 = /* @__PURE__ */ new Set(["x", "y", "z"]), E8 = aa.filter((e) => !C8.has(e));
function A8(e) {
  const t = [];
  return E8.forEach((n) => {
    const r = e.getValue(n);
    r !== void 0 && (t.push([n, r.get()]), r.set(n.startsWith("scale") ? 1 : 0));
  }), t;
}
const lo = {
  // Dimensions
  width: ({ x: e }, { paddingLeft: t = "0", paddingRight: n = "0" }) => e.max - e.min - parseFloat(t) - parseFloat(n),
  height: ({ y: e }, { paddingTop: t = "0", paddingBottom: n = "0" }) => e.max - e.min - parseFloat(t) - parseFloat(n),
  top: (e, { top: t }) => parseFloat(t),
  left: (e, { left: t }) => parseFloat(t),
  bottom: ({ y: e }, { top: t }) => parseFloat(t) + (e.max - e.min),
  right: ({ x: e }, { left: t }) => parseFloat(t) + (e.max - e.min),
  // Transform
  x: (e, { transform: t }) => Fg(t, "x"),
  y: (e, { transform: t }) => Fg(t, "y")
};
lo.translateX = lo.x;
lo.translateY = lo.y;
const uo = /* @__PURE__ */ new Set();
let Ug = !1, Wg = !1, zg = !1;
function wV() {
  if (Wg) {
    const e = Array.from(uo).filter((r) => r.needsMeasurement), t = new Set(e.map((r) => r.element)), n = /* @__PURE__ */ new Map();
    t.forEach((r) => {
      const i = A8(r);
      i.length && (n.set(r, i), r.render());
    }), e.forEach((r) => r.measureInitialState()), t.forEach((r) => {
      r.render();
      const i = n.get(r);
      i && i.forEach(([s, l]) => {
        var u;
        (u = r.getValue(s)) == null || u.set(l);
      });
    }), e.forEach((r) => r.measureEndState()), e.forEach((r) => {
      r.suspendedScrollY !== void 0 && window.scrollTo(0, r.suspendedScrollY);
    });
  }
  Wg = !1, Ug = !1, uo.forEach((e) => e.complete(zg)), uo.clear();
}
function bV() {
  uo.forEach((e) => {
    e.readKeyframes(), e.needsMeasurement && (Wg = !0);
  });
}
function x8() {
  zg = !0, bV(), wV(), zg = !1;
}
let I0 = class {
  constructor(t, n, r, i, s, l = !1) {
    this.state = "pending", this.isAsync = !1, this.needsMeasurement = !1, this.unresolvedKeyframes = [...t], this.onComplete = n, this.name = r, this.motionValue = i, this.element = s, this.isAsync = l;
  }
  scheduleResolve() {
    this.state = "scheduled", this.isAsync ? (uo.add(this), Ug || (Ug = !0, Hn.read(bV), Hn.resolveKeyframes(wV))) : (this.readKeyframes(), this.complete());
  }
  readKeyframes() {
    const { unresolvedKeyframes: t, name: n, element: r, motionValue: i } = this;
    if (t[0] === null) {
      const s = i == null ? void 0 : i.get(), l = t[t.length - 1];
      if (s !== void 0)
        t[0] = s;
      else if (r && n) {
        const u = r.readValue(n, l);
        u != null && (t[0] = u);
      }
      t[0] === void 0 && (t[0] = l), i && s === void 0 && i.set(t[0]);
    }
    g8(t);
  }
  setFinalKeyframe() {
  }
  measureInitialState() {
  }
  renderEndStyles() {
  }
  measureEndState() {
  }
  complete(t = !1) {
    this.state = "complete", this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, t), uo.delete(this);
  }
  cancel() {
    this.state === "scheduled" && (uo.delete(this), this.state = "pending");
  }
  resume() {
    this.state === "pending" && this.scheduleResolve();
  }
};
const S8 = (e) => e.startsWith("--");
function k8(e, t, n) {
  S8(t) ? e.style.setProperty(t, n) : e.style[t] = n;
}
const R8 = /* @__PURE__ */ C0(() => window.ScrollTimeline !== void 0), T8 = {};
function $8(e, t) {
  const n = /* @__PURE__ */ C0(e);
  return () => T8[t] ?? n();
}
const CV = /* @__PURE__ */ $8(() => {
  try {
    document.createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" });
  } catch {
    return !1;
  }
  return !0;
}, "linearEasing"), wl = ([e, t, n, r]) => `cubic-bezier(${e}, ${t}, ${n}, ${r})`, px = {
  linear: "linear",
  ease: "ease",
  easeIn: "ease-in",
  easeOut: "ease-out",
  easeInOut: "ease-in-out",
  circIn: /* @__PURE__ */ wl([0, 0.65, 0.55, 1]),
  circOut: /* @__PURE__ */ wl([0.55, 0, 1, 0.45]),
  backIn: /* @__PURE__ */ wl([0.31, 0.01, 0.66, -0.59]),
  backOut: /* @__PURE__ */ wl([0.33, 1.53, 0.69, 0.99])
};
function EV(e, t) {
  if (e)
    return typeof e == "function" ? CV() ? gV(e, t) : "ease-out" : oV(e) ? wl(e) : Array.isArray(e) ? e.map((n) => EV(n, t) || px.easeOut) : px[e];
}
function V8(e, t, n, { delay: r = 0, duration: i = 300, repeat: s = 0, repeatType: l = "loop", ease: u = "easeOut", times: d } = {}, h = void 0) {
  const f = {
    [t]: n
  };
  d && (f.offset = d);
  const m = EV(u, i);
  Array.isArray(m) && (f.easing = m);
  const g = {
    delay: r,
    duration: i,
    easing: Array.isArray(m) ? "linear" : m,
    fill: "both",
    iterations: s + 1,
    direction: l === "reverse" ? "alternate" : "normal"
  };
  return h && (g.pseudoElement = h), e.animate(f, g);
}
function AV(e) {
  return typeof e == "function" && "applyToOptions" in e;
}
function _8({ type: e, ...t }) {
  return AV(e) && CV() ? e.applyToOptions(t) : (t.duration ?? (t.duration = 300), t.ease ?? (t.ease = "easeOut"), t);
}
let I8 = class extends V0 {
  constructor(t) {
    if (super(), this.finishedTime = null, this.isStopped = !1, !t)
      return;
    const { element: n, name: r, keyframes: i, pseudoElement: s, allowFlatten: l = !1, finalKeyframe: u, onComplete: d } = t;
    this.isPseudoElement = !!s, this.allowFlatten = l, this.options = t, b0(typeof t.type != "string");
    const h = _8(t);
    this.animation = V8(n, r, i, h, s), h.autoplay === !1 && this.animation.pause(), this.animation.onfinish = () => {
      if (this.finishedTime = this.time, !s) {
        const f = $0(i, this.options, u, this.speed);
        this.updateMotionValue ? this.updateMotionValue(f) : k8(n, r, f), this.animation.cancel();
      }
      d == null || d(), this.notifyFinished();
    };
  }
  play() {
    this.isStopped || (this.animation.play(), this.state === "finished" && this.updateFinished());
  }
  pause() {
    this.animation.pause();
  }
  complete() {
    var t, n;
    (n = (t = this.animation).finish) == null || n.call(t);
  }
  cancel() {
    try {
      this.animation.cancel();
    } catch {
    }
  }
  stop() {
    if (this.isStopped)
      return;
    this.isStopped = !0;
    const { state: t } = this;
    t === "idle" || t === "finished" || (this.updateMotionValue ? this.updateMotionValue() : this.commitStyles(), this.isPseudoElement || this.cancel());
  }
  /**
   * WAAPI doesn't natively have any interruption capabilities.
   *
   * In this method, we commit styles back to the DOM before cancelling
   * the animation.
   *
   * This is designed to be overridden by NativeAnimationExtended, which
   * will create a renderless JS animation and sample it twice to calculate
   * its current value, "previous" value, and therefore allow
   * Motion to also correctly calculate velocity for any subsequent animation
   * while deferring the commit until the next animation frame.
   */
  commitStyles() {
    var t, n;
    this.isPseudoElement || (n = (t = this.animation).commitStyles) == null || n.call(t);
  }
  get duration() {
    var t, n;
    const r = ((n = (t = this.animation.effect) == null ? void 0 : t.getComputedTiming) == null ? void 0 : n.call(t).duration) || 0;
    return /* @__PURE__ */ Tr(Number(r));
  }
  get time() {
    return /* @__PURE__ */ Tr(Number(this.animation.currentTime) || 0);
  }
  set time(t) {
    this.finishedTime = null, this.animation.currentTime = /* @__PURE__ */ Rr(t);
  }
  /**
   * The playback speed of the animation.
   * 1 = normal speed, 2 = double speed, 0.5 = half speed.
   */
  get speed() {
    return this.animation.playbackRate;
  }
  set speed(t) {
    t < 0 && (this.finishedTime = null), this.animation.playbackRate = t;
  }
  get state() {
    return this.finishedTime !== null ? "finished" : this.animation.playState;
  }
  get startTime() {
    return Number(this.animation.startTime);
  }
  set startTime(t) {
    this.animation.startTime = t;
  }
  /**
   * Attaches a timeline to the animation, for instance the `ScrollTimeline`.
   */
  attachTimeline({ timeline: t, observe: n }) {
    var r;
    return this.allowFlatten && ((r = this.animation.effect) == null || r.updateTiming({ easing: "linear" })), this.animation.onfinish = null, t && R8() ? (this.animation.timeline = t, ia) : n(this);
  }
};
const xV = {
  anticipate: nV,
  backInOut: tV,
  circInOut: rV
};
function L8(e) {
  return e in xV;
}
function P8(e) {
  typeof e.ease == "string" && L8(e.ease) && (e.ease = xV[e.ease]);
}
const mx = 10;
let M8 = class extends I8 {
  constructor(t) {
    P8(t), yV(t), super(t), t.startTime && (this.startTime = t.startTime), this.options = t;
  }
  /**
   * WAAPI doesn't natively have any interruption capabilities.
   *
   * Rather than read commited styles back out of the DOM, we can
   * create a renderless JS animation and sample it twice to calculate
   * its current value, "previous" value, and therefore allow
   * Motion to calculate velocity for any subsequent animation.
   */
  updateMotionValue(t) {
    const { motionValue: n, onUpdate: r, onComplete: i, element: s, ...l } = this.options;
    if (!n)
      return;
    if (t !== void 0) {
      n.set(t);
      return;
    }
    const u = new _0({
      ...l,
      autoplay: !1
    }), d = /* @__PURE__ */ Rr(this.finishedTime ?? this.time);
    n.setWithVelocity(u.sample(d - mx).value, u.sample(d).value, mx), u.stop();
  }
};
const gx = (e, t) => t === "zIndex" ? !1 : !!(typeof e == "number" || Array.isArray(e) || typeof e == "string" && // It's animatable if we have a string
(sa.test(e) || e === "0") && // And it contains numbers and/or colors
!e.startsWith("url("));
function O8(e) {
  const t = e[0];
  if (e.length === 1)
    return !0;
  for (let n = 0; n < e.length; n++)
    if (e[n] !== t)
      return !0;
}
function B8(e, t, n, r) {
  const i = e[0];
  if (i === null)
    return !1;
  if (t === "display" || t === "visibility")
    return !0;
  const s = e[e.length - 1], l = gx(i, t), u = gx(s, t);
  return !l || !u ? !1 : O8(e) || (n === "spring" || AV(n)) && r;
}
function Hg(e) {
  e.duration = 0, e.type;
}
const N8 = /* @__PURE__ */ new Set([
  "opacity",
  "clipPath",
  "filter",
  "transform"
  // TODO: Could be re-enabled now we have support for linear() easing
  // "background-color"
]), D8 = /* @__PURE__ */ C0(() => Object.hasOwnProperty.call(Element.prototype, "animate"));
function j8(e) {
  var t;
  const { motionValue: n, name: r, repeatDelay: i, repeatType: s, damping: l, type: u } = e;
  if (!(((t = n == null ? void 0 : n.owner) == null ? void 0 : t.current) instanceof HTMLElement))
    return !1;
  const { onUpdate: d, transformTemplate: h } = n.owner.getProps();
  return D8() && r && N8.has(r) && (r !== "transform" || !h) && /**
  * If we're outputting values to onUpdate then we can't use WAAPI as there's
  * no way to read the value from WAAPI every frame.
  */
  !d && !i && s !== "mirror" && l !== 0 && u !== "inertia";
}
const F8 = 40;
let U8 = class extends V0 {
  constructor({ autoplay: t = !0, delay: n = 0, type: r = "keyframes", repeat: i = 0, repeatDelay: s = 0, repeatType: l = "loop", keyframes: u, name: d, motionValue: h, element: f, ...m }) {
    var g;
    super(), this.stop = () => {
      var b, A;
      this._animation && (this._animation.stop(), (b = this.stopTimeline) == null || b.call(this)), (A = this.keyframeResolver) == null || A.cancel();
    }, this.createdAt = Sn.now();
    const w = {
      autoplay: t,
      delay: n,
      type: r,
      repeat: i,
      repeatDelay: s,
      repeatType: l,
      name: d,
      motionValue: h,
      element: f,
      ...m
    }, E = (f == null ? void 0 : f.KeyframeResolver) || I0;
    this.keyframeResolver = new E(u, (b, A, x) => this.onKeyframesResolved(b, A, w, !x), d, h, f), (g = this.keyframeResolver) == null || g.scheduleResolve();
  }
  onKeyframesResolved(t, n, r, i) {
    this.keyframeResolver = void 0;
    const { name: s, type: l, velocity: u, delay: d, isHandoff: h, onUpdate: f } = r;
    this.resolvedAt = Sn.now(), B8(t, s, l, u) || ((Dr.instantAnimations || !d) && (f == null || f($0(t, r, n))), t[0] = t[t.length - 1], Hg(r), r.repeat = 0);
    const m = {
      startTime: i ? this.resolvedAt ? this.resolvedAt - this.createdAt > F8 ? this.resolvedAt : this.createdAt : this.createdAt : void 0,
      finalKeyframe: n,
      ...r,
      keyframes: t
    }, g = !h && j8(m) ? new M8({
      ...m,
      element: m.motionValue.owner.current
    }) : new _0(m);
    g.finished.then(() => this.notifyFinished()).catch(ia), this.pendingTimeline && (this.stopTimeline = g.attachTimeline(this.pendingTimeline), this.pendingTimeline = void 0), this._animation = g;
  }
  get finished() {
    return this._animation ? this.animation.finished : this._finished;
  }
  then(t, n) {
    return this.finished.finally(t).then(() => {
    });
  }
  get animation() {
    var t;
    return this._animation || ((t = this.keyframeResolver) == null || t.resume(), x8()), this._animation;
  }
  get duration() {
    return this.animation.duration;
  }
  get time() {
    return this.animation.time;
  }
  set time(t) {
    this.animation.time = t;
  }
  get speed() {
    return this.animation.speed;
  }
  get state() {
    return this.animation.state;
  }
  set speed(t) {
    this.animation.speed = t;
  }
  get startTime() {
    return this.animation.startTime;
  }
  attachTimeline(t) {
    return this._animation ? this.stopTimeline = this.animation.attachTimeline(t) : this.pendingTimeline = t, () => this.stop();
  }
  play() {
    this.animation.play();
  }
  pause() {
    this.animation.pause();
  }
  complete() {
    this.animation.complete();
  }
  cancel() {
    var t;
    this._animation && this.animation.cancel(), (t = this.keyframeResolver) == null || t.cancel();
  }
};
const W8 = (
  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words
  /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u
);
function z8(e) {
  const t = W8.exec(e);
  if (!t)
    return [,];
  const [, n, r, i] = t;
  return [`--${n ?? r}`, i];
}
function SV(e, t, n = 1) {
  const [r, i] = z8(e);
  if (!r)
    return;
  const s = window.getComputedStyle(t).getPropertyValue(r);
  if (s) {
    const l = s.trim();
    return K$(l) ? parseFloat(l) : l;
  }
  return x0(i) ? SV(i, t, n + 1) : i;
}
function kV(e, t) {
  return (e == null ? void 0 : e[t]) ?? (e == null ? void 0 : e.default) ?? e;
}
const RV = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  ...aa
]), H8 = {
  test: (e) => e === "auto",
  parse: (e) => e
}, TV = (e) => (t) => t.test(e), $V = [oa, Te, ys, hi, O9, M9, H8], vx = (e) => $V.find(TV(e));
function K8(e) {
  return typeof e == "number" ? e === 0 : e !== null ? e === "none" || e === "0" || G$(e) : !0;
}
const G8 = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
function Y8(e) {
  const [t, n] = e.slice(0, -1).split("(");
  if (t === "drop-shadow")
    return e;
  const [r] = n.match(S0) || [];
  if (!r)
    return e;
  const i = n.replace(r, "");
  let s = G8.has(t) ? 1 : 0;
  return r !== n && (s *= 100), t + "(" + s + i + ")";
}
const q8 = /\b([a-z-]*)\(.*?\)/gu, Kg = {
  ...sa,
  getAnimatableNone: (e) => {
    const t = e.match(q8);
    return t ? t.map(Y8).join(" ") : e;
  }
}, yx = {
  ...oa,
  transform: Math.round
}, X8 = {
  rotate: hi,
  rotateX: hi,
  rotateY: hi,
  rotateZ: hi,
  scale: Yc,
  scaleX: Yc,
  scaleY: Yc,
  scaleZ: Yc,
  skew: hi,
  skewX: hi,
  skewY: hi,
  distance: Te,
  translateX: Te,
  translateY: Te,
  translateZ: Te,
  x: Te,
  y: Te,
  z: Te,
  perspective: Te,
  transformPerspective: Te,
  opacity: Kl,
  originX: ox,
  originY: ox,
  originZ: Te
}, L0 = {
  // Border props
  borderWidth: Te,
  borderTopWidth: Te,
  borderRightWidth: Te,
  borderBottomWidth: Te,
  borderLeftWidth: Te,
  borderRadius: Te,
  radius: Te,
  borderTopLeftRadius: Te,
  borderTopRightRadius: Te,
  borderBottomRightRadius: Te,
  borderBottomLeftRadius: Te,
  // Positioning props
  width: Te,
  maxWidth: Te,
  height: Te,
  maxHeight: Te,
  top: Te,
  right: Te,
  bottom: Te,
  left: Te,
  // Spacing props
  padding: Te,
  paddingTop: Te,
  paddingRight: Te,
  paddingBottom: Te,
  paddingLeft: Te,
  margin: Te,
  marginTop: Te,
  marginRight: Te,
  marginBottom: Te,
  marginLeft: Te,
  // Misc
  backgroundPositionX: Te,
  backgroundPositionY: Te,
  ...X8,
  zIndex: yx,
  // SVG
  fillOpacity: Kl,
  strokeOpacity: Kl,
  numOctaves: yx
}, Z8 = {
  ...L0,
  // Color props
  color: ft,
  backgroundColor: ft,
  outlineColor: ft,
  fill: ft,
  stroke: ft,
  // Border props
  borderColor: ft,
  borderTopColor: ft,
  borderRightColor: ft,
  borderBottomColor: ft,
  borderLeftColor: ft,
  filter: Kg,
  WebkitFilter: Kg
}, VV = (e) => Z8[e];
function _V(e, t) {
  let n = VV(e);
  return n !== Kg && (n = sa), n.getAnimatableNone ? n.getAnimatableNone(t) : void 0;
}
const Q8 = /* @__PURE__ */ new Set(["auto", "none", "0"]);
function J8(e, t, n) {
  let r = 0, i;
  for (; r < e.length && !i; ) {
    const s = e[r];
    typeof s == "string" && !Q8.has(s) && Gl(s).values.length && (i = e[r]), r++;
  }
  if (i && n)
    for (const s of t)
      e[s] = _V(n, i);
}
let eH = class extends I0 {
  constructor(t, n, r, i, s) {
    super(t, n, r, i, s, !0);
  }
  readKeyframes() {
    const { unresolvedKeyframes: t, element: n, name: r } = this;
    if (!n || !n.current)
      return;
    super.readKeyframes();
    for (let d = 0; d < t.length; d++) {
      let h = t[d];
      if (typeof h == "string" && (h = h.trim(), x0(h))) {
        const f = SV(h, n.current);
        f !== void 0 && (t[d] = f), d === t.length - 1 && (this.finalKeyframe = h);
      }
    }
    if (this.resolveNoneKeyframes(), !RV.has(r) || t.length !== 2)
      return;
    const [i, s] = t, l = vx(i), u = vx(s);
    if (l !== u)
      if (hx(l) && hx(u))
        for (let d = 0; d < t.length; d++) {
          const h = t[d];
          typeof h == "string" && (t[d] = parseFloat(h));
        }
      else lo[r] && (this.needsMeasurement = !0);
  }
  resolveNoneKeyframes() {
    const { unresolvedKeyframes: t, name: n } = this, r = [];
    for (let i = 0; i < t.length; i++)
      (t[i] === null || K8(t[i])) && r.push(i);
    r.length && J8(t, r, n);
  }
  measureInitialState() {
    const { element: t, unresolvedKeyframes: n, name: r } = this;
    if (!t || !t.current)
      return;
    r === "height" && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = lo[r](t.measureViewportBox(), window.getComputedStyle(t.current)), n[0] = this.measuredOrigin;
    const i = n[n.length - 1];
    i !== void 0 && t.getValue(r, i).jump(i, !1);
  }
  measureEndState() {
    var t;
    const { element: n, name: r, unresolvedKeyframes: i } = this;
    if (!n || !n.current)
      return;
    const s = n.getValue(r);
    s && s.jump(this.measuredOrigin, !1);
    const l = i.length - 1, u = i[l];
    i[l] = lo[r](n.measureViewportBox(), window.getComputedStyle(n.current)), u !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = u), (t = this.removedTransforms) != null && t.length && this.removedTransforms.forEach(([d, h]) => {
      n.getValue(d).set(h);
    }), this.resolveNoneKeyframes();
  }
};
function tH(e, t, n) {
  if (e instanceof EventTarget)
    return [e];
  if (typeof e == "string") {
    const i = document.querySelectorAll(e);
    return i ? Array.from(i) : [];
  }
  return Array.from(e);
}
const IV = (e, t) => t && typeof e == "number" ? t.transform(e) : e;
function nH(e) {
  return m9(e) && "offsetHeight" in e;
}
const wx = 30, rH = (e) => !isNaN(parseFloat(e));
let iH = class {
  /**
   * @param init - The initiating value
   * @param config - Optional configuration options
   *
   * -  `transformer`: A function to transform incoming values with.
   */
  constructor(t, n = {}) {
    this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = (r) => {
      var i;
      const s = Sn.now();
      if (this.updatedAt !== s && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(r), this.current !== this.prev && ((i = this.events.change) == null || i.notify(this.current), this.dependents))
        for (const l of this.dependents)
          l.dirty();
    }, this.hasAnimated = !1, this.setCurrent(t), this.owner = n.owner;
  }
  setCurrent(t) {
    this.current = t, this.updatedAt = Sn.now(), this.canTrackVelocity === null && t !== void 0 && (this.canTrackVelocity = rH(this.current));
  }
  setPrevFrameValue(t = this.current) {
    this.prevFrameValue = t, this.prevUpdatedAt = this.updatedAt;
  }
  /**
   * Adds a function that will be notified when the `MotionValue` is updated.
   *
   * It returns a function that, when called, will cancel the subscription.
   *
   * When calling `onChange` inside a React component, it should be wrapped with the
   * `useEffect` hook. As it returns an unsubscribe function, this should be returned
   * from the `useEffect` function to ensure you don't add duplicate subscribers..
   *
   * ```jsx
   * export const MyComponent = () => {
   *   const x = useMotionValue(0)
   *   const y = useMotionValue(0)
   *   const opacity = useMotionValue(1)
   *
   *   useEffect(() => {
   *     function updateOpacity() {
   *       const maxXY = Math.max(x.get(), y.get())
   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
   *       opacity.set(newOpacity)
   *     }
   *
   *     const unsubscribeX = x.on("change", updateOpacity)
   *     const unsubscribeY = y.on("change", updateOpacity)
   *
   *     return () => {
   *       unsubscribeX()
   *       unsubscribeY()
   *     }
   *   }, [])
   *
   *   return <motion.div style={{ x }} />
   * }
   * ```
   *
   * @param subscriber - A function that receives the latest value.
   * @returns A function that, when called, will cancel this subscription.
   *
   * @deprecated
   */
  onChange(t) {
    return this.on("change", t);
  }
  on(t, n) {
    this.events[t] || (this.events[t] = new q$());
    const r = this.events[t].add(n);
    return t === "change" ? () => {
      r(), Hn.read(() => {
        this.events.change.getSize() || this.stop();
      });
    } : r;
  }
  clearListeners() {
    for (const t in this.events)
      this.events[t].clear();
  }
  /**
   * Attaches a passive effect to the `MotionValue`.
   */
  attach(t, n) {
    this.passiveEffect = t, this.stopPassiveEffect = n;
  }
  /**
   * Sets the state of the `MotionValue`.
   *
   * @remarks
   *
   * ```jsx
   * const x = useMotionValue(0)
   * x.set(10)
   * ```
   *
   * @param latest - Latest value to set.
   * @param render - Whether to notify render subscribers. Defaults to `true`
   *
   * @public
   */
  set(t) {
    this.passiveEffect ? this.passiveEffect(t, this.updateAndNotify) : this.updateAndNotify(t);
  }
  setWithVelocity(t, n, r) {
    this.set(n), this.prev = void 0, this.prevFrameValue = t, this.prevUpdatedAt = this.updatedAt - r;
  }
  /**
   * Set the state of the `MotionValue`, stopping any active animations,
   * effects, and resets velocity to `0`.
   */
  jump(t, n = !0) {
    this.updateAndNotify(t), this.prev = t, this.prevUpdatedAt = this.prevFrameValue = void 0, n && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
  dirty() {
    var t;
    (t = this.events.change) == null || t.notify(this.current);
  }
  addDependent(t) {
    this.dependents || (this.dependents = /* @__PURE__ */ new Set()), this.dependents.add(t);
  }
  removeDependent(t) {
    this.dependents && this.dependents.delete(t);
  }
  /**
   * Returns the latest state of `MotionValue`
   *
   * @returns - The latest state of `MotionValue`
   *
   * @public
   */
  get() {
    return this.current;
  }
  /**
   * @public
   */
  getPrevious() {
    return this.prev;
  }
  /**
   * Returns the latest velocity of `MotionValue`
   *
   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
   *
   * @public
   */
  getVelocity() {
    const t = Sn.now();
    if (!this.canTrackVelocity || this.prevFrameValue === void 0 || t - this.updatedAt > wx)
      return 0;
    const n = Math.min(this.updatedAt - this.prevUpdatedAt, wx);
    return X$(parseFloat(this.current) - parseFloat(this.prevFrameValue), n);
  }
  /**
   * Registers a new animation to control this `MotionValue`. Only one
   * animation can drive a `MotionValue` at one time.
   *
   * ```jsx
   * value.start()
   * ```
   *
   * @param animation - A function that starts the provided animation
   */
  start(t) {
    return this.stop(), new Promise((n) => {
      this.hasAnimated = !0, this.animation = t(n), this.events.animationStart && this.events.animationStart.notify();
    }).then(() => {
      this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation();
    });
  }
  /**
   * Stop the currently active animation.
   *
   * @public
   */
  stop() {
    this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation();
  }
  /**
   * Returns `true` if this value is currently animating.
   *
   * @public
   */
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  /**
   * Destroy and clean up subscribers to this `MotionValue`.
   *
   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
   * created a `MotionValue` via the `motionValue` function.
   *
   * @public
   */
  destroy() {
    var t, n;
    (t = this.dependents) == null || t.clear(), (n = this.events.destroy) == null || n.notify(), this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
};
function Wd(e, t) {
  return new iH(e, t);
}
const { schedule: oH } = /* @__PURE__ */ sV(queueMicrotask, !1), sH = {
  y: !1
};
function aH() {
  return sH.y;
}
function LV(e, t) {
  const n = tH(e), r = new AbortController(), i = {
    passive: !0,
    ...t,
    signal: r.signal
  };
  return [n, i, () => r.abort()];
}
function bx(e) {
  return !(e.pointerType === "touch" || aH());
}
function lH(e, t, n = {}) {
  const [r, i, s] = LV(e, n), l = (u) => {
    if (!bx(u))
      return;
    const { target: d } = u, h = t(d, u);
    if (typeof h != "function" || !d)
      return;
    const f = (m) => {
      bx(m) && (h(m), d.removeEventListener("pointerleave", f));
    };
    d.addEventListener("pointerleave", f, i);
  };
  return r.forEach((u) => {
    u.addEventListener("pointerenter", l, i);
  }), s;
}
const PV = (e, t) => t ? e === t ? !0 : PV(e, t.parentElement) : !1, uH = (e) => e.pointerType === "mouse" ? typeof e.button != "number" || e.button <= 0 : e.isPrimary !== !1, cH = /* @__PURE__ */ new Set([
  "BUTTON",
  "INPUT",
  "SELECT",
  "TEXTAREA",
  "A"
]);
function dH(e) {
  return cH.has(e.tagName) || e.tabIndex !== -1;
}
const yd = /* @__PURE__ */ new WeakSet();
function Cx(e) {
  return (t) => {
    t.key === "Enter" && e(t);
  };
}
function Cm(e, t) {
  e.dispatchEvent(new PointerEvent("pointer" + t, { isPrimary: !0, bubbles: !0 }));
}
const fH = (e, t) => {
  const n = e.currentTarget;
  if (!n)
    return;
  const r = Cx(() => {
    if (yd.has(n))
      return;
    Cm(n, "down");
    const i = Cx(() => {
      Cm(n, "up");
    }), s = () => Cm(n, "cancel");
    n.addEventListener("keyup", i, t), n.addEventListener("blur", s, t);
  });
  n.addEventListener("keydown", r, t), n.addEventListener("blur", () => n.removeEventListener("keydown", r), t);
};
function Ex(e) {
  return uH(e) && !0;
}
function hH(e, t, n = {}) {
  const [r, i, s] = LV(e, n), l = (u) => {
    const d = u.currentTarget;
    if (!Ex(u))
      return;
    yd.add(d);
    const h = t(d, u), f = (w, E) => {
      window.removeEventListener("pointerup", m), window.removeEventListener("pointercancel", g), yd.has(d) && yd.delete(d), Ex(w) && typeof h == "function" && h(w, { success: E });
    }, m = (w) => {
      f(w, d === window || d === document || n.useGlobalTarget || PV(d, w.target));
    }, g = (w) => {
      f(w, !1);
    };
    window.addEventListener("pointerup", m, i), window.addEventListener("pointercancel", g, i);
  };
  return r.forEach((u) => {
    (n.useGlobalTarget ? window : u).addEventListener("pointerdown", l, i), nH(u) && (u.addEventListener("focus", (d) => fH(d, i)), !dH(u) && !u.hasAttribute("tabindex") && (u.tabIndex = 0));
  }), s;
}
const Dt = (e) => !!(e && e.getVelocity), pH = [...$V, ft, sa], mH = (e) => pH.find(TV(e)), MV = C.createContext({
  transformPagePoint: (e) => e,
  isStatic: !1,
  reducedMotion: "never"
}), P0 = C.createContext({ strict: !1 }), Ax = {
  animation: [
    "animate",
    "variants",
    "whileHover",
    "whileTap",
    "exit",
    "whileInView",
    "whileFocus",
    "whileDrag"
  ],
  exit: ["exit"],
  drag: ["drag", "dragControls"],
  focus: ["whileFocus"],
  hover: ["whileHover", "onHoverStart", "onHoverEnd"],
  tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
  pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
  inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
  layout: ["layout", "layoutId"]
}, Fs = {};
for (const e in Ax)
  Fs[e] = {
    isEnabled: (t) => Ax[e].some((n) => !!t[n])
  };
function xx(e) {
  for (const t in e)
    Fs[t] = {
      ...Fs[t],
      ...e[t]
    };
}
function gH({ children: e, features: t, strict: n = !1 }) {
  const [, r] = C.useState(!Em(t)), i = C.useRef(void 0);
  if (!Em(t)) {
    const { renderer: s, ...l } = t;
    i.current = s, xx(l);
  }
  return C.useEffect(() => {
    Em(t) && t().then(({ renderer: s, ...l }) => {
      xx(l), i.current = s, r(!0);
    });
  }, []), I.jsx(P0.Provider, { value: { renderer: i.current, strict: n }, children: e });
}
function Em(e) {
  return typeof e == "function";
}
const vH = /* @__PURE__ */ new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "custom",
  "inherit",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "globalTapTarget",
  "ignoreStrict",
  "viewport"
]);
function M0(e) {
  return e.startsWith("while") || e.startsWith("drag") && e !== "draggable" || e.startsWith("layout") || e.startsWith("onTap") || e.startsWith("onPan") || e.startsWith("onLayout") || vH.has(e);
}
let OV = (e) => !M0(e);
function yH(e) {
  typeof e == "function" && (OV = (t) => t.startsWith("on") ? !M0(t) : e(t));
}
try {
  yH(require("@emotion/is-prop-valid").default);
} catch {
}
function wH(e, t, n) {
  const r = {};
  for (const i in e)
    i === "values" && typeof e.values == "object" || (OV(i) || n === !0 && M0(i) || // If trying to use native HTML drag events, forward drag listeners
    e.draggable && i.startsWith("onDrag")) && (r[i] = e[i]);
  return r;
}
const Vf = /* @__PURE__ */ C.createContext({});
function _f(e) {
  return e !== null && typeof e == "object" && typeof e.start == "function";
}
function Yl(e) {
  return typeof e == "string" || Array.isArray(e);
}
const O0 = [
  "animate",
  "whileInView",
  "whileFocus",
  "whileHover",
  "whileTap",
  "whileDrag",
  "exit"
], B0 = ["initial", ...O0];
function If(e) {
  return _f(e.animate) || B0.some((t) => Yl(e[t]));
}
function BV(e) {
  return !!(If(e) || e.variants);
}
function bH(e, t) {
  if (If(e)) {
    const { initial: n, animate: r } = e;
    return {
      initial: n === !1 || Yl(n) ? n : void 0,
      animate: Yl(r) ? r : void 0
    };
  }
  return e.inherit !== !1 ? t : {};
}
function CH(e) {
  const { initial: t, animate: n } = bH(e, C.useContext(Vf));
  return C.useMemo(() => ({ initial: t, animate: n }), [Sx(t), Sx(n)]);
}
function Sx(e) {
  return Array.isArray(e) ? e.join(" ") : e;
}
const EH = {};
function NV(e, { layout: t, layoutId: n }) {
  return la.has(e) || e.startsWith("origin") || (t || n !== void 0) && (!!EH[e] || e === "opacity");
}
const AH = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
}, xH = aa.length;
function SH(e, t, n) {
  let r = "", i = !0;
  for (let s = 0; s < xH; s++) {
    const l = aa[s], u = e[l];
    if (u === void 0)
      continue;
    let d = !0;
    if (typeof u == "number" ? d = u === (l.startsWith("scale") ? 1 : 0) : d = parseFloat(u) === 0, !d || n) {
      const h = IV(u, L0[l]);
      if (!d) {
        i = !1;
        const f = AH[l] || l;
        r += `${f}(${h}) `;
      }
      n && (t[l] = h);
    }
  }
  return r = r.trim(), n ? r = n(t, i ? "" : r) : i && (r = "none"), r;
}
function N0(e, t, n) {
  const { style: r, vars: i, transformOrigin: s } = e;
  let l = !1, u = !1;
  for (const d in t) {
    const h = t[d];
    if (la.has(d)) {
      l = !0;
      continue;
    } else if (lV(d)) {
      i[d] = h;
      continue;
    } else {
      const f = IV(h, L0[d]);
      d.startsWith("origin") ? (u = !0, s[d] = f) : r[d] = f;
    }
  }
  if (t.transform || (l || n ? r.transform = SH(t, e.transform, n) : r.transform && (r.transform = "none")), u) {
    const { originX: d = "50%", originY: h = "50%", originZ: f = 0 } = s;
    r.transformOrigin = `${d} ${h} ${f}`;
  }
}
const D0 = () => ({
  style: {},
  transform: {},
  transformOrigin: {},
  vars: {}
});
function DV(e, t, n) {
  for (const r in t)
    !Dt(t[r]) && !NV(r, n) && (e[r] = t[r]);
}
function kH({ transformTemplate: e }, t) {
  return C.useMemo(() => {
    const n = D0();
    return N0(n, t, e), Object.assign({}, n.vars, n.style);
  }, [t]);
}
function RH(e, t) {
  const n = e.style || {}, r = {};
  return DV(r, n, e), Object.assign(r, kH(e, t)), r;
}
function TH(e, t) {
  const n = {}, r = RH(e, t);
  return e.drag && e.dragListener !== !1 && (n.draggable = !1, r.userSelect = r.WebkitUserSelect = r.WebkitTouchCallout = "none", r.touchAction = e.drag === !0 ? "none" : `pan-${e.drag === "x" ? "y" : "x"}`), e.tabIndex === void 0 && (e.onTap || e.onTapStart || e.whileTap) && (n.tabIndex = 0), n.style = r, n;
}
const $H = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
}, VH = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function _H(e, t, n = 1, r = 0, i = !0) {
  e.pathLength = 1;
  const s = i ? $H : VH;
  e[s.offset] = Te.transform(-r);
  const l = Te.transform(t), u = Te.transform(n);
  e[s.array] = `${l} ${u}`;
}
function jV(e, {
  attrX: t,
  attrY: n,
  attrScale: r,
  pathLength: i,
  pathSpacing: s = 1,
  pathOffset: l = 0,
  // This is object creation, which we try to avoid per-frame.
  ...u
}, d, h, f) {
  if (N0(e, u, h), d) {
    e.style.viewBox && (e.attrs.viewBox = e.style.viewBox);
    return;
  }
  e.attrs = e.style, e.style = {};
  const { attrs: m, style: g } = e;
  m.transform && (g.transform = m.transform, delete m.transform), (g.transform || m.transformOrigin) && (g.transformOrigin = m.transformOrigin ?? "50% 50%", delete m.transformOrigin), g.transform && (g.transformBox = (f == null ? void 0 : f.transformBox) ?? "fill-box", delete m.transformBox), t !== void 0 && (m.x = t), n !== void 0 && (m.y = n), r !== void 0 && (m.scale = r), i !== void 0 && _H(m, i, s, l, !1);
}
const FV = () => ({
  ...D0(),
  attrs: {}
}), UV = (e) => typeof e == "string" && e.toLowerCase() === "svg";
function IH(e, t, n, r) {
  const i = C.useMemo(() => {
    const s = FV();
    return jV(s, t, UV(r), e.transformTemplate, e.style), {
      ...s.attrs,
      style: { ...s.style }
    };
  }, [t]);
  if (e.style) {
    const s = {};
    DV(s, e.style, e), i.style = { ...s, ...i.style };
  }
  return i;
}
const LH = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view"
];
function j0(e) {
  return (
    /**
     * If it's not a string, it's a custom React component. Currently we only support
     * HTML custom React components.
     */
    typeof e != "string" || /**
    * If it contains a dash, the element is a custom HTML webcomponent.
    */
    e.includes("-") ? !1 : (
      /**
       * If it's in our list of lowercase SVG tags, it's an SVG component
       */
      !!(LH.indexOf(e) > -1 || /**
      * If it contains a capital letter, it's an SVG component
      */
      /[A-Z]/u.test(e))
    )
  );
}
function PH(e, t, n, { latestValues: r }, i, s = !1) {
  const l = (j0(e) ? IH : TH)(t, r, i, e), u = wH(t, typeof e == "string", s), d = e !== C.Fragment ? { ...u, ...l, ref: n } : {}, { children: h } = t, f = C.useMemo(() => Dt(h) ? h.get() : h, [h]);
  return C.createElement(e, {
    ...d,
    children: f
  });
}
function kx(e) {
  const t = [{}, {}];
  return e == null || e.values.forEach((n, r) => {
    t[0][r] = n.get(), t[1][r] = n.getVelocity();
  }), t;
}
function F0(e, t, n, r) {
  if (typeof t == "function") {
    const [i, s] = kx(r);
    t = t(n !== void 0 ? n : e.custom, i, s);
  }
  if (typeof t == "string" && (t = e.variants && e.variants[t]), typeof t == "function") {
    const [i, s] = kx(r);
    t = t(n !== void 0 ? n : e.custom, i, s);
  }
  return t;
}
function MH(e) {
  return Dt(e) ? e.get() : e;
}
function OH({ scrapeMotionValuesFromProps: e, createRenderState: t }, n, r, i) {
  return {
    latestValues: BH(n, r, i, e),
    renderState: t()
  };
}
function BH(e, t, n, r) {
  const i = {}, s = r(e, {});
  for (const g in s)
    i[g] = MH(s[g]);
  let { initial: l, animate: u } = e;
  const d = If(e), h = BV(e);
  t && h && !d && e.inherit !== !1 && (l === void 0 && (l = t.initial), u === void 0 && (u = t.animate));
  let f = n ? n.initial === !1 : !1;
  f = f || l === !1;
  const m = f ? u : l;
  if (m && typeof m != "boolean" && !_f(m)) {
    const g = Array.isArray(m) ? m : [m];
    for (let w = 0; w < g.length; w++) {
      const E = F0(e, g[w]);
      if (E) {
        const { transitionEnd: b, transition: A, ...x } = E;
        for (const R in x) {
          let _ = x[R];
          if (Array.isArray(_)) {
            const L = f ? _.length - 1 : 0;
            _ = _[L];
          }
          _ !== null && (i[R] = _);
        }
        for (const R in b)
          i[R] = b[R];
      }
    }
  }
  return i;
}
const WV = (e) => (t, n) => {
  const r = C.useContext(Vf), i = C.useContext(H$), s = () => OH(e, t, r, i);
  return n ? s() : d9(s);
};
function U0(e, t, n) {
  var r;
  const { style: i } = e, s = {};
  for (const l in i)
    (Dt(i[l]) || t.style && Dt(t.style[l]) || NV(l, e) || ((r = n == null ? void 0 : n.getValue(l)) == null ? void 0 : r.liveStyle) !== void 0) && (s[l] = i[l]);
  return s;
}
const NH = /* @__PURE__ */ WV({
  scrapeMotionValuesFromProps: U0,
  createRenderState: D0
});
function zV(e, t, n) {
  const r = U0(e, t, n);
  for (const i in e)
    if (Dt(e[i]) || Dt(t[i])) {
      const s = aa.indexOf(i) !== -1 ? "attr" + i.charAt(0).toUpperCase() + i.substring(1) : i;
      r[s] = e[i];
    }
  return r;
}
const DH = /* @__PURE__ */ WV({
  scrapeMotionValuesFromProps: zV,
  createRenderState: FV
}), jH = Symbol.for("motionComponentSymbol");
function HV(e) {
  return e && typeof e == "object" && Object.prototype.hasOwnProperty.call(e, "current");
}
function FH(e, t, n) {
  return C.useCallback(
    (r) => {
      r && e.onMount && e.onMount(r), t && (r ? t.mount(r) : t.unmount()), n && (typeof n == "function" ? n(r) : HV(n) && (n.current = r));
    },
    /**
     * Only pass a new ref callback to React if we've received a visual element
     * factory. Otherwise we'll be mounting/remounting every time externalRef
     * or other dependencies change.
     */
    [t]
  );
}
const W0 = (e) => e.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(), UH = "framerAppearId", KV = "data-" + W0(UH), WH = C.createContext({});
function zH(e, t, n, r, i) {
  var s, l;
  const { visualElement: u } = C.useContext(Vf), d = C.useContext(P0), h = C.useContext(H$), f = C.useContext(MV).reducedMotion, m = C.useRef(null);
  r = r || d.renderer, !m.current && r && (m.current = r(e, {
    visualState: t,
    parent: u,
    props: n,
    presenceContext: h,
    blockInitialAnimation: h ? h.initial === !1 : !1,
    reducedMotionConfig: f
  }));
  const g = m.current, w = C.useContext(WH);
  g && !g.projection && i && (g.type === "html" || g.type === "svg") && HH(m.current, n, i, w);
  const E = C.useRef(!1);
  C.useInsertionEffect(() => {
    g && E.current && g.update(n, h);
  });
  const b = n[KV], A = C.useRef(!!b && !((s = window.MotionHandoffIsComplete) != null && s.call(window, b)) && ((l = window.MotionHasOptimisedAnimation) == null ? void 0 : l.call(window, b)));
  return f9(() => {
    g && (E.current = !0, window.MotionIsMounted = !0, g.updateFeatures(), g.scheduleRenderMicrotask(), A.current && g.animationState && g.animationState.animateChanges());
  }), C.useEffect(() => {
    g && (!A.current && g.animationState && g.animationState.animateChanges(), A.current && (queueMicrotask(() => {
      var x;
      (x = window.MotionHandoffMarkAsComplete) == null || x.call(window, b);
    }), A.current = !1), g.enteringChildren = void 0);
  }), g;
}
function HH(e, t, n, r) {
  const { layoutId: i, layout: s, drag: l, dragConstraints: u, layoutScroll: d, layoutRoot: h, layoutCrossfade: f } = t;
  e.projection = new n(e.latestValues, t["data-framer-portal-id"] ? void 0 : GV(e.parent)), e.projection.setOptions({
    layoutId: i,
    layout: s,
    alwaysMeasureLayout: !!l || u && HV(u),
    visualElement: e,
    /**
     * TODO: Update options in an effect. This could be tricky as it'll be too late
     * to update by the time layout animations run.
     * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
     * ensuring it gets called if there's no potential layout animations.
     *
     */
    animationType: typeof s == "string" ? s : "both",
    initialPromotionConfig: r,
    crossfade: f,
    layoutScroll: d,
    layoutRoot: h
  });
}
function GV(e) {
  if (e)
    return e.options.allowProjection !== !1 ? e.projection : GV(e.parent);
}
function KH(e, { forwardMotionProps: t = !1 } = {}, n, r) {
  const i = j0(e) ? DH : NH;
  function s(u, d) {
    let h;
    const f = {
      ...C.useContext(MV),
      ...u,
      layoutId: GH(u)
    }, { isStatic: m } = f, g = CH(u), w = i(u, m);
    if (!m && w0) {
      YH();
      const E = qH(f);
      h = E.MeasureLayout, g.visualElement = zH(e, w, f, r, E.ProjectionNode);
    }
    return I.jsxs(Vf.Provider, { value: g, children: [h && g.visualElement ? I.jsx(h, { visualElement: g.visualElement, ...f }) : null, PH(e, u, FH(w, g.visualElement, d), w, m, t)] });
  }
  s.displayName = `motion.${e}`;
  const l = C.forwardRef(s);
  return l[jH] = e, l;
}
function GH({ layoutId: e }) {
  const t = C.useContext(c9).id;
  return t && e !== void 0 ? t + "-" + e : e;
}
function YH(e, t) {
  C.useContext(P0).strict;
}
function qH(e) {
  const { drag: t, layout: n } = Fs;
  if (!t && !n)
    return {};
  const r = { ...t, ...n };
  return {
    MeasureLayout: t != null && t.isEnabled(e) || n != null && n.isEnabled(e) ? r.MeasureLayout : void 0,
    ProjectionNode: r.ProjectionNode
  };
}
function XH({ top: e, left: t, right: n, bottom: r }) {
  return {
    x: { min: t, max: n },
    y: { min: e, max: r }
  };
}
function ZH(e, t) {
  if (!t)
    return e;
  const n = t({ x: e.left, y: e.top }), r = t({ x: e.right, y: e.bottom });
  return {
    top: n.y,
    left: n.x,
    bottom: r.y,
    right: r.x
  };
}
function QH(e, t) {
  return XH(ZH(e.getBoundingClientRect(), t));
}
const Rx = () => ({ min: 0, max: 0 }), YV = () => ({
  x: Rx(),
  y: Rx()
}), Gg = { current: null }, qV = { current: !1 };
function JH() {
  if (qV.current = !0, !!w0)
    if (window.matchMedia) {
      const e = window.matchMedia("(prefers-reduced-motion)"), t = () => Gg.current = e.matches;
      e.addEventListener("change", t), t();
    } else
      Gg.current = !1;
}
const e7 = /* @__PURE__ */ new WeakMap();
function t7(e, t, n) {
  for (const r in t) {
    const i = t[r], s = n[r];
    if (Dt(i))
      e.addValue(r, i);
    else if (Dt(s))
      e.addValue(r, Wd(i, { owner: e }));
    else if (s !== i)
      if (e.hasValue(r)) {
        const l = e.getValue(r);
        l.liveStyle === !0 ? l.jump(i) : l.hasAnimated || l.set(i);
      } else {
        const l = e.getStaticValue(r);
        e.addValue(r, Wd(l !== void 0 ? l : i, { owner: e }));
      }
  }
  for (const r in n)
    t[r] === void 0 && e.removeValue(r);
  return t;
}
const Tx = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete"
];
let n7 = class {
  /**
   * This method takes React props and returns found MotionValues. For example, HTML
   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
   *
   * This isn't an abstract method as it needs calling in the constructor, but it is
   * intended to be one.
   */
  scrapeMotionValuesFromProps(t, n, r) {
    return {};
  }
  constructor({ parent: t, props: n, presenceContext: r, reducedMotionConfig: i, blockInitialAnimation: s, visualState: l }, u = {}) {
    this.current = null, this.children = /* @__PURE__ */ new Set(), this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = /* @__PURE__ */ new Map(), this.KeyframeResolver = I0, this.features = {}, this.valueSubscriptions = /* @__PURE__ */ new Map(), this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => {
      this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection));
    }, this.renderScheduledAt = 0, this.scheduleRender = () => {
      const g = Sn.now();
      this.renderScheduledAt < g && (this.renderScheduledAt = g, Hn.render(this.render, !1, !0));
    };
    const { latestValues: d, renderState: h } = l;
    this.latestValues = d, this.baseTarget = { ...d }, this.initialValues = n.initial ? { ...d } : {}, this.renderState = h, this.parent = t, this.props = n, this.presenceContext = r, this.depth = t ? t.depth + 1 : 0, this.reducedMotionConfig = i, this.options = u, this.blockInitialAnimation = !!s, this.isControllingVariants = If(n), this.isVariantNode = BV(n), this.isVariantNode && (this.variantChildren = /* @__PURE__ */ new Set()), this.manuallyAnimateOnMount = !!(t && t.current);
    const { willChange: f, ...m } = this.scrapeMotionValuesFromProps(n, {}, this);
    for (const g in m) {
      const w = m[g];
      d[g] !== void 0 && Dt(w) && w.set(d[g]);
    }
  }
  mount(t) {
    var n;
    this.current = t, e7.set(t, this), this.projection && !this.projection.instance && this.projection.mount(t), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((r, i) => this.bindToMotionValue(i, r)), qV.current || JH(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : Gg.current, (n = this.parent) == null || n.addChild(this), this.update(this.props, this.presenceContext);
  }
  unmount() {
    var t;
    this.projection && this.projection.unmount(), Lg(this.notifyUpdate), Lg(this.render), this.valueSubscriptions.forEach((n) => n()), this.valueSubscriptions.clear(), this.removeFromVariantTree && this.removeFromVariantTree(), (t = this.parent) == null || t.removeChild(this);
    for (const n in this.events)
      this.events[n].clear();
    for (const n in this.features) {
      const r = this.features[n];
      r && (r.unmount(), r.isMounted = !1);
    }
    this.current = null;
  }
  addChild(t) {
    this.children.add(t), this.enteringChildren ?? (this.enteringChildren = /* @__PURE__ */ new Set()), this.enteringChildren.add(t);
  }
  removeChild(t) {
    this.children.delete(t), this.enteringChildren && this.enteringChildren.delete(t);
  }
  bindToMotionValue(t, n) {
    this.valueSubscriptions.has(t) && this.valueSubscriptions.get(t)();
    const r = la.has(t);
    r && this.onBindTransform && this.onBindTransform();
    const i = n.on("change", (l) => {
      this.latestValues[t] = l, this.props.onUpdate && Hn.preRender(this.notifyUpdate), r && this.projection && (this.projection.isTransformDirty = !0), this.scheduleRender();
    });
    let s;
    window.MotionCheckAppearSync && (s = window.MotionCheckAppearSync(this, t, n)), this.valueSubscriptions.set(t, () => {
      i(), s && s(), n.owner && n.stop();
    });
  }
  sortNodePosition(t) {
    return !this.current || !this.sortInstanceNodePosition || this.type !== t.type ? 0 : this.sortInstanceNodePosition(this.current, t.current);
  }
  updateFeatures() {
    let t = "animation";
    for (t in Fs) {
      const n = Fs[t];
      if (!n)
        continue;
      const { isEnabled: r, Feature: i } = n;
      if (!this.features[t] && i && r(this.props) && (this.features[t] = new i(this)), this.features[t]) {
        const s = this.features[t];
        s.isMounted ? s.update() : (s.mount(), s.isMounted = !0);
      }
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.props);
  }
  /**
   * Measure the current viewport box with or without transforms.
   * Only measures axis-aligned boxes, rotate and skew must be manually
   * removed with a re-render to work.
   */
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : YV();
  }
  getStaticValue(t) {
    return this.latestValues[t];
  }
  setStaticValue(t, n) {
    this.latestValues[t] = n;
  }
  /**
   * Update the provided props. Ensure any newly-added motion values are
   * added to our map, old ones removed, and listeners updated.
   */
  update(t, n) {
    (t.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = t, this.prevPresenceContext = this.presenceContext, this.presenceContext = n;
    for (let r = 0; r < Tx.length; r++) {
      const i = Tx[r];
      this.propEventSubscriptions[i] && (this.propEventSubscriptions[i](), delete this.propEventSubscriptions[i]);
      const s = "on" + i, l = t[s];
      l && (this.propEventSubscriptions[i] = this.on(i, l));
    }
    this.prevMotionValues = t7(this, this.scrapeMotionValuesFromProps(t, this.prevProps, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue();
  }
  getProps() {
    return this.props;
  }
  /**
   * Returns the variant definition with a given name.
   */
  getVariant(t) {
    return this.props.variants ? this.props.variants[t] : void 0;
  }
  /**
   * Returns the defined default transition on this component.
   */
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
  }
  /**
   * Add a child visual element to our set of children.
   */
  addVariantChild(t) {
    const n = this.getClosestVariantNode();
    if (n)
      return n.variantChildren && n.variantChildren.add(t), () => n.variantChildren.delete(t);
  }
  /**
   * Add a motion value and bind it to this visual element.
   */
  addValue(t, n) {
    const r = this.values.get(t);
    n !== r && (r && this.removeValue(t), this.bindToMotionValue(t, n), this.values.set(t, n), this.latestValues[t] = n.get());
  }
  /**
   * Remove a motion value and unbind any active subscriptions.
   */
  removeValue(t) {
    this.values.delete(t);
    const n = this.valueSubscriptions.get(t);
    n && (n(), this.valueSubscriptions.delete(t)), delete this.latestValues[t], this.removeValueFromRenderState(t, this.renderState);
  }
  /**
   * Check whether we have a motion value for this key
   */
  hasValue(t) {
    return this.values.has(t);
  }
  getValue(t, n) {
    if (this.props.values && this.props.values[t])
      return this.props.values[t];
    let r = this.values.get(t);
    return r === void 0 && n !== void 0 && (r = Wd(n === null ? void 0 : n, { owner: this }), this.addValue(t, r)), r;
  }
  /**
   * If we're trying to animate to a previously unencountered value,
   * we need to check for it in our state and as a last resort read it
   * directly from the instance (which might have performance implications).
   */
  readValue(t, n) {
    let r = this.latestValues[t] !== void 0 || !this.current ? this.latestValues[t] : this.getBaseTargetFromProps(this.props, t) ?? this.readValueFromInstance(this.current, t, this.options);
    return r != null && (typeof r == "string" && (K$(r) || G$(r)) ? r = parseFloat(r) : !mH(r) && sa.test(n) && (r = _V(t, n)), this.setBaseTarget(t, Dt(r) ? r.get() : r)), Dt(r) ? r.get() : r;
  }
  /**
   * Set the base target to later animate back to. This is currently
   * only hydrated on creation and when we first read a value.
   */
  setBaseTarget(t, n) {
    this.baseTarget[t] = n;
  }
  /**
   * Find the base target for a value thats been removed from all animation
   * props.
   */
  getBaseTarget(t) {
    var n;
    const { initial: r } = this.props;
    let i;
    if (typeof r == "string" || typeof r == "object") {
      const l = F0(this.props, r, (n = this.presenceContext) == null ? void 0 : n.custom);
      l && (i = l[t]);
    }
    if (r && i !== void 0)
      return i;
    const s = this.getBaseTargetFromProps(this.props, t);
    return s !== void 0 && !Dt(s) ? s : this.initialValues[t] !== void 0 && i === void 0 ? void 0 : this.baseTarget[t];
  }
  on(t, n) {
    return this.events[t] || (this.events[t] = new q$()), this.events[t].add(n);
  }
  notify(t, ...n) {
    this.events[t] && this.events[t].notify(...n);
  }
  scheduleRenderMicrotask() {
    oH.render(this.render);
  }
}, XV = class extends n7 {
  constructor() {
    super(...arguments), this.KeyframeResolver = eH;
  }
  sortInstanceNodePosition(t, n) {
    return t.compareDocumentPosition(n) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(t, n) {
    return t.style ? t.style[n] : void 0;
  }
  removeValueFromRenderState(t, { vars: n, style: r }) {
    delete n[t], delete r[t];
  }
  handleChildMotionValue() {
    this.childSubscription && (this.childSubscription(), delete this.childSubscription);
    const { children: t } = this.props;
    Dt(t) && (this.childSubscription = t.on("change", (n) => {
      this.current && (this.current.textContent = `${n}`);
    }));
  }
};
function ZV(e, { style: t, vars: n }, r, i) {
  const s = e.style;
  let l;
  for (l in t)
    s[l] = t[l];
  i == null || i.applyProjectionStyles(s, r);
  for (l in n)
    s.setProperty(l, n[l]);
}
function r7(e) {
  return window.getComputedStyle(e);
}
let i7 = class extends XV {
  constructor() {
    super(...arguments), this.type = "html", this.renderInstance = ZV;
  }
  readValueFromInstance(t, n) {
    var r;
    if (la.has(n))
      return (r = this.projection) != null && r.isProjecting ? jg(n) : w8(t, n);
    {
      const i = r7(t), s = (lV(n) ? i.getPropertyValue(n) : i[n]) || 0;
      return typeof s == "string" ? s.trim() : s;
    }
  }
  measureInstanceViewportBox(t, { transformPagePoint: n }) {
    return QH(t, n);
  }
  build(t, n, r) {
    N0(t, n, r.transformTemplate);
  }
  scrapeMotionValuesFromProps(t, n, r) {
    return U0(t, n, r);
  }
};
const QV = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust"
]);
function o7(e, t, n, r) {
  ZV(e, t, void 0, r);
  for (const i in t.attrs)
    e.setAttribute(QV.has(i) ? i : W0(i), t.attrs[i]);
}
let s7 = class extends XV {
  constructor() {
    super(...arguments), this.type = "svg", this.isSVGTag = !1, this.measureInstanceViewportBox = YV;
  }
  getBaseTargetFromProps(t, n) {
    return t[n];
  }
  readValueFromInstance(t, n) {
    if (la.has(n)) {
      const r = VV(n);
      return r && r.default || 0;
    }
    return n = QV.has(n) ? n : W0(n), t.getAttribute(n);
  }
  scrapeMotionValuesFromProps(t, n, r) {
    return zV(t, n, r);
  }
  build(t, n, r) {
    jV(t, n, this.isSVGTag, r.transformTemplate, r.style);
  }
  renderInstance(t, n, r, i) {
    o7(t, n, r, i);
  }
  mount(t) {
    this.isSVGTag = UV(t.tagName), super.mount(t);
  }
};
const a7 = (e, t) => j0(e) ? new s7(t) : new i7(t, {
  allowProjection: e !== C.Fragment
});
function ws(e, t, n) {
  const r = e.getProps();
  return F0(r, t, n !== void 0 ? n : r.custom, e);
}
const Yg = (e) => Array.isArray(e);
function l7(e, t, n) {
  e.hasValue(t) ? e.getValue(t).set(n) : e.addValue(t, Wd(n));
}
function u7(e) {
  return Yg(e) ? e[e.length - 1] || 0 : e;
}
function c7(e, t) {
  const n = ws(e, t);
  let { transitionEnd: r = {}, transition: i = {}, ...s } = n || {};
  s = { ...s, ...r };
  for (const l in s) {
    const u = u7(s[l]);
    l7(e, l, u);
  }
}
function d7(e) {
  return !!(Dt(e) && e.add);
}
function f7(e, t) {
  const n = e.getValue("willChange");
  if (d7(n))
    return n.add(t);
  if (!n && Dr.WillChange) {
    const r = new Dr.WillChange("auto");
    e.addValue("willChange", r), r.add(t);
  }
}
function h7(e) {
  return e.props[KV];
}
const p7 = (e) => e !== null;
function m7(e, { repeat: t, repeatType: n = "loop" }, r) {
  const i = e.filter(p7), s = t && n !== "loop" && t % 2 === 1 ? 0 : i.length - 1;
  return i[s];
}
const g7 = {
  type: "spring",
  stiffness: 500,
  damping: 25,
  restSpeed: 10
}, v7 = (e) => ({
  type: "spring",
  stiffness: 550,
  damping: e === 0 ? 2 * Math.sqrt(550) : 30,
  restSpeed: 10
}), y7 = {
  type: "keyframes",
  duration: 0.8
}, w7 = {
  type: "keyframes",
  ease: [0.25, 0.1, 0.35, 1],
  duration: 0.3
}, b7 = (e, { keyframes: t }) => t.length > 2 ? y7 : la.has(e) ? e.startsWith("scale") ? v7(t[1]) : g7 : w7;
function C7({ when: e, delay: t, delayChildren: n, staggerChildren: r, staggerDirection: i, repeat: s, repeatType: l, repeatDelay: u, from: d, elapsed: h, ...f }) {
  return !!Object.keys(f).length;
}
const E7 = (e, t, n, r = {}, i, s) => (l) => {
  const u = kV(r, e) || {}, d = u.delay || r.delay || 0;
  let { elapsed: h = 0 } = r;
  h = h - /* @__PURE__ */ Rr(d);
  const f = {
    keyframes: Array.isArray(n) ? n : [null, n],
    ease: "easeOut",
    velocity: t.getVelocity(),
    ...u,
    delay: -h,
    onUpdate: (g) => {
      t.set(g), u.onUpdate && u.onUpdate(g);
    },
    onComplete: () => {
      l(), u.onComplete && u.onComplete();
    },
    name: e,
    motionValue: t,
    element: s ? void 0 : i
  };
  C7(u) || Object.assign(f, b7(e, f)), f.duration && (f.duration = /* @__PURE__ */ Rr(f.duration)), f.repeatDelay && (f.repeatDelay = /* @__PURE__ */ Rr(f.repeatDelay)), f.from !== void 0 && (f.keyframes[0] = f.from);
  let m = !1;
  if ((f.type === !1 || f.duration === 0 && !f.repeatDelay) && (Hg(f), f.delay === 0 && (m = !0)), (Dr.instantAnimations || Dr.skipAnimations) && (m = !0, Hg(f), f.delay = 0), f.allowFlatten = !u.type && !u.ease, m && !s && t.get() !== void 0) {
    const g = m7(f.keyframes, u);
    if (g !== void 0) {
      Hn.update(() => {
        f.onUpdate(g), f.onComplete();
      });
      return;
    }
  }
  return u.isSync ? new _0(f) : new U8(f);
};
function A7({ protectedKeys: e, needsAnimating: t }, n) {
  const r = e.hasOwnProperty(n) && t[n] !== !0;
  return t[n] = !1, r;
}
function JV(e, t, { delay: n = 0, transitionOverride: r, type: i } = {}) {
  let { transition: s = e.getDefaultTransition(), transitionEnd: l, ...u } = t;
  r && (s = r);
  const d = [], h = i && e.animationState && e.animationState.getState()[i];
  for (const f in u) {
    const m = e.getValue(f, e.latestValues[f] ?? null), g = u[f];
    if (g === void 0 || h && A7(h, f))
      continue;
    const w = {
      delay: n,
      ...kV(s || {}, f)
    }, E = m.get();
    if (E !== void 0 && !m.isAnimating && !Array.isArray(g) && g === E && !w.velocity)
      continue;
    let b = !1;
    if (window.MotionHandoffAnimation) {
      const x = h7(e);
      if (x) {
        const R = window.MotionHandoffAnimation(x, f, Hn);
        R !== null && (w.startTime = R, b = !0);
      }
    }
    f7(e, f), m.start(E7(f, m, g, e.shouldReduceMotion && RV.has(f) ? { type: !1 } : w, e, b));
    const A = m.animation;
    A && d.push(A);
  }
  return l && Promise.all(d).then(() => {
    Hn.update(() => {
      l && c7(e, l);
    });
  }), d;
}
function e_(e, t, n, r = 0, i = 1) {
  const s = Array.from(e).sort((d, h) => d.sortNodePosition(h)).indexOf(t), l = e.size, u = (l - 1) * r;
  return typeof n == "function" ? n(s, l) : i === 1 ? s * r : u - s * r;
}
function qg(e, t, n = {}) {
  var r;
  const i = ws(e, t, n.type === "exit" ? (r = e.presenceContext) == null ? void 0 : r.custom : void 0);
  let { transition: s = e.getDefaultTransition() || {} } = i || {};
  n.transitionOverride && (s = n.transitionOverride);
  const l = i ? () => Promise.all(JV(e, i, n)) : () => Promise.resolve(), u = e.variantChildren && e.variantChildren.size ? (h = 0) => {
    const { delayChildren: f = 0, staggerChildren: m, staggerDirection: g } = s;
    return x7(e, t, h, f, m, g, n);
  } : () => Promise.resolve(), { when: d } = s;
  if (d) {
    const [h, f] = d === "beforeChildren" ? [l, u] : [u, l];
    return h().then(() => f());
  } else
    return Promise.all([l(), u(n.delay)]);
}
function x7(e, t, n = 0, r = 0, i = 0, s = 1, l) {
  const u = [];
  for (const d of e.variantChildren)
    d.notify("AnimationStart", t), u.push(qg(d, t, {
      ...l,
      delay: n + (typeof r == "function" ? 0 : r) + e_(e.variantChildren, d, r, i, s)
    }).then(() => d.notify("AnimationComplete", t)));
  return Promise.all(u);
}
function S7(e, t, n = {}) {
  e.notify("AnimationStart", t);
  let r;
  if (Array.isArray(t)) {
    const i = t.map((s) => qg(e, s, n));
    r = Promise.all(i);
  } else if (typeof t == "string")
    r = qg(e, t, n);
  else {
    const i = typeof t == "function" ? ws(e, t, n.custom) : t;
    r = Promise.all(JV(e, i, n));
  }
  return r.then(() => {
    e.notify("AnimationComplete", t);
  });
}
function t_(e, t) {
  if (!Array.isArray(t))
    return !1;
  const n = t.length;
  if (n !== e.length)
    return !1;
  for (let r = 0; r < n; r++)
    if (t[r] !== e[r])
      return !1;
  return !0;
}
const k7 = B0.length;
function n_(e) {
  if (!e)
    return;
  if (!e.isControllingVariants) {
    const n = e.parent ? n_(e.parent) || {} : {};
    return e.props.initial !== void 0 && (n.initial = e.props.initial), n;
  }
  const t = {};
  for (let n = 0; n < k7; n++) {
    const r = B0[n], i = e.props[r];
    (Yl(i) || i === !1) && (t[r] = i);
  }
  return t;
}
const R7 = [...O0].reverse(), T7 = O0.length;
function $7(e) {
  return (t) => Promise.all(t.map(({ animation: n, options: r }) => S7(e, n, r)));
}
function V7(e) {
  let t = $7(e), n = $x(), r = !0;
  const i = (d) => (h, f) => {
    var m;
    const g = ws(e, f, d === "exit" ? (m = e.presenceContext) == null ? void 0 : m.custom : void 0);
    if (g) {
      const { transition: w, transitionEnd: E, ...b } = g;
      h = { ...h, ...b, ...E };
    }
    return h;
  };
  function s(d) {
    t = d(e);
  }
  function l(d) {
    const { props: h } = e, f = n_(e.parent) || {}, m = [], g = /* @__PURE__ */ new Set();
    let w = {}, E = 1 / 0;
    for (let A = 0; A < T7; A++) {
      const x = R7[A], R = n[x], _ = h[x] !== void 0 ? h[x] : f[x], L = Yl(_), V = x === d ? R.isActive : null;
      V === !1 && (E = A);
      let O = _ === f[x] && _ !== h[x] && L;
      if (O && r && e.manuallyAnimateOnMount && (O = !1), R.protectedKeys = { ...w }, // If it isn't active and hasn't *just* been set as inactive
      !R.isActive && V === null || // If we didn't and don't have any defined prop for this animation type
      !_ && !R.prevProp || // Or if the prop doesn't define an animation
      _f(_) || typeof _ == "boolean")
        continue;
      const D = _7(R.prevProp, _);
      let B = D || // If we're making this variant active, we want to always make it active
      x === d && R.isActive && !O && L || // If we removed a higher-priority variant (i is in reverse order)
      A > E && L, H = !1;
      const J = Array.isArray(_) ? _ : [_];
      let ce = J.reduce(i(x), {});
      V === !1 && (ce = {});
      const { prevResolvedValues: fe = {} } = R, de = {
        ...fe,
        ...ce
      }, he = (Y) => {
        B = !0, g.has(Y) && (H = !0, g.delete(Y)), R.needsAnimating[Y] = !0;
        const te = e.getValue(Y);
        te && (te.liveStyle = !1);
      };
      for (const Y in de) {
        const te = ce[Y], S = fe[Y];
        if (w.hasOwnProperty(Y))
          continue;
        let T = !1;
        Yg(te) && Yg(S) ? T = !t_(te, S) : T = te !== S, T ? te != null ? he(Y) : g.add(Y) : te !== void 0 && g.has(Y) ? he(Y) : R.protectedKeys[Y] = !0;
      }
      R.prevProp = _, R.prevResolvedValues = ce, R.isActive && (w = { ...w, ...ce }), r && e.blockInitialAnimation && (B = !1);
      const le = O && D;
      B && (!le || H) && m.push(...J.map((Y) => {
        const te = { type: x };
        if (typeof Y == "string" && r && !le && e.manuallyAnimateOnMount && e.parent) {
          const { parent: S } = e, T = ws(S, Y);
          if (S.enteringChildren && T) {
            const { delayChildren: P } = T.transition || {};
            te.delay = e_(S.enteringChildren, e, P);
          }
        }
        return {
          animation: Y,
          options: te
        };
      }));
    }
    if (g.size) {
      const A = {};
      if (typeof h.initial != "boolean") {
        const x = ws(e, Array.isArray(h.initial) ? h.initial[0] : h.initial);
        x && x.transition && (A.transition = x.transition);
      }
      g.forEach((x) => {
        const R = e.getBaseTarget(x), _ = e.getValue(x);
        _ && (_.liveStyle = !0), A[x] = R ?? null;
      }), m.push({ animation: A });
    }
    let b = !!m.length;
    return r && (h.initial === !1 || h.initial === h.animate) && !e.manuallyAnimateOnMount && (b = !1), r = !1, b ? t(m) : Promise.resolve();
  }
  function u(d, h) {
    var f;
    if (n[d].isActive === h)
      return Promise.resolve();
    (f = e.variantChildren) == null || f.forEach((g) => {
      var w;
      return (w = g.animationState) == null ? void 0 : w.setActive(d, h);
    }), n[d].isActive = h;
    const m = l(d);
    for (const g in n)
      n[g].protectedKeys = {};
    return m;
  }
  return {
    animateChanges: l,
    setActive: u,
    setAnimateFunction: s,
    getState: () => n,
    reset: () => {
      n = $x(), r = !0;
    }
  };
}
function _7(e, t) {
  return typeof t == "string" ? t !== e : Array.isArray(t) ? !t_(t, e) : !1;
}
function ji(e = !1) {
  return {
    isActive: e,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function $x() {
  return {
    animate: ji(!0),
    whileInView: ji(),
    whileHover: ji(),
    whileTap: ji(),
    whileDrag: ji(),
    whileFocus: ji(),
    exit: ji()
  };
}
let ua = class {
  constructor(t) {
    this.isMounted = !1, this.node = t;
  }
  update() {
  }
}, I7 = class extends ua {
  /**
   * We dynamically generate the AnimationState manager as it contains a reference
   * to the underlying animation library. We only want to load that if we load this,
   * so people can optionally code split it out using the `m` component.
   */
  constructor(t) {
    super(t), t.animationState || (t.animationState = V7(t));
  }
  updateAnimationControlsSubscription() {
    const { animate: t } = this.node.getProps();
    _f(t) && (this.unmountControls = t.subscribe(this.node));
  }
  /**
   * Subscribe any provided AnimationControls to the component's VisualElement
   */
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate: t } = this.node.getProps(), { animate: n } = this.node.prevProps || {};
    t !== n && this.updateAnimationControlsSubscription();
  }
  unmount() {
    var t;
    this.node.animationState.reset(), (t = this.unmountControls) == null || t.call(this);
  }
}, L7 = 0, P7 = class extends ua {
  constructor() {
    super(...arguments), this.id = L7++;
  }
  update() {
    if (!this.node.presenceContext)
      return;
    const { isPresent: t, onExitComplete: n } = this.node.presenceContext, { isPresent: r } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || t === r)
      return;
    const i = this.node.animationState.setActive("exit", !t);
    n && !t && i.then(() => {
      n(this.id);
    });
  }
  mount() {
    const { register: t, onExitComplete: n } = this.node.presenceContext || {};
    n && n(this.id), t && (this.unmount = t(this.id));
  }
  unmount() {
  }
};
const M7 = {
  animation: {
    Feature: I7
  },
  exit: {
    Feature: P7
  }
};
function Vx(e, t, n, r = { passive: !0 }) {
  return e.addEventListener(t, n, r), () => e.removeEventListener(t, n);
}
function r_(e) {
  return {
    point: {
      x: e.pageX,
      y: e.pageY
    }
  };
}
function _x(e, t, n) {
  const { props: r } = e;
  e.animationState && r.whileHover && e.animationState.setActive("whileHover", n === "Start");
  const i = "onHover" + n, s = r[i];
  s && Hn.postRender(() => s(t, r_(t)));
}
let O7 = class extends ua {
  mount() {
    const { current: t } = this.node;
    t && (this.unmount = lH(t, (n, r) => (_x(this.node, r, "Start"), (i) => _x(this.node, i, "End"))));
  }
  unmount() {
  }
}, B7 = class extends ua {
  constructor() {
    super(...arguments), this.isActive = !1;
  }
  onFocus() {
    let t = !1;
    try {
      t = this.node.current.matches(":focus-visible");
    } catch {
      t = !0;
    }
    !t || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0);
  }
  onBlur() {
    !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1);
  }
  mount() {
    this.unmount = Tf(Vx(this.node.current, "focus", () => this.onFocus()), Vx(this.node.current, "blur", () => this.onBlur()));
  }
  unmount() {
  }
};
function Ix(e, t, n) {
  const { props: r } = e;
  if (e.current instanceof HTMLButtonElement && e.current.disabled)
    return;
  e.animationState && r.whileTap && e.animationState.setActive("whileTap", n === "Start");
  const i = "onTap" + (n === "End" ? "" : n), s = r[i];
  s && Hn.postRender(() => s(t, r_(t)));
}
let N7 = class extends ua {
  mount() {
    const { current: t } = this.node;
    t && (this.unmount = hH(t, (n, r) => (Ix(this.node, r, "Start"), (i, { success: s }) => Ix(this.node, i, s ? "End" : "Cancel")), { useGlobalTarget: this.node.props.globalTapTarget }));
  }
  unmount() {
  }
};
const Xg = /* @__PURE__ */ new WeakMap(), Am = /* @__PURE__ */ new WeakMap(), D7 = (e) => {
  const t = Xg.get(e.target);
  t && t(e);
}, j7 = (e) => {
  e.forEach(D7);
};
function F7({ root: e, ...t }) {
  const n = e || document;
  Am.has(n) || Am.set(n, {});
  const r = Am.get(n), i = JSON.stringify(t);
  return r[i] || (r[i] = new IntersectionObserver(j7, { root: e, ...t })), r[i];
}
function U7(e, t, n) {
  const r = F7(t);
  return Xg.set(e, n), r.observe(e), () => {
    Xg.delete(e), r.unobserve(e);
  };
}
const W7 = {
  some: 0,
  all: 1
};
let z7 = class extends ua {
  constructor() {
    super(...arguments), this.hasEnteredView = !1, this.isInView = !1;
  }
  startObserver() {
    this.unmount();
    const { viewport: t = {} } = this.node.getProps(), { root: n, margin: r, amount: i = "some", once: s } = t, l = {
      root: n ? n.current : void 0,
      rootMargin: r,
      threshold: typeof i == "number" ? i : W7[i]
    }, u = (d) => {
      const { isIntersecting: h } = d;
      if (this.isInView === h || (this.isInView = h, s && !h && this.hasEnteredView))
        return;
      h && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", h);
      const { onViewportEnter: f, onViewportLeave: m } = this.node.getProps(), g = h ? f : m;
      g && g(d);
    };
    return U7(this.node.current, l, u);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver > "u")
      return;
    const { props: t, prevProps: n } = this.node;
    ["amount", "margin", "root"].some(H7(t, n)) && this.startObserver();
  }
  unmount() {
  }
};
function H7({ viewport: e = {} }, { viewport: t = {} } = {}) {
  return (n) => e[n] !== t[n];
}
const K7 = {
  inView: {
    Feature: z7
  },
  tap: {
    Feature: N7
  },
  focus: {
    Feature: B7
  },
  hover: {
    Feature: O7
  }
}, G7 = {
  renderer: a7,
  ...M7,
  ...K7
};
function Y7(e, t) {
  return KH(e, t);
}
const Lx = /* @__PURE__ */ Y7("span"), q7 = {
  Root: {
    0: {
      h: "5"
    },
    1: {
      h: "6"
    },
    2: {
      h: "8"
    }
  }
}, i_ = {
  Root: {
    0: "1",
    1: "1_5",
    2: "2"
  },
  Text: {
    0: "1",
    1: "1_5",
    2: "2"
  }
}, wu = {
  Root: {
    solid: {
      default: "gray-12",
      accent: "accent-9",
      gray: "gray-9",
      red: "red-9",
      blue: "blue-9",
      green: "green-9",
      yellow: "yellow-9",
      purple: "purple-9"
    },
    soft: {
      default: "gray-3",
      accent: "accent-3",
      gray: "gray-3",
      red: "red-3",
      blue: "blue-3",
      green: "green-3",
      yellow: "yellow-3",
      purple: "purple-3"
    }
  },
  Icon: {
    solid: {
      default: "white",
      gray: "white",
      red: "white",
      accent: "white",
      blue: "white",
      green: "white",
      yellow: "white",
      purple: "white"
    },
    soft: {
      default: "default",
      gray: "gray",
      accent: "accent",
      red: "red",
      blue: "blue",
      green: "green",
      yellow: "yellow",
      purple: "purple"
    }
  },
  Text: {
    solid: {
      default: "white",
      gray: "white",
      accent: "white",
      red: "white",
      blue: "white",
      green: "white",
      yellow: "white",
      purple: "white"
    },
    soft: {
      default: "default",
      gray: "gray",
      accent: "accent",
      red: "red",
      blue: "blue",
      green: "green",
      yellow: "yellow",
      purple: "purple"
    }
  },
  Button: {
    solid: {
      default: "default",
      gray: "gray",
      accent: "accent",
      red: "red",
      blue: "blue",
      green: "green",
      yellow: "yellow",
      purple: "purple"
    },
    soft: {
      default: "gray",
      gray: "gray",
      accent: "accent",
      red: "red",
      blue: "blue",
      green: "green",
      yellow: "yellow",
      purple: "purple"
    }
  }
}, bu = j.createContext({
  size: "1",
  color: "default",
  variant: "soft"
}), o_ = ({
  as: e = "span",
  size: t = "1",
  color: n = "default",
  variant: r = "soft",
  className: i,
  ...s
}) => /* @__PURE__ */ I.jsx(bu.Provider, { value: { size: t, color: n, variant: r }, children: /* @__PURE__ */ I.jsx(
  KF,
  {
    as: e,
    align: "center",
    rounded: "1",
    display: "inline-flex",
    pl: i_.Root[t],
    backgroundColor: wu.Root[r][n],
    h: q7.Root[t].h,
    className: Se("tgph-tag", i),
    ...s,
    "data-tag": !0
  }
) }), s_ = ({
  as: e = "span",
  maxW: t = "40",
  overflow: n = "hidden",
  style: r,
  ...i
}) => {
  const s = j.useContext(bu);
  return /* @__PURE__ */ I.jsx(
    qn,
    {
      as: e,
      size: s.size,
      color: wu.Text[s.variant][s.color],
      weight: "medium",
      mr: i_.Text[s.size],
      maxW: t,
      overflow: n,
      internal_optionalAs: !0,
      style: {
        whiteSpace: "nowrap",
        textOverflow: "ellipsis",
        ...r
      },
      ...i
    }
  );
}, a_ = ({ onClick: e, textToCopy: t, ...n }) => {
  const r = j.useContext(bu), [i, s] = j.useState(!1);
  return j.useEffect(() => {
    if (i) {
      const l = setTimeout(() => s(!1), 2e3);
      return () => clearTimeout(l);
    }
  }, [i]), /* @__PURE__ */ I.jsx(gH, { features: G7, children: /* @__PURE__ */ I.jsx(y0, { label: "Copy text", children: /* @__PURE__ */ I.jsxs(
    Ut.Root,
    {
      onClick: (l) => {
        var u;
        e == null || e(l), s(!0), t && navigator.clipboard.writeText(t), (u = l.currentTarget) == null || u.blur();
      },
      size: r.size,
      color: wu.Button[r.variant][r.color],
      variant: r.variant,
      roundedTopRight: "1",
      roundedBottomRight: "1",
      roundedTopLeft: "0",
      roundedBottomLeft: "0",
      position: "relative",
      overflow: "hidden",
      p: "2",
      ...n,
      children: [
        /* @__PURE__ */ I.jsx(
          Ut.Icon,
          {
            as: Lx,
            initial: !1,
            animate: { y: i ? 0 : "150%", opacity: 1 },
            transition: { duration: 0.15, type: "spring", bounce: 0 },
            icon: PF,
            alt: "Copied text",
            "aria-hidden": !i
          }
        ),
        /* @__PURE__ */ I.jsx(
          Ut.Icon,
          {
            as: Lx,
            initial: !1,
            animate: { y: i ? "-150%" : 0, opacity: 1 },
            transition: { duration: 0.15, type: "spring", bounce: 0 },
            icon: OF,
            position: "absolute",
            alt: "Copy text",
            "aria-hidden": i
          }
        )
      ]
    }
  ) }) });
}, l_ = ({ ...e }) => {
  const t = j.useContext(bu);
  return /* @__PURE__ */ I.jsx(
    Ut,
    {
      size: t.size,
      color: wu.Button[t.variant][t.color],
      variant: t.variant,
      icon: { icon: HR, alt: "close" },
      roundedTopRight: "1",
      roundedBottomRight: "1",
      roundedTopLeft: "0",
      roundedBottomLeft: "0",
      ...e
    }
  );
}, u_ = ({
  icon: e,
  alt: t,
  "aria-hidden": n,
  ...r
}) => {
  const i = j.useContext(bu), s = t ? { alt: t } : { "aria-hidden": n };
  return /* @__PURE__ */ I.jsx(
    DF,
    {
      icon: e,
      size: i.size,
      color: wu.Icon[i.variant][i.color],
      mr: "1",
      ...s,
      ...r
    }
  );
}, c_ = ({
  color: e = "default",
  size: t = "1",
  variant: n = "soft",
  icon: r,
  onRemove: i,
  onCopy: s,
  textToCopy: l,
  textProps: u = { maxW: "40" },
  children: d,
  ...h
}) => /* @__PURE__ */ I.jsxs(o_, { color: e, size: t, variant: n, ...h, children: [
  r && /* @__PURE__ */ I.jsx(u_, { ...r }),
  /* @__PURE__ */ I.jsx(s_, { as: "span", ...u, children: d }),
  i && /* @__PURE__ */ I.jsx(l_, { onClick: i, icon: { icon: HR, alt: "Remove" } }),
  s && /* @__PURE__ */ I.jsx(a_, { onClick: s, textToCopy: l })
] });
Object.assign(c_, {
  Root: o_,
  Button: l_,
  Text: s_,
  Icon: u_,
  CopyButton: a_
});
const z0 = c_;
var xm = "focusScope.autoFocusOnMount", Sm = "focusScope.autoFocusOnUnmount", Px = { bubbles: !1, cancelable: !0 }, X7 = "FocusScope", H0 = C.forwardRef((e, t) => {
  const {
    loop: n = !1,
    trapped: r = !1,
    onMountAutoFocus: i,
    onUnmountAutoFocus: s,
    ...l
  } = e, [u, d] = C.useState(null), h = Mr(i), f = Mr(s), m = C.useRef(null), g = wt(t, (b) => d(b)), w = C.useRef({
    paused: !1,
    pause() {
      this.paused = !0;
    },
    resume() {
      this.paused = !1;
    }
  }).current;
  C.useEffect(() => {
    if (r) {
      let b = function(_) {
        if (w.paused || !u) return;
        const L = _.target;
        u.contains(L) ? m.current = L : pi(m.current, { select: !0 });
      }, A = function(_) {
        if (w.paused || !u) return;
        const L = _.relatedTarget;
        L !== null && (u.contains(L) || pi(m.current, { select: !0 }));
      }, x = function(_) {
        if (document.activeElement === document.body)
          for (const V of _)
            V.removedNodes.length > 0 && pi(u);
      };
      document.addEventListener("focusin", b), document.addEventListener("focusout", A);
      const R = new MutationObserver(x);
      return u && R.observe(u, { childList: !0, subtree: !0 }), () => {
        document.removeEventListener("focusin", b), document.removeEventListener("focusout", A), R.disconnect();
      };
    }
  }, [r, u, w.paused]), C.useEffect(() => {
    if (u) {
      Ox.add(w);
      const b = document.activeElement;
      if (!u.contains(b)) {
        const x = new CustomEvent(xm, Px);
        u.addEventListener(xm, h), u.dispatchEvent(x), x.defaultPrevented || (Z7(nK(d_(u)), { select: !0 }), document.activeElement === b && pi(u));
      }
      return () => {
        u.removeEventListener(xm, h), setTimeout(() => {
          const x = new CustomEvent(Sm, Px);
          u.addEventListener(Sm, f), u.dispatchEvent(x), x.defaultPrevented || pi(b ?? document.body, { select: !0 }), u.removeEventListener(Sm, f), Ox.remove(w);
        }, 0);
      };
    }
  }, [u, h, f, w]);
  const E = C.useCallback(
    (b) => {
      if (!n && !r || w.paused) return;
      const A = b.key === "Tab" && !b.altKey && !b.ctrlKey && !b.metaKey, x = document.activeElement;
      if (A && x) {
        const R = b.currentTarget, [_, L] = Q7(R);
        _ && L ? !b.shiftKey && x === L ? (b.preventDefault(), n && pi(_, { select: !0 })) : b.shiftKey && x === _ && (b.preventDefault(), n && pi(L, { select: !0 })) : x === R && b.preventDefault();
      }
    },
    [n, r, w.paused]
  );
  return /* @__PURE__ */ I.jsx(ut.div, { tabIndex: -1, ...l, ref: g, onKeyDown: E });
});
H0.displayName = X7;
function Z7(e, { select: t = !1 } = {}) {
  const n = document.activeElement;
  for (const r of e)
    if (pi(r, { select: t }), document.activeElement !== n) return;
}
function Q7(e) {
  const t = d_(e), n = Mx(t, e), r = Mx(t.reverse(), e);
  return [n, r];
}
function d_(e) {
  const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (r) => {
      const i = r.tagName === "INPUT" && r.type === "hidden";
      return r.disabled || r.hidden || i ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; n.nextNode(); ) t.push(n.currentNode);
  return t;
}
function Mx(e, t) {
  for (const n of e)
    if (!J7(n, { upTo: t })) return n;
}
function J7(e, { upTo: t }) {
  if (getComputedStyle(e).visibility === "hidden") return !0;
  for (; e; ) {
    if (t !== void 0 && e === t) return !1;
    if (getComputedStyle(e).display === "none") return !0;
    e = e.parentElement;
  }
  return !1;
}
function eK(e) {
  return e instanceof HTMLInputElement && "select" in e;
}
function pi(e, { select: t = !1 } = {}) {
  if (e && e.focus) {
    const n = document.activeElement;
    e.focus({ preventScroll: !0 }), e !== n && eK(e) && t && e.select();
  }
}
var Ox = tK();
function tK() {
  let e = [];
  return {
    add(t) {
      const n = e[0];
      t !== n && (n == null || n.pause()), e = Bx(e, t), e.unshift(t);
    },
    remove(t) {
      var n;
      e = Bx(e, t), (n = e[0]) == null || n.resume();
    }
  };
}
function Bx(e, t) {
  const n = [...e], r = n.indexOf(t);
  return r !== -1 && n.splice(r, 1), n;
}
function nK(e) {
  return e.filter((t) => t.tagName !== "A");
}
var km = 0;
function f_() {
  C.useEffect(() => {
    const e = document.querySelectorAll("[data-radix-focus-guard]");
    return document.body.insertAdjacentElement("afterbegin", e[0] ?? Nx()), document.body.insertAdjacentElement("beforeend", e[1] ?? Nx()), km++, () => {
      km === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach((t) => t.remove()), km--;
    };
  }, []);
}
function Nx() {
  const e = document.createElement("span");
  return e.setAttribute("data-radix-focus-guard", ""), e.tabIndex = 0, e.style.outline = "none", e.style.opacity = "0", e.style.position = "fixed", e.style.pointerEvents = "none", e;
}
var lr = function() {
  return lr = Object.assign || function(t) {
    for (var n, r = 1, i = arguments.length; r < i; r++) {
      n = arguments[r];
      for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (t[s] = n[s]);
    }
    return t;
  }, lr.apply(this, arguments);
};
function h_(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
}
function rK(e, t, n) {
  if (n || arguments.length === 2) for (var r = 0, i = t.length, s; r < i; r++)
    (s || !(r in t)) && (s || (s = Array.prototype.slice.call(t, 0, r)), s[r] = t[r]);
  return e.concat(s || Array.prototype.slice.call(t));
}
var wd = "right-scroll-bar-position", bd = "width-before-scroll-bar", iK = "with-scroll-bars-hidden", oK = "--removed-body-scroll-bar-size";
function Rm(e, t) {
  return typeof e == "function" ? e(t) : e && (e.current = t), e;
}
function sK(e, t) {
  var n = C.useState(function() {
    return {
      // value
      value: e,
      // last callback
      callback: t,
      // "memoized" public interface
      facade: {
        get current() {
          return n.value;
        },
        set current(r) {
          var i = n.value;
          i !== r && (n.value = r, n.callback(r, i));
        }
      }
    };
  })[0];
  return n.callback = t, n.facade;
}
var aK = typeof window < "u" ? C.useLayoutEffect : C.useEffect, Dx = /* @__PURE__ */ new WeakMap();
function lK(e, t) {
  var n = sK(null, function(r) {
    return e.forEach(function(i) {
      return Rm(i, r);
    });
  });
  return aK(function() {
    var r = Dx.get(n);
    if (r) {
      var i = new Set(r), s = new Set(e), l = n.current;
      i.forEach(function(u) {
        s.has(u) || Rm(u, null);
      }), s.forEach(function(u) {
        i.has(u) || Rm(u, l);
      });
    }
    Dx.set(n, e);
  }, [e]), n;
}
function uK(e) {
  return e;
}
function cK(e, t) {
  t === void 0 && (t = uK);
  var n = [], r = !1, i = {
    read: function() {
      if (r)
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      return n.length ? n[n.length - 1] : e;
    },
    useMedium: function(s) {
      var l = t(s, r);
      return n.push(l), function() {
        n = n.filter(function(u) {
          return u !== l;
        });
      };
    },
    assignSyncMedium: function(s) {
      for (r = !0; n.length; ) {
        var l = n;
        n = [], l.forEach(s);
      }
      n = {
        push: function(u) {
          return s(u);
        },
        filter: function() {
          return n;
        }
      };
    },
    assignMedium: function(s) {
      r = !0;
      var l = [];
      if (n.length) {
        var u = n;
        n = [], u.forEach(s), l = n;
      }
      var d = function() {
        var f = l;
        l = [], f.forEach(s);
      }, h = function() {
        return Promise.resolve().then(d);
      };
      h(), n = {
        push: function(f) {
          l.push(f), h();
        },
        filter: function(f) {
          return l = l.filter(f), n;
        }
      };
    }
  };
  return i;
}
function dK(e) {
  e === void 0 && (e = {});
  var t = cK(null);
  return t.options = lr({ async: !0, ssr: !1 }, e), t;
}
var p_ = function(e) {
  var t = e.sideCar, n = h_(e, ["sideCar"]);
  if (!t)
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  var r = t.read();
  if (!r)
    throw new Error("Sidecar medium not found");
  return C.createElement(r, lr({}, n));
};
p_.isSideCarExport = !0;
function fK(e, t) {
  return e.useMedium(t), p_;
}
var m_ = dK(), Tm = function() {
}, Lf = C.forwardRef(function(e, t) {
  var n = C.useRef(null), r = C.useState({
    onScrollCapture: Tm,
    onWheelCapture: Tm,
    onTouchMoveCapture: Tm
  }), i = r[0], s = r[1], l = e.forwardProps, u = e.children, d = e.className, h = e.removeScrollBar, f = e.enabled, m = e.shards, g = e.sideCar, w = e.noRelative, E = e.noIsolation, b = e.inert, A = e.allowPinchZoom, x = e.as, R = x === void 0 ? "div" : x, _ = e.gapMode, L = h_(e, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noRelative", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), V = g, O = lK([n, t]), D = lr(lr({}, L), i);
  return C.createElement(
    C.Fragment,
    null,
    f && C.createElement(V, { sideCar: m_, removeScrollBar: h, shards: m, noRelative: w, noIsolation: E, inert: b, setCallbacks: s, allowPinchZoom: !!A, lockRef: n, gapMode: _ }),
    l ? C.cloneElement(C.Children.only(u), lr(lr({}, D), { ref: O })) : C.createElement(R, lr({}, D, { className: d, ref: O }), u)
  );
});
Lf.defaultProps = {
  enabled: !0,
  removeScrollBar: !0,
  inert: !1
};
Lf.classNames = {
  fullWidth: bd,
  zeroRight: wd
};
var hK = function() {
  if (typeof __webpack_nonce__ < "u")
    return __webpack_nonce__;
};
function pK() {
  if (!document)
    return null;
  var e = document.createElement("style");
  e.type = "text/css";
  var t = hK();
  return t && e.setAttribute("nonce", t), e;
}
function mK(e, t) {
  e.styleSheet ? e.styleSheet.cssText = t : e.appendChild(document.createTextNode(t));
}
function gK(e) {
  var t = document.head || document.getElementsByTagName("head")[0];
  t.appendChild(e);
}
var vK = function() {
  var e = 0, t = null;
  return {
    add: function(n) {
      e == 0 && (t = pK()) && (mK(t, n), gK(t)), e++;
    },
    remove: function() {
      e--, !e && t && (t.parentNode && t.parentNode.removeChild(t), t = null);
    }
  };
}, yK = function() {
  var e = vK();
  return function(t, n) {
    C.useEffect(function() {
      return e.add(t), function() {
        e.remove();
      };
    }, [t && n]);
  };
}, g_ = function() {
  var e = yK(), t = function(n) {
    var r = n.styles, i = n.dynamic;
    return e(r, i), null;
  };
  return t;
}, wK = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
}, $m = function(e) {
  return parseInt(e || "", 10) || 0;
}, bK = function(e) {
  var t = window.getComputedStyle(document.body), n = t[e === "padding" ? "paddingLeft" : "marginLeft"], r = t[e === "padding" ? "paddingTop" : "marginTop"], i = t[e === "padding" ? "paddingRight" : "marginRight"];
  return [$m(n), $m(r), $m(i)];
}, CK = function(e) {
  if (e === void 0 && (e = "margin"), typeof window > "u")
    return wK;
  var t = bK(e), n = document.documentElement.clientWidth, r = window.innerWidth;
  return {
    left: t[0],
    top: t[1],
    right: t[2],
    gap: Math.max(0, r - n + t[2] - t[0])
  };
}, EK = g_(), bs = "data-scroll-locked", AK = function(e, t, n, r) {
  var i = e.left, s = e.top, l = e.right, u = e.gap;
  return n === void 0 && (n = "margin"), `
  .`.concat(iK, ` {
   overflow: hidden `).concat(r, `;
   padding-right: `).concat(u, "px ").concat(r, `;
  }
  body[`).concat(bs, `] {
    overflow: hidden `).concat(r, `;
    overscroll-behavior: contain;
    `).concat([
    t && "position: relative ".concat(r, ";"),
    n === "margin" && `
    padding-left: `.concat(i, `px;
    padding-top: `).concat(s, `px;
    padding-right: `).concat(l, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(u, "px ").concat(r, `;
    `),
    n === "padding" && "padding-right: ".concat(u, "px ").concat(r, ";")
  ].filter(Boolean).join(""), `
  }
  
  .`).concat(wd, ` {
    right: `).concat(u, "px ").concat(r, `;
  }
  
  .`).concat(bd, ` {
    margin-right: `).concat(u, "px ").concat(r, `;
  }
  
  .`).concat(wd, " .").concat(wd, ` {
    right: 0 `).concat(r, `;
  }
  
  .`).concat(bd, " .").concat(bd, ` {
    margin-right: 0 `).concat(r, `;
  }
  
  body[`).concat(bs, `] {
    `).concat(oK, ": ").concat(u, `px;
  }
`);
}, jx = function() {
  var e = parseInt(document.body.getAttribute(bs) || "0", 10);
  return isFinite(e) ? e : 0;
}, xK = function() {
  C.useEffect(function() {
    return document.body.setAttribute(bs, (jx() + 1).toString()), function() {
      var e = jx() - 1;
      e <= 0 ? document.body.removeAttribute(bs) : document.body.setAttribute(bs, e.toString());
    };
  }, []);
}, SK = function(e) {
  var t = e.noRelative, n = e.noImportant, r = e.gapMode, i = r === void 0 ? "margin" : r;
  xK();
  var s = C.useMemo(function() {
    return CK(i);
  }, [i]);
  return C.createElement(EK, { styles: AK(s, !t, i, n ? "" : "!important") });
}, Zg = !1;
if (typeof window < "u")
  try {
    var qc = Object.defineProperty({}, "passive", {
      get: function() {
        return Zg = !0, !0;
      }
    });
    window.addEventListener("test", qc, qc), window.removeEventListener("test", qc, qc);
  } catch {
    Zg = !1;
  }
var es = Zg ? { passive: !1 } : !1, kK = function(e) {
  return e.tagName === "TEXTAREA";
}, v_ = function(e, t) {
  if (!(e instanceof Element))
    return !1;
  var n = window.getComputedStyle(e);
  return (
    // not-not-scrollable
    n[t] !== "hidden" && // contains scroll inside self
    !(n.overflowY === n.overflowX && !kK(e) && n[t] === "visible")
  );
}, RK = function(e) {
  return v_(e, "overflowY");
}, TK = function(e) {
  return v_(e, "overflowX");
}, Fx = function(e, t) {
  var n = t.ownerDocument, r = t;
  do {
    typeof ShadowRoot < "u" && r instanceof ShadowRoot && (r = r.host);
    var i = y_(e, r);
    if (i) {
      var s = w_(e, r), l = s[1], u = s[2];
      if (l > u)
        return !0;
    }
    r = r.parentNode;
  } while (r && r !== n.body);
  return !1;
}, $K = function(e) {
  var t = e.scrollTop, n = e.scrollHeight, r = e.clientHeight;
  return [
    t,
    n,
    r
  ];
}, VK = function(e) {
  var t = e.scrollLeft, n = e.scrollWidth, r = e.clientWidth;
  return [
    t,
    n,
    r
  ];
}, y_ = function(e, t) {
  return e === "v" ? RK(t) : TK(t);
}, w_ = function(e, t) {
  return e === "v" ? $K(t) : VK(t);
}, _K = function(e, t) {
  return e === "h" && t === "rtl" ? -1 : 1;
}, IK = function(e, t, n, r, i) {
  var s = _K(e, window.getComputedStyle(t).direction), l = s * r, u = n.target, d = t.contains(u), h = !1, f = l > 0, m = 0, g = 0;
  do {
    if (!u)
      break;
    var w = w_(e, u), E = w[0], b = w[1], A = w[2], x = b - A - s * E;
    (E || x) && y_(e, u) && (m += x, g += E);
    var R = u.parentNode;
    u = R && R.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? R.host : R;
  } while (
    // portaled content
    !d && u !== document.body || // self content
    d && (t.contains(u) || t === u)
  );
  return (f && Math.abs(m) < 1 || !f && Math.abs(g) < 1) && (h = !0), h;
}, Xc = function(e) {
  return "changedTouches" in e ? [e.changedTouches[0].clientX, e.changedTouches[0].clientY] : [0, 0];
}, Ux = function(e) {
  return [e.deltaX, e.deltaY];
}, Wx = function(e) {
  return e && "current" in e ? e.current : e;
}, LK = function(e, t) {
  return e[0] === t[0] && e[1] === t[1];
}, PK = function(e) {
  return `
  .block-interactivity-`.concat(e, ` {pointer-events: none;}
  .allow-interactivity-`).concat(e, ` {pointer-events: all;}
`);
}, MK = 0, ts = [];
function OK(e) {
  var t = C.useRef([]), n = C.useRef([0, 0]), r = C.useRef(), i = C.useState(MK++)[0], s = C.useState(g_)[0], l = C.useRef(e);
  C.useEffect(function() {
    l.current = e;
  }, [e]), C.useEffect(function() {
    if (e.inert) {
      document.body.classList.add("block-interactivity-".concat(i));
      var b = rK([e.lockRef.current], (e.shards || []).map(Wx), !0).filter(Boolean);
      return b.forEach(function(A) {
        return A.classList.add("allow-interactivity-".concat(i));
      }), function() {
        document.body.classList.remove("block-interactivity-".concat(i)), b.forEach(function(A) {
          return A.classList.remove("allow-interactivity-".concat(i));
        });
      };
    }
  }, [e.inert, e.lockRef.current, e.shards]);
  var u = C.useCallback(function(b, A) {
    if ("touches" in b && b.touches.length === 2 || b.type === "wheel" && b.ctrlKey)
      return !l.current.allowPinchZoom;
    var x = Xc(b), R = n.current, _ = "deltaX" in b ? b.deltaX : R[0] - x[0], L = "deltaY" in b ? b.deltaY : R[1] - x[1], V, O = b.target, D = Math.abs(_) > Math.abs(L) ? "h" : "v";
    if ("touches" in b && D === "h" && O.type === "range")
      return !1;
    var B = Fx(D, O);
    if (!B)
      return !0;
    if (B ? V = D : (V = D === "v" ? "h" : "v", B = Fx(D, O)), !B)
      return !1;
    if (!r.current && "changedTouches" in b && (_ || L) && (r.current = V), !V)
      return !0;
    var H = r.current || V;
    return IK(H, A, b, H === "h" ? _ : L);
  }, []), d = C.useCallback(function(b) {
    var A = b;
    if (!(!ts.length || ts[ts.length - 1] !== s)) {
      var x = "deltaY" in A ? Ux(A) : Xc(A), R = t.current.filter(function(V) {
        return V.name === A.type && (V.target === A.target || A.target === V.shadowParent) && LK(V.delta, x);
      })[0];
      if (R && R.should) {
        A.cancelable && A.preventDefault();
        return;
      }
      if (!R) {
        var _ = (l.current.shards || []).map(Wx).filter(Boolean).filter(function(V) {
          return V.contains(A.target);
        }), L = _.length > 0 ? u(A, _[0]) : !l.current.noIsolation;
        L && A.cancelable && A.preventDefault();
      }
    }
  }, []), h = C.useCallback(function(b, A, x, R) {
    var _ = { name: b, delta: A, target: x, should: R, shadowParent: BK(x) };
    t.current.push(_), setTimeout(function() {
      t.current = t.current.filter(function(L) {
        return L !== _;
      });
    }, 1);
  }, []), f = C.useCallback(function(b) {
    n.current = Xc(b), r.current = void 0;
  }, []), m = C.useCallback(function(b) {
    h(b.type, Ux(b), b.target, u(b, e.lockRef.current));
  }, []), g = C.useCallback(function(b) {
    h(b.type, Xc(b), b.target, u(b, e.lockRef.current));
  }, []);
  C.useEffect(function() {
    return ts.push(s), e.setCallbacks({
      onScrollCapture: m,
      onWheelCapture: m,
      onTouchMoveCapture: g
    }), document.addEventListener("wheel", d, es), document.addEventListener("touchmove", d, es), document.addEventListener("touchstart", f, es), function() {
      ts = ts.filter(function(b) {
        return b !== s;
      }), document.removeEventListener("wheel", d, es), document.removeEventListener("touchmove", d, es), document.removeEventListener("touchstart", f, es);
    };
  }, []);
  var w = e.removeScrollBar, E = e.inert;
  return C.createElement(
    C.Fragment,
    null,
    E ? C.createElement(s, { styles: PK(i) }) : null,
    w ? C.createElement(SK, { noRelative: e.noRelative, gapMode: e.gapMode }) : null
  );
}
function BK(e) {
  for (var t = null; e !== null; )
    e instanceof ShadowRoot && (t = e.host, e = e.host), e = e.parentNode;
  return t;
}
const NK = fK(m_, OK);
var K0 = C.forwardRef(function(e, t) {
  return C.createElement(Lf, lr({}, e, { ref: t, sideCar: NK }));
});
K0.classNames = Lf.classNames;
var DK = function(e) {
  if (typeof document > "u")
    return null;
  var t = Array.isArray(e) ? e[0] : e;
  return t.ownerDocument.body;
}, ns = /* @__PURE__ */ new WeakMap(), Zc = /* @__PURE__ */ new WeakMap(), Qc = {}, Vm = 0, b_ = function(e) {
  return e && (e.host || b_(e.parentNode));
}, jK = function(e, t) {
  return t.map(function(n) {
    if (e.contains(n))
      return n;
    var r = b_(n);
    return r && e.contains(r) ? r : (console.error("aria-hidden", n, "in not contained inside", e, ". Doing nothing"), null);
  }).filter(function(n) {
    return !!n;
  });
}, FK = function(e, t, n, r) {
  var i = jK(t, Array.isArray(e) ? e : [e]);
  Qc[n] || (Qc[n] = /* @__PURE__ */ new WeakMap());
  var s = Qc[n], l = [], u = /* @__PURE__ */ new Set(), d = new Set(i), h = function(m) {
    !m || u.has(m) || (u.add(m), h(m.parentNode));
  };
  i.forEach(h);
  var f = function(m) {
    !m || d.has(m) || Array.prototype.forEach.call(m.children, function(g) {
      if (u.has(g))
        f(g);
      else
        try {
          var w = g.getAttribute(r), E = w !== null && w !== "false", b = (ns.get(g) || 0) + 1, A = (s.get(g) || 0) + 1;
          ns.set(g, b), s.set(g, A), l.push(g), b === 1 && E && Zc.set(g, !0), A === 1 && g.setAttribute(n, "true"), E || g.setAttribute(r, "true");
        } catch (x) {
          console.error("aria-hidden: cannot operate on ", g, x);
        }
    });
  };
  return f(t), u.clear(), Vm++, function() {
    l.forEach(function(m) {
      var g = ns.get(m) - 1, w = s.get(m) - 1;
      ns.set(m, g), s.set(m, w), g || (Zc.has(m) || m.removeAttribute(r), Zc.delete(m)), w || m.removeAttribute(n);
    }), Vm--, Vm || (ns = /* @__PURE__ */ new WeakMap(), ns = /* @__PURE__ */ new WeakMap(), Zc = /* @__PURE__ */ new WeakMap(), Qc = {});
  };
}, C_ = function(e, t, n) {
  n === void 0 && (n = "data-aria-hidden");
  var r = Array.from(Array.isArray(e) ? e : [e]), i = DK(e);
  return i ? (r.push.apply(r, Array.from(i.querySelectorAll("[aria-live], script"))), FK(r, i, n, "aria-hidden")) : function() {
    return null;
  };
}, Pf = "Dialog", [E_] = Ys(Pf), [UK, Xn] = E_(Pf), A_ = (e) => {
  const {
    __scopeDialog: t,
    children: n,
    open: r,
    defaultOpen: i,
    onOpenChange: s,
    modal: l = !0
  } = e, u = C.useRef(null), d = C.useRef(null), [h, f] = Zs({
    prop: r,
    defaultProp: i ?? !1,
    onChange: s,
    caller: Pf
  });
  return /* @__PURE__ */ I.jsx(
    UK,
    {
      scope: t,
      triggerRef: u,
      contentRef: d,
      contentId: Rl(),
      titleId: Rl(),
      descriptionId: Rl(),
      open: h,
      onOpenChange: f,
      onOpenToggle: C.useCallback(() => f((m) => !m), [f]),
      modal: l,
      children: n
    }
  );
};
A_.displayName = Pf;
var x_ = "DialogTrigger", WK = C.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, i = Xn(x_, n), s = wt(t, i.triggerRef);
    return /* @__PURE__ */ I.jsx(
      ut.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": i.open,
        "aria-controls": i.contentId,
        "data-state": q0(i.open),
        ...r,
        ref: s,
        onClick: Le(e.onClick, i.onOpenToggle)
      }
    );
  }
);
WK.displayName = x_;
var G0 = "DialogPortal", [zK, S_] = E_(G0, {
  forceMount: void 0
}), k_ = (e) => {
  const { __scopeDialog: t, forceMount: n, children: r, container: i } = e, s = Xn(G0, t);
  return /* @__PURE__ */ I.jsx(zK, { scope: t, forceMount: n, children: C.Children.map(r, (l) => /* @__PURE__ */ I.jsx(Ur, { present: n || s.open, children: /* @__PURE__ */ I.jsx(bf, { asChild: !0, container: i, children: l }) })) });
};
k_.displayName = G0;
var zd = "DialogOverlay", R_ = C.forwardRef(
  (e, t) => {
    const n = S_(zd, e.__scopeDialog), { forceMount: r = n.forceMount, ...i } = e, s = Xn(zd, e.__scopeDialog);
    return s.modal ? /* @__PURE__ */ I.jsx(Ur, { present: r || s.open, children: /* @__PURE__ */ I.jsx(KK, { ...i, ref: t }) }) : null;
  }
);
R_.displayName = zd;
var HK = /* @__PURE__ */ Bs("DialogOverlay.RemoveScroll"), KK = C.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, i = Xn(zd, n);
    return (
      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
      // ie. when `Overlay` and `Content` are siblings
      /* @__PURE__ */ I.jsx(K0, { as: HK, allowPinchZoom: !0, shards: [i.contentRef], children: /* @__PURE__ */ I.jsx(
        ut.div,
        {
          "data-state": q0(i.open),
          ...r,
          ref: t,
          style: { pointerEvents: "auto", ...r.style }
        }
      ) })
    );
  }
), bo = "DialogContent", T_ = C.forwardRef(
  (e, t) => {
    const n = S_(bo, e.__scopeDialog), { forceMount: r = n.forceMount, ...i } = e, s = Xn(bo, e.__scopeDialog);
    return /* @__PURE__ */ I.jsx(Ur, { present: r || s.open, children: s.modal ? /* @__PURE__ */ I.jsx(GK, { ...i, ref: t }) : /* @__PURE__ */ I.jsx(YK, { ...i, ref: t }) });
  }
);
T_.displayName = bo;
var GK = C.forwardRef(
  (e, t) => {
    const n = Xn(bo, e.__scopeDialog), r = C.useRef(null), i = wt(t, n.contentRef, r);
    return C.useEffect(() => {
      const s = r.current;
      if (s) return C_(s);
    }, []), /* @__PURE__ */ I.jsx(
      $_,
      {
        ...e,
        ref: i,
        trapFocus: n.open,
        disableOutsidePointerEvents: !0,
        onCloseAutoFocus: Le(e.onCloseAutoFocus, (s) => {
          var l;
          s.preventDefault(), (l = n.triggerRef.current) == null || l.focus();
        }),
        onPointerDownOutside: Le(e.onPointerDownOutside, (s) => {
          const l = s.detail.originalEvent, u = l.button === 0 && l.ctrlKey === !0;
          (l.button === 2 || u) && s.preventDefault();
        }),
        onFocusOutside: Le(
          e.onFocusOutside,
          (s) => s.preventDefault()
        )
      }
    );
  }
), YK = C.forwardRef(
  (e, t) => {
    const n = Xn(bo, e.__scopeDialog), r = C.useRef(!1), i = C.useRef(!1);
    return /* @__PURE__ */ I.jsx(
      $_,
      {
        ...e,
        ref: t,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        onCloseAutoFocus: (s) => {
          var l, u;
          (l = e.onCloseAutoFocus) == null || l.call(e, s), s.defaultPrevented || (r.current || (u = n.triggerRef.current) == null || u.focus(), s.preventDefault()), r.current = !1, i.current = !1;
        },
        onInteractOutside: (s) => {
          var d, h;
          (d = e.onInteractOutside) == null || d.call(e, s), s.defaultPrevented || (r.current = !0, s.detail.originalEvent.type === "pointerdown" && (i.current = !0));
          const l = s.target;
          ((h = n.triggerRef.current) == null ? void 0 : h.contains(l)) && s.preventDefault(), s.detail.originalEvent.type === "focusin" && i.current && s.preventDefault();
        }
      }
    );
  }
), $_ = C.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, trapFocus: r, onOpenAutoFocus: i, onCloseAutoFocus: s, ...l } = e, u = Xn(bo, n), d = C.useRef(null), h = wt(t, d);
    return f_(), /* @__PURE__ */ I.jsxs(I.Fragment, { children: [
      /* @__PURE__ */ I.jsx(
        H0,
        {
          asChild: !0,
          loop: !0,
          trapped: r,
          onMountAutoFocus: i,
          onUnmountAutoFocus: s,
          children: /* @__PURE__ */ I.jsx(
            fu,
            {
              role: "dialog",
              id: u.contentId,
              "aria-describedby": u.descriptionId,
              "aria-labelledby": u.titleId,
              "data-state": q0(u.open),
              ...l,
              ref: h,
              onDismiss: () => u.onOpenChange(!1)
            }
          )
        }
      ),
      /* @__PURE__ */ I.jsxs(I.Fragment, { children: [
        /* @__PURE__ */ I.jsx(qK, { titleId: u.titleId }),
        /* @__PURE__ */ I.jsx(ZK, { contentRef: d, descriptionId: u.descriptionId })
      ] })
    ] });
  }
), Y0 = "DialogTitle", V_ = C.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, i = Xn(Y0, n);
    return /* @__PURE__ */ I.jsx(ut.h2, { id: i.titleId, ...r, ref: t });
  }
);
V_.displayName = Y0;
var __ = "DialogDescription", I_ = C.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, i = Xn(__, n);
    return /* @__PURE__ */ I.jsx(ut.p, { id: i.descriptionId, ...r, ref: t });
  }
);
I_.displayName = __;
var L_ = "DialogClose", P_ = C.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, i = Xn(L_, n);
    return /* @__PURE__ */ I.jsx(
      ut.button,
      {
        type: "button",
        ...r,
        ref: t,
        onClick: Le(e.onClick, () => i.onOpenChange(!1))
      }
    );
  }
);
P_.displayName = L_;
function q0(e) {
  return e ? "open" : "closed";
}
var M_ = "DialogTitleWarning", [Die, O_] = GF(M_, {
  contentName: bo,
  titleName: Y0,
  docsSlug: "dialog"
}), qK = ({ titleId: e }) => {
  const t = O_(M_), n = `\`${t.contentName}\` requires a \`${t.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${t.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${t.docsSlug}`;
  return C.useEffect(() => {
    e && (document.getElementById(e) || console.error(n));
  }, [n, e]), null;
}, XK = "DialogDescriptionWarning", ZK = ({ contentRef: e, descriptionId: t }) => {
  const r = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${O_(XK).contentName}}.`;
  return C.useEffect(() => {
    var s;
    const i = (s = e.current) == null ? void 0 : s.getAttribute("aria-describedby");
    t && i && (document.getElementById(t) || console.warn(r));
  }, [r, e, t]), null;
}, QK = A_, JK = k_, eG = R_, tG = T_, nG = V_, rG = I_, iG = P_;
const X0 = ({
  children: e,
  onOpenChange: t,
  ...n
}) => /* @__PURE__ */ j.createElement(QK, { defaultOpen: !0, onOpenChange: t, ...n }, /* @__PURE__ */ j.createElement(JK, null, e));
X0.displayName = "ModalView.Root";
const Z0 = j.forwardRef(({
  className: e,
  ...t
}, n) => /* @__PURE__ */ j.createElement(eG, { className: Se("knock-guide-modal__overlay", e), ref: n, ...t }));
Z0.displayName = "ModalView.Overlay";
const Q0 = j.forwardRef(({
  children: e,
  className: t,
  ...n
}, r) => /* @__PURE__ */ j.createElement(tG, { className: Se("knock-guide-modal", t), ref: r, ...n }, e));
Q0.displayName = "ModalView.Content";
const B_ = ({
  children: e,
  className: t,
  ...n
}) => /* @__PURE__ */ j.createElement("div", { className: Se("knock-guide-modal__header", t), ...n }, e);
B_.displayName = "ModalView.Header";
const J0 = ({
  title: e,
  className: t,
  ...n
}) => /* @__PURE__ */ j.createElement(nG, { className: Se("knock-guide-modal__title", t), ...n }, e);
J0.displayName = "ModalView.Title";
const ew = ({
  body: e,
  className: t,
  ...n
}) => /* @__PURE__ */ j.createElement(rG, { className: Se("knock-guide-modal__body", t), dangerouslySetInnerHTML: {
  __html: e
}, ...n });
ew.displayName = "ModalView.Body";
const tw = ({
  children: e,
  className: t,
  alt: n,
  ...r
}) => /* @__PURE__ */ j.createElement("img", { className: Se("knock-guide-modal__img", t), alt: n || "", ...r }, e);
tw.displayName = "ModalView.Img";
const nw = ({
  children: e,
  className: t,
  ...n
}) => /* @__PURE__ */ j.createElement("div", { className: Se("knock-guide-modal__actions", t), ...n }, e);
nw.displayName = "ModalView.Actions";
const rw = ({
  text: e,
  action: t,
  className: n,
  ...r
}) => /* @__PURE__ */ j.createElement("button", { className: Se("knock-guide-modal__action", n), ...r }, e);
rw.displayName = "ModalView.PrimaryButton";
const iw = ({
  text: e,
  action: t,
  className: n,
  ...r
}) => /* @__PURE__ */ j.createElement("button", { className: Se("knock-guide-modal__action knock-guide-modal__action--secondary", n), ...r }, e);
iw.displayName = "ModalView.SecondaryButton";
const ow = ({
  className: e,
  ...t
}) => /* @__PURE__ */ j.createElement(iG, { className: Se("knock-guide-modal__close", e), ...t }, /* @__PURE__ */ j.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "18", height: "18", fill: "none" }, /* @__PURE__ */ j.createElement("g", { fill: "#60646C", fillRule: "evenodd", clipRule: "evenodd" }, /* @__PURE__ */ j.createElement("path", { d: "M14.03 3.97a.75.75 0 0 1 0 1.06l-9 9a.75.75 0 0 1-1.06-1.06l9-9a.75.75 0 0 1 1.06 0Z" }), /* @__PURE__ */ j.createElement("path", { d: "M3.97 3.97a.75.75 0 0 1 1.06 0l9 9a.75.75 0 1 1-1.06 1.06l-9-9a.75.75 0 0 1 0-1.06Z" }))));
ow.displayName = "ModalView.Close";
const N_ = ({
  content: e,
  colorMode: t = "light",
  onOpenChange: n,
  onDismiss: r,
  onButtonClick: i,
  onImageClick: s
}) => /* @__PURE__ */ j.createElement(X0, { onOpenChange: n }, /* @__PURE__ */ j.createElement(Z0, null), /* @__PURE__ */ j.createElement(Q0, { "data-knock-color-mode": t, onPointerDownOutside: r }, /* @__PURE__ */ j.createElement(B_, null, /* @__PURE__ */ j.createElement(J0, { title: e.title }), e.dismissible && /* @__PURE__ */ j.createElement(ow, { onClick: r })), /* @__PURE__ */ j.createElement(ew, { body: e.body }), e.image && /* @__PURE__ */ j.createElement("a", { href: _R(e.image.action) ? e.image.action : void 0, target: "_blank" }, /* @__PURE__ */ j.createElement(tw, { src: e.image.url, alt: e.image.alt, onClick: (l) => {
  s && s(l, e.image);
} })), (e.primary_button || e.secondary_button) && /* @__PURE__ */ j.createElement(nw, null, e.secondary_button && /* @__PURE__ */ j.createElement(iw, { text: e.secondary_button.text, action: e.secondary_button.action, onClick: (l) => {
  if (i) {
    const {
      text: u,
      action: d
    } = e.secondary_button;
    i(l, {
      name: "secondary_button",
      text: u,
      action: d
    });
  }
} }), e.primary_button && /* @__PURE__ */ j.createElement(rw, { text: e.primary_button.text, action: e.primary_button.action, onClick: (l) => {
  if (i) {
    const {
      text: u,
      action: d
    } = e.primary_button;
    i(l, {
      name: "primary_button",
      text: u,
      action: d
    });
  }
} }))));
N_.displayName = "ModalView.Default";
const oG = {};
Object.assign(oG, {
  Default: N_,
  Root: X0,
  Overlay: Z0,
  Content: Q0,
  Title: J0,
  Body: ew,
  Img: tw,
  Actions: nw,
  PrimaryButton: rw,
  SecondaryButton: iw,
  Close: ow
});
var sG = Symbol.for("react.lazy"), Hd = Dv[" use ".trim().toString()];
function aG(e) {
  return typeof e == "object" && e !== null && "then" in e;
}
function D_(e) {
  return e != null && typeof e == "object" && "$$typeof" in e && e.$$typeof === sG && "_payload" in e && aG(e._payload);
}
// @__NO_SIDE_EFFECTS__
function lG(e) {
  const t = /* @__PURE__ */ uG(e), n = C.forwardRef((r, i) => {
    let { children: s, ...l } = r;
    D_(s) && typeof Hd == "function" && (s = Hd(s._payload));
    const u = C.Children.toArray(s), d = u.find(dG);
    if (d) {
      const h = d.props.children, f = u.map((m) => m === d ? C.Children.count(h) > 1 ? C.Children.only(null) : C.isValidElement(h) ? h.props.children : null : m);
      return /* @__PURE__ */ I.jsx(t, { ...l, ref: i, children: C.isValidElement(h) ? C.cloneElement(h, void 0, f) : null });
    }
    return /* @__PURE__ */ I.jsx(t, { ...l, ref: i, children: s });
  });
  return n.displayName = `${e}.Slot`, n;
}
// @__NO_SIDE_EFFECTS__
function uG(e) {
  const t = C.forwardRef((n, r) => {
    let { children: i, ...s } = n;
    if (D_(i) && typeof Hd == "function" && (i = Hd(i._payload)), C.isValidElement(i)) {
      const l = hG(i), u = fG(s, i.props);
      return i.type !== C.Fragment && (u.ref = r ? pf(r, l) : l), C.cloneElement(i, u);
    }
    return C.Children.count(i) > 1 ? C.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var cG = Symbol("radix.slottable");
function dG(e) {
  return C.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === cG;
}
function fG(e, t) {
  const n = { ...t };
  for (const r in t) {
    const i = e[r], s = t[r];
    /^on[A-Z]/.test(r) ? i && s ? n[r] = (...u) => {
      const d = s(...u);
      return i(...u), d;
    } : i && (n[r] = i) : r === "style" ? n[r] = { ...i, ...s } : r === "className" && (n[r] = [i, s].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function hG(e) {
  var r, i;
  let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = (i = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : i.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var pG = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
], mG = pG.reduce((e, t) => {
  const n = /* @__PURE__ */ lG(`Primitive.${t}`), r = C.forwardRef((i, s) => {
    const { asChild: l, ...u } = i, d = l ? n : t;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ I.jsx(d, { ...u, ref: s });
  });
  return r.displayName = `Primitive.${t}`, { ...e, [t]: r };
}, {}), gG = Object.freeze({
  // See: https://github.com/twbs/bootstrap/blob/main/scss/mixins/_visually-hidden.scss
  position: "absolute",
  border: 0,
  width: 1,
  height: 1,
  padding: 0,
  margin: -1,
  overflow: "hidden",
  clip: "rect(0, 0, 0, 0)",
  whiteSpace: "nowrap",
  wordWrap: "normal"
}), vG = "VisuallyHidden", j_ = C.forwardRef(
  (e, t) => /* @__PURE__ */ I.jsx(
    mG.span,
    {
      ...e,
      ref: t,
      style: { ...gG, ...e.style }
    }
  )
);
j_.displayName = vG;
var yG = j_;
function wG(e, t) {
  typeof e == "function" ? e(t) : e != null && (e.current = t);
}
function bG(...e) {
  return (t) => e.forEach((n) => wG(n, t));
}
function sw(...e) {
  return C.useCallback(bG(...e), e);
}
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const CG = (e) => e.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), EG = (e) => e.replace(
  /^([A-Z])|[\s-_]+(\w)/g,
  (t, n, r) => r ? r.toUpperCase() : n.toLowerCase()
), zx = (e) => {
  const t = EG(e);
  return t.charAt(0).toUpperCase() + t.slice(1);
}, F_ = (...e) => e.filter((t, n, r) => !!t && t.trim() !== "" && r.indexOf(t) === n).join(" ").trim(), AG = (e) => {
  for (const t in e)
    if (t.startsWith("aria-") || t === "role" || t === "title")
      return !0;
};
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
var xG = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round"
};
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const SG = C.forwardRef(
  ({
    color: e = "currentColor",
    size: t = 24,
    strokeWidth: n = 2,
    absoluteStrokeWidth: r,
    className: i = "",
    children: s,
    iconNode: l,
    ...u
  }, d) => C.createElement(
    "svg",
    {
      ref: d,
      ...xG,
      width: t,
      height: t,
      stroke: e,
      strokeWidth: r ? Number(n) * 24 / Number(t) : n,
      className: F_("lucide", i),
      ...!s && !AG(u) && { "aria-hidden": "true" },
      ...u
    },
    [
      ...l.map(([h, f]) => C.createElement(h, f)),
      ...Array.isArray(s) ? s : [s]
    ]
  )
);
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Mf = (e, t) => {
  const n = C.forwardRef(
    ({ className: r, ...i }, s) => C.createElement(SG, {
      ref: s,
      iconNode: t,
      className: F_(
        `lucide-${CG(zx(e))}`,
        `lucide-${e}`,
        r
      ),
      ...i
    })
  );
  return n.displayName = zx(e), n;
};
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const kG = [
  ["path", { d: "m7 15 5 5 5-5", key: "1hf1tw" }],
  ["path", { d: "m7 9 5-5 5 5", key: "sgt6xg" }]
], RG = Mf("chevrons-up-down", kG);
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const TG = [
  ["path", { d: "M5 12h14", key: "1ays0h" }],
  ["path", { d: "M12 5v14", key: "s699le" }]
], $G = Mf("plus", TG);
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const VG = [
  ["path", { d: "m21 21-4.34-4.34", key: "14j7rj" }],
  ["circle", { cx: "11", cy: "11", r: "8", key: "4ej97u" }]
], U_ = Mf("search", VG);
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const _G = [
  ["path", { d: "M18 6 6 18", key: "1bl5f8" }],
  ["path", { d: "m6 6 12 12", key: "d8bk6v" }]
], aw = Mf("x", _G), Hx = {
  0: "var(--tgph-spacing-3)",
  1: "var(--tgph-spacing-3_5)",
  2: "var(--tgph-spacing-4)",
  3: "1.125rem",
  4: "var(--tgph-spacing-5)",
  5: "var(--tgph-spacing-6)",
  6: "var(--tgph-spacing-7)",
  7: "var(--tgph-spacing-8)",
  8: "var(--tgph-spacing-10)",
  9: "var(--tgph-spacing-12)"
}, IG = {
  primary: {
    default: "var(--tgph-gray-12)",
    gray: "var(--tgph-gray-11)",
    accent: "var(--tgph-accent-11)",
    beige: "var(--tgph-beige-11)",
    blue: "var(--tgph-blue-11)",
    green: "var(--tgph-green-11)",
    yellow: "var(--tgph-yellow-11)",
    purple: "var(--tgph-purple-11)",
    red: "var(--tgph-red-11)",
    white: "var(--tgph-white)",
    disabled: "var(--tgph-gray-9)",
    black: "var(--tgph-black)"
  },
  secondary: {
    default: "var(--tgph-gray-11)",
    gray: "var(--tgph-gray-10)",
    accent: "var(--tgph-accent-10)",
    beige: "var(--tgph-beige-10)",
    blue: "var(--tgph-blue-10)",
    green: "var(--tgph-green-10)",
    yellow: "var(--tgph-yellow-10)",
    purple: "var(--tgph-purple-10)",
    red: "var(--tgph-red-10)",
    white: "var(--tgph-white)",
    disabled: "var(--tgph-gray-8)",
    black: "var(--tgph-black)"
  }
}, W_ = ({
  as: e,
  size: t = "2",
  color: n = "default",
  variant: r = "primary",
  animation: i = "none",
  icon: s,
  alt: l,
  className: u,
  style: d,
  ...h
}) => {
  const f = s;
  return f || console.error("@telegraph/icon: icon prop is required"), !l && !h["aria-hidden"] && console.error("@telegraph/icon: alt prop is required"), /* @__PURE__ */ I.jsx(
    qn,
    {
      as: e || "span",
      className: Se("tgph-icon", u),
      "data-button-icon": !0,
      "data-tgph-icon-animation": i,
      style: {
        // We choose to override these values vs passing them in as props because
        // the icon's sizes aren't all exact telegraph tokens and the colors
        // of the icon are different than the text color. Because of how the Text
        // component is setup this is a valid way to inject these values in for these
        // few cases.
        "--height": Hx[t],
        "--width": Hx[t],
        "--color": IG[r][n],
        ...d
      },
      ...h,
      children: f && /* @__PURE__ */ I.jsx(
        f,
        {
          role: "img",
          "aria-label": l,
          width: "100%",
          height: "100%",
          display: "block"
        }
      )
    }
  );
}, Ne = {
  display: {
    cssVar: "--display",
    value: "VARIABLE"
  },
  backgroundColor: {
    cssVar: "--background-color",
    value: "var(--tgph-VARIABLE)"
  },
  hover_backgroundColor: {
    cssVar: "--hover_backgroundColor",
    value: "var(--tgph-VARIABLE)",
    interactive: !0
  },
  focus_backgroundColor: {
    cssVar: "--focus_backgroundColor",
    value: "var(--tgph-VARIABLE)",
    interactive: !0
  },
  active_backgroundColor: {
    cssVar: "--active_backgroundColor",
    interactive: !0,
    value: "var(--tgph-VARIABLE)"
  },
  focus_within_backgroundColor: {
    cssVar: "--focus_within_backgroundColor",
    interactive: !0,
    value: "var(--tgph-VARIABLE)"
  },
  borderStyle: {
    cssVar: "--border-style",
    value: "var(--tgph-border-style-VARIABLE)"
  },
  padding: {
    cssVar: "--padding",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "all"
  },
  paddingX: {
    cssVar: "--padding",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "x"
  },
  paddingY: {
    cssVar: "--padding",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "y"
  },
  paddingTop: {
    cssVar: "--padding",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "top"
  },
  paddingBottom: {
    cssVar: "--padding",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "bottom"
  },
  paddingLeft: {
    cssVar: "--padding",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "left"
  },
  paddingRight: {
    cssVar: "--padding",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "right"
  },
  margin: {
    cssVar: "--margin",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "all"
  },
  marginX: {
    cssVar: "--margin",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "x"
  },
  marginY: {
    cssVar: "--margin",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "y"
  },
  marginTop: {
    cssVar: "--margin",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "top"
  },
  marginBottom: {
    cssVar: "--margin",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "bottom"
  },
  marginLeft: {
    cssVar: "--margin",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "left"
  },
  marginRight: {
    cssVar: "--margin",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "right"
  },
  borderColor: {
    cssVar: "--border-color",
    value: "var(--tgph-VARIABLE)"
  },
  hover_borderColor: {
    cssVar: "--hover_borderColor",
    value: "var(--tgph-VARIABLE)",
    interactive: !0
  },
  focus_borderColor: {
    cssVar: "--focus_borderColor",
    value: "var(--tgph-VARIABLE)",
    interactive: !0
  },
  focus_within_borderColor: {
    cssVar: "--focus_within_borderColor",
    interactive: !0,
    value: "var(--tgph-VARIABLE)"
  },
  active_borderColor: {
    cssVar: "--active_borderColor",
    interactive: !0,
    value: "var(--tgph-VARIABLE)"
  },
  borderTopColor: {
    cssVar: "--border-color",
    value: "var(--tgph-VARIABLE)",
    direction: "top"
  },
  borderBottomColor: {
    cssVar: "--border-color",
    value: "var(--tgph-VARIABLE)",
    direction: "bottom"
  },
  borderLeftColor: {
    cssVar: "--border-color",
    value: "var(--tgph-VARIABLE)",
    direction: "left"
  },
  borderRightColor: {
    cssVar: "--border-color",
    value: "var(--tgph-VARIABLE)",
    direction: "right"
  },
  borderWidth: {
    cssVar: "--border-width",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  borderTopWidth: {
    cssVar: "--border-width",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "top"
  },
  borderBottomWidth: {
    cssVar: "--border-width",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "bottom"
  },
  borderLeftWidth: {
    cssVar: "--border-width",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "left"
  },
  borderRightWidth: {
    cssVar: "--border-width",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "right"
  },
  borderRadius: {
    cssVar: "--border-radius",
    value: "var(--tgph-rounded-VARIABLE)"
  },
  borderTopLeftRadius: {
    cssVar: "--border-radius",
    value: "var(--tgph-rounded-VARIABLE)",
    direction: "top"
  },
  borderTopRightRadius: {
    cssVar: "--border-radius",
    value: "var(--tgph-rounded-VARIABLE)",
    direction: "right"
  },
  borderBottomLeftRadius: {
    cssVar: "--border-radius",
    value: "var(--tgph-rounded-VARIABLE)",
    direction: "left"
  },
  borderBottomRightRadius: {
    cssVar: "--border-radius",
    value: "var(--tgph-rounded-VARIABLE)",
    direction: "bottom"
  },
  borderTopRadius: {
    cssVar: "--border-radius",
    value: "var(--tgph-rounded-VARIABLE)",
    direction: "side-top"
  },
  borderBottomRadius: {
    cssVar: "--border-radius",
    value: "var(--tgph-rounded-VARIABLE)",
    direction: "side-bottom"
  },
  borderLeftRadius: {
    cssVar: "--border-radius",
    value: "var(--tgph-rounded-VARIABLE)",
    direction: "side-left"
  },
  borderRightRadius: {
    cssVar: "--border-radius",
    value: "var(--tgph-rounded-VARIABLE)",
    direction: "side-right"
  },
  boxShadow: {
    cssVar: "--box-shadow",
    value: "var(--tgph-shadow-VARIABLE)"
  },
  width: {
    cssVar: "--width",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  height: {
    cssVar: "--height",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  minWidth: {
    cssVar: "--min-width",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  minHeight: {
    cssVar: "--min-height",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  maxWidth: {
    cssVar: "--max-width",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  maxHeight: {
    cssVar: "--max-height",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  zIndex: {
    cssVar: "--z-index",
    value: "var(--tgph-zIndex-VARIABLE)"
  },
  position: {
    cssVar: "--position",
    value: "VARIABLE"
  },
  top: {
    cssVar: "--top",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  left: {
    cssVar: "--left",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  right: {
    cssVar: "--right",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  bottom: {
    cssVar: "--bottom",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  overflow: {
    cssVar: "--overflow",
    value: "VARIABLE"
  },
  overflowX: {
    cssVar: "--overflow-x",
    value: "VARIABLE"
  },
  overflowY: {
    cssVar: "--overflow-y",
    value: "VARIABLE"
  },
  alignSelf: {
    cssVar: "--align-self",
    value: "VARIABLE"
  }
}, LG = {
  border: Ne.borderWidth,
  borderX: Ne.borderLeftWidth,
  borderY: Ne.borderTopWidth,
  bg: Ne.backgroundColor,
  p: Ne.padding,
  m: Ne.margin,
  px: Ne.paddingX,
  py: Ne.paddingY,
  pt: Ne.paddingTop,
  pb: Ne.paddingBottom,
  pl: Ne.paddingLeft,
  pr: Ne.paddingRight,
  mx: Ne.marginX,
  my: Ne.marginY,
  mt: Ne.marginTop,
  mb: Ne.marginBottom,
  ml: Ne.marginLeft,
  mr: Ne.marginRight,
  shadow: Ne.boxShadow,
  w: Ne.width,
  h: Ne.height,
  minW: Ne.minWidth,
  minH: Ne.minHeight,
  maxW: Ne.maxWidth,
  maxH: Ne.maxHeight,
  rounded: Ne.borderRadius,
  roundedTopLeft: Ne.borderTopLeftRadius,
  roundedTopRight: Ne.borderTopRightRadius,
  roundedBottomLeft: Ne.borderBottomLeftRadius,
  roundedBottomRight: Ne.borderBottomRightRadius,
  roundedTop: Ne.borderTopRadius,
  roundedBottom: Ne.borderBottomRadius,
  roundedLeft: Ne.borderLeftRadius,
  roundedRight: Ne.borderRightRadius,
  borderTop: Ne.borderTopWidth,
  borderBottom: Ne.borderBottomWidth,
  borderLeft: Ne.borderLeftWidth,
  borderRight: Ne.borderRightWidth
}, PG = {
  ...Ne,
  ...LG
}, MG = ({
  as: e,
  className: t,
  tgphRef: n,
  children: r,
  ...i
}) => {
  const s = e || "div", { styleProp: l, otherProps: u, interactive: d } = Wt({
    props: i,
    cssVars: PG
  });
  return /* @__PURE__ */ I.jsx(
    s,
    {
      className: Se(
        "tgph-box",
        d && "tgph-box--interactive",
        t
      ),
      style: l,
      ...u,
      ref: n,
      children: r
    }
  );
}, OG = {
  flexDirection: {
    cssVar: "--direction",
    value: "VARIABLE"
  },
  flexWrap: {
    cssVar: "--wrap",
    value: "VARIABLE"
  },
  justifyContent: {
    cssVar: "--justify",
    value: "VARIABLE"
  },
  alignItems: {
    cssVar: "--align",
    value: "VARIABLE"
  },
  gap: {
    cssVar: "--gap",
    value: "var(--tgph-spacing-VARIABLE)"
  }
}, BG = {
  direction: {
    cssVar: "--direction",
    value: "VARIABLE"
  },
  align: {
    cssVar: "--align",
    value: "VARIABLE"
  },
  justify: {
    cssVar: "--justify",
    value: "VARIABLE"
  },
  wrap: {
    cssVar: "--wrap",
    value: "VARIABLE"
  }
}, NG = {
  ...OG,
  ...BG
}, z_ = ({
  className: e,
  ...t
}) => {
  const { styleProp: n, otherProps: r } = Wt({
    props: t,
    cssVars: NG
  });
  return /* @__PURE__ */ I.jsx(
    MG,
    {
      className: Se("tgph-stack", e),
      style: n,
      ...r
    }
  );
}, Kd = {
  Container: {
    1: {
      h: "6",
      pl: "0",
      rounded: "2"
    },
    2: {
      h: "8",
      pl: "0",
      rounded: "2"
    },
    3: {
      h: "10",
      pl: "0",
      rounded: "2"
    }
  },
  Text: {
    1: {
      size: "1",
      px: "1"
    },
    2: {
      size: "2",
      px: "2"
    },
    3: {
      size: "3",
      px: "3"
    }
  },
  SlotLeading: {
    1: {
      pl: "1_5"
    },
    2: {
      pl: "2"
    },
    3: {
      pl: "3"
    }
  },
  SlotTrailing: {
    1: {
      pr: "1"
    },
    2: {
      pr: "2"
    },
    3: {
      pr: "3"
    }
  }
}, Kx = {
  Container: {
    default: {
      outline: {
        bg: "surface-1",
        border: "px",
        borderColor: "gray-6",
        hover_borderColor: "gray-7",
        focus_within_borderColor: "blue-8"
      },
      ghost: {
        bg: "transparent",
        border: "px",
        borderColor: "transparent",
        hover_backgroundColor: "gray-3",
        hover_borderColor: "transparent",
        focus_within_backgroundColor: "gray-4",
        focus_within_borderColor: "blue-8"
      }
    },
    disabled: {
      outline: {
        bg: "gray-2",
        border: "px",
        borderColor: "gray-2"
      },
      ghost: {
        bg: "transparent",
        border: "px",
        borderColor: "transparent"
      }
    },
    error: {
      outline: {
        bg: "surface-1",
        border: "px",
        borderColor: "red-6"
      },
      ghost: {
        bg: "transparent",
        border: "px",
        borderColor: "red-6"
      }
    }
  },
  Text: {
    default: {
      color: "default"
    },
    disabled: {
      color: "disabled"
    },
    error: {
      color: "default"
    }
  }
}, H_ = j.createContext({
  state: "default",
  size: "2",
  variant: "outline"
}), K_ = ({
  as: e = "input",
  size: t = "2",
  variant: n = "outline",
  textProps: r,
  stackProps: i,
  disabled: s,
  errored: l,
  children: u,
  tgphRef: d,
  ...h
}) => {
  const f = e, m = j.useRef(null), g = sw(d, m), w = s ? "disabled" : l ? "error" : "default";
  return /* @__PURE__ */ I.jsx(H_.Provider, { value: { size: t, variant: n, state: w }, children: /* @__PURE__ */ I.jsxs(
    z_,
    {
      onPointerDown: (E) => {
        if (E.target.closest("button, a")) {
          E.preventDefault();
          return;
        }
        const b = m.current;
        b && requestAnimationFrame(() => {
          b.focus();
        });
      },
      align: "center",
      ...Kd.Container[t],
      ...Kx.Container[w][n],
      "data-tgph-input-container": !0,
      "data-tgph-input-container-variant": n,
      "data-tgph-input-container-state": w,
      "data-tgph-input-container-size": t,
      ...i,
      children: [
        /* @__PURE__ */ I.jsx(
          qn,
          {
            as: f,
            bg: "transparent",
            shadow: "0",
            h: "full",
            w: "full",
            disabled: s,
            tgphRef: g,
            ...Kd.Text[t],
            ...Kx.Text[w],
            ...h,
            ...r,
            "data-tgph-input-field": !0
          }
        ),
        u
      ]
    }
  ) });
}, Qg = j.forwardRef(
  ({ position: e = "leading", ...t }, n) => {
    const r = j.useContext(H_);
    return /* @__PURE__ */ I.jsx(
      z_,
      {
        align: "center",
        justify: "center",
        h: "full",
        "data-tgph-input-slot": !0,
        "data-tgph-input-slot-position": e,
        "data-tgph-input-slot-size": t.size ?? r.size,
        ...e === "leading" && Kd.SlotLeading[r.size],
        ...e === "trailing" && Kd.SlotTrailing[r.size],
        children: /* @__PURE__ */ I.jsx(GR, { size: r.size, ...t, ref: n })
      }
    );
  }
), G_ = ({
  LeadingComponent: e,
  TrailingComponent: t,
  ...n
}) => /* @__PURE__ */ I.jsxs(K_, { ...n, children: [
  e && /* @__PURE__ */ I.jsx(Qg, { position: "leading", children: e }),
  t && /* @__PURE__ */ I.jsx(Qg, { position: "trailing", children: t })
] });
Object.assign(G_, { Root: K_, Slot: Qg });
const DG = G_, De = {
  display: {
    cssVar: "--display",
    value: "VARIABLE"
  },
  backgroundColor: {
    cssVar: "--background-color",
    value: "var(--tgph-VARIABLE)"
  },
  hover_backgroundColor: {
    cssVar: "--hover_backgroundColor",
    value: "var(--tgph-VARIABLE)",
    interactive: !0
  },
  focus_backgroundColor: {
    cssVar: "--focus_backgroundColor",
    value: "var(--tgph-VARIABLE)",
    interactive: !0
  },
  active_backgroundColor: {
    cssVar: "--active_backgroundColor",
    interactive: !0,
    value: "var(--tgph-VARIABLE)"
  },
  focus_within_backgroundColor: {
    cssVar: "--focus_within_backgroundColor",
    interactive: !0,
    value: "var(--tgph-VARIABLE)"
  },
  borderStyle: {
    cssVar: "--border-style",
    value: "var(--tgph-border-style-VARIABLE)"
  },
  padding: {
    cssVar: "--padding",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "all"
  },
  paddingX: {
    cssVar: "--padding",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "x"
  },
  paddingY: {
    cssVar: "--padding",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "y"
  },
  paddingTop: {
    cssVar: "--padding",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "top"
  },
  paddingBottom: {
    cssVar: "--padding",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "bottom"
  },
  paddingLeft: {
    cssVar: "--padding",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "left"
  },
  paddingRight: {
    cssVar: "--padding",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "right"
  },
  margin: {
    cssVar: "--margin",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "all"
  },
  marginX: {
    cssVar: "--margin",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "x"
  },
  marginY: {
    cssVar: "--margin",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "y"
  },
  marginTop: {
    cssVar: "--margin",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "top"
  },
  marginBottom: {
    cssVar: "--margin",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "bottom"
  },
  marginLeft: {
    cssVar: "--margin",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "left"
  },
  marginRight: {
    cssVar: "--margin",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "right"
  },
  borderColor: {
    cssVar: "--border-color",
    value: "var(--tgph-VARIABLE)"
  },
  hover_borderColor: {
    cssVar: "--hover_borderColor",
    value: "var(--tgph-VARIABLE)",
    interactive: !0
  },
  focus_borderColor: {
    cssVar: "--focus_borderColor",
    value: "var(--tgph-VARIABLE)",
    interactive: !0
  },
  focus_within_borderColor: {
    cssVar: "--focus_within_borderColor",
    interactive: !0,
    value: "var(--tgph-VARIABLE)"
  },
  active_borderColor: {
    cssVar: "--active_borderColor",
    interactive: !0,
    value: "var(--tgph-VARIABLE)"
  },
  borderTopColor: {
    cssVar: "--border-color",
    value: "var(--tgph-VARIABLE)",
    direction: "top"
  },
  borderBottomColor: {
    cssVar: "--border-color",
    value: "var(--tgph-VARIABLE)",
    direction: "bottom"
  },
  borderLeftColor: {
    cssVar: "--border-color",
    value: "var(--tgph-VARIABLE)",
    direction: "left"
  },
  borderRightColor: {
    cssVar: "--border-color",
    value: "var(--tgph-VARIABLE)",
    direction: "right"
  },
  borderWidth: {
    cssVar: "--border-width",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  borderTopWidth: {
    cssVar: "--border-width",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "top"
  },
  borderBottomWidth: {
    cssVar: "--border-width",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "bottom"
  },
  borderLeftWidth: {
    cssVar: "--border-width",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "left"
  },
  borderRightWidth: {
    cssVar: "--border-width",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "right"
  },
  borderRadius: {
    cssVar: "--border-radius",
    value: "var(--tgph-rounded-VARIABLE)"
  },
  borderTopLeftRadius: {
    cssVar: "--border-radius",
    value: "var(--tgph-rounded-VARIABLE)",
    direction: "top"
  },
  borderTopRightRadius: {
    cssVar: "--border-radius",
    value: "var(--tgph-rounded-VARIABLE)",
    direction: "right"
  },
  borderBottomLeftRadius: {
    cssVar: "--border-radius",
    value: "var(--tgph-rounded-VARIABLE)",
    direction: "left"
  },
  borderBottomRightRadius: {
    cssVar: "--border-radius",
    value: "var(--tgph-rounded-VARIABLE)",
    direction: "bottom"
  },
  borderTopRadius: {
    cssVar: "--border-radius",
    value: "var(--tgph-rounded-VARIABLE)",
    direction: "side-top"
  },
  borderBottomRadius: {
    cssVar: "--border-radius",
    value: "var(--tgph-rounded-VARIABLE)",
    direction: "side-bottom"
  },
  borderLeftRadius: {
    cssVar: "--border-radius",
    value: "var(--tgph-rounded-VARIABLE)",
    direction: "side-left"
  },
  borderRightRadius: {
    cssVar: "--border-radius",
    value: "var(--tgph-rounded-VARIABLE)",
    direction: "side-right"
  },
  boxShadow: {
    cssVar: "--box-shadow",
    value: "var(--tgph-shadow-VARIABLE)"
  },
  width: {
    cssVar: "--width",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  height: {
    cssVar: "--height",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  minWidth: {
    cssVar: "--min-width",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  minHeight: {
    cssVar: "--min-height",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  maxWidth: {
    cssVar: "--max-width",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  maxHeight: {
    cssVar: "--max-height",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  zIndex: {
    cssVar: "--z-index",
    value: "var(--tgph-zIndex-VARIABLE)"
  },
  position: {
    cssVar: "--position",
    value: "VARIABLE"
  },
  top: {
    cssVar: "--top",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  left: {
    cssVar: "--left",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  right: {
    cssVar: "--right",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  bottom: {
    cssVar: "--bottom",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  overflow: {
    cssVar: "--overflow",
    value: "VARIABLE"
  },
  overflowX: {
    cssVar: "--overflow-x",
    value: "VARIABLE"
  },
  overflowY: {
    cssVar: "--overflow-y",
    value: "VARIABLE"
  },
  alignSelf: {
    cssVar: "--align-self",
    value: "VARIABLE"
  }
}, jG = {
  border: De.borderWidth,
  borderX: De.borderLeftWidth,
  borderY: De.borderTopWidth,
  bg: De.backgroundColor,
  p: De.padding,
  m: De.margin,
  px: De.paddingX,
  py: De.paddingY,
  pt: De.paddingTop,
  pb: De.paddingBottom,
  pl: De.paddingLeft,
  pr: De.paddingRight,
  mx: De.marginX,
  my: De.marginY,
  mt: De.marginTop,
  mb: De.marginBottom,
  ml: De.marginLeft,
  mr: De.marginRight,
  shadow: De.boxShadow,
  w: De.width,
  h: De.height,
  minW: De.minWidth,
  minH: De.minHeight,
  maxW: De.maxWidth,
  maxH: De.maxHeight,
  rounded: De.borderRadius,
  roundedTopLeft: De.borderTopLeftRadius,
  roundedTopRight: De.borderTopRightRadius,
  roundedBottomLeft: De.borderBottomLeftRadius,
  roundedBottomRight: De.borderBottomRightRadius,
  roundedTop: De.borderTopRadius,
  roundedBottom: De.borderBottomRadius,
  roundedLeft: De.borderLeftRadius,
  roundedRight: De.borderRightRadius,
  borderTop: De.borderTopWidth,
  borderBottom: De.borderBottomWidth,
  borderLeft: De.borderLeftWidth,
  borderRight: De.borderRightWidth
}, FG = {
  ...De,
  ...jG
}, lw = ({
  as: e,
  className: t,
  tgphRef: n,
  children: r,
  ...i
}) => {
  const s = e || "div", { styleProp: l, otherProps: u, interactive: d } = Wt({
    props: i,
    cssVars: FG
  });
  return /* @__PURE__ */ I.jsx(
    s,
    {
      className: Se(
        "tgph-box",
        d && "tgph-box--interactive",
        t
      ),
      style: l,
      ...u,
      ref: n,
      children: r
    }
  );
}, UG = {
  flexDirection: {
    cssVar: "--direction",
    value: "VARIABLE"
  },
  flexWrap: {
    cssVar: "--wrap",
    value: "VARIABLE"
  },
  justifyContent: {
    cssVar: "--justify",
    value: "VARIABLE"
  },
  alignItems: {
    cssVar: "--align",
    value: "VARIABLE"
  },
  gap: {
    cssVar: "--gap",
    value: "var(--tgph-spacing-VARIABLE)"
  }
}, WG = {
  direction: {
    cssVar: "--direction",
    value: "VARIABLE"
  },
  align: {
    cssVar: "--align",
    value: "VARIABLE"
  },
  justify: {
    cssVar: "--justify",
    value: "VARIABLE"
  },
  wrap: {
    cssVar: "--wrap",
    value: "VARIABLE"
  }
}, zG = {
  ...UG,
  ...WG
}, Us = ({
  className: e,
  ...t
}) => {
  const { styleProp: n, otherProps: r } = Wt({
    props: t,
    cssVars: zG
  });
  return /* @__PURE__ */ I.jsx(
    lw,
    {
      className: Se("tgph-stack", e),
      style: n,
      ...r
    }
  );
};
function Y_(e) {
  const t = e + "CollectionProvider", [n, r] = Ys(t), [i, s] = n(
    t,
    { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
  ), l = (b) => {
    const { scope: A, children: x } = b, R = j.useRef(null), _ = j.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ I.jsx(i, { scope: A, itemMap: _, collectionRef: R, children: x });
  };
  l.displayName = t;
  const u = e + "CollectionSlot", d = /* @__PURE__ */ Bs(u), h = j.forwardRef(
    (b, A) => {
      const { scope: x, children: R } = b, _ = s(u, x), L = wt(A, _.collectionRef);
      return /* @__PURE__ */ I.jsx(d, { ref: L, children: R });
    }
  );
  h.displayName = u;
  const f = e + "CollectionItemSlot", m = "data-radix-collection-item", g = /* @__PURE__ */ Bs(f), w = j.forwardRef(
    (b, A) => {
      const { scope: x, children: R, ..._ } = b, L = j.useRef(null), V = wt(A, L), O = s(f, x);
      return j.useEffect(() => (O.itemMap.set(L, { ref: L, ..._ }), () => void O.itemMap.delete(L))), /* @__PURE__ */ I.jsx(g, { [m]: "", ref: V, children: R });
    }
  );
  w.displayName = f;
  function E(b) {
    const A = s(e + "CollectionConsumer", b);
    return j.useCallback(() => {
      const R = A.collectionRef.current;
      if (!R) return [];
      const _ = Array.from(R.querySelectorAll(`[${m}]`));
      return Array.from(A.itemMap.values()).sort(
        (O, D) => _.indexOf(O.ref.current) - _.indexOf(D.ref.current)
      );
    }, [A.collectionRef, A.itemMap]);
  }
  return [
    { Provider: l, Slot: h, ItemSlot: w },
    E,
    r
  ];
}
var HG = C.createContext(void 0);
function q_(e) {
  const t = C.useContext(HG);
  return e || t || "ltr";
}
var _m = "rovingFocusGroup.onEntryFocus", KG = { bubbles: !1, cancelable: !0 }, Cu = "RovingFocusGroup", [Jg, X_, GG] = Y_(Cu), [YG, Z_] = Ys(
  Cu,
  [GG]
), [qG, XG] = YG(Cu), Q_ = C.forwardRef(
  (e, t) => /* @__PURE__ */ I.jsx(Jg.Provider, { scope: e.__scopeRovingFocusGroup, children: /* @__PURE__ */ I.jsx(Jg.Slot, { scope: e.__scopeRovingFocusGroup, children: /* @__PURE__ */ I.jsx(ZG, { ...e, ref: t }) }) })
);
Q_.displayName = Cu;
var ZG = C.forwardRef((e, t) => {
  const {
    __scopeRovingFocusGroup: n,
    orientation: r,
    loop: i = !1,
    dir: s,
    currentTabStopId: l,
    defaultCurrentTabStopId: u,
    onCurrentTabStopIdChange: d,
    onEntryFocus: h,
    preventScrollOnEntryFocus: f = !1,
    ...m
  } = e, g = C.useRef(null), w = wt(t, g), E = q_(s), [b, A] = Zs({
    prop: l,
    defaultProp: u ?? null,
    onChange: d,
    caller: Cu
  }), [x, R] = C.useState(!1), _ = Mr(h), L = X_(n), V = C.useRef(!1), [O, D] = C.useState(0);
  return C.useEffect(() => {
    const B = g.current;
    if (B)
      return B.addEventListener(_m, _), () => B.removeEventListener(_m, _);
  }, [_]), /* @__PURE__ */ I.jsx(
    qG,
    {
      scope: n,
      orientation: r,
      dir: E,
      loop: i,
      currentTabStopId: b,
      onItemFocus: C.useCallback(
        (B) => A(B),
        [A]
      ),
      onItemShiftTab: C.useCallback(() => R(!0), []),
      onFocusableItemAdd: C.useCallback(
        () => D((B) => B + 1),
        []
      ),
      onFocusableItemRemove: C.useCallback(
        () => D((B) => B - 1),
        []
      ),
      children: /* @__PURE__ */ I.jsx(
        ut.div,
        {
          tabIndex: x || O === 0 ? -1 : 0,
          "data-orientation": r,
          ...m,
          ref: w,
          style: { outline: "none", ...e.style },
          onMouseDown: Le(e.onMouseDown, () => {
            V.current = !0;
          }),
          onFocus: Le(e.onFocus, (B) => {
            const H = !V.current;
            if (B.target === B.currentTarget && H && !x) {
              const J = new CustomEvent(_m, KG);
              if (B.currentTarget.dispatchEvent(J), !J.defaultPrevented) {
                const ce = L().filter((Y) => Y.focusable), fe = ce.find((Y) => Y.active), de = ce.find((Y) => Y.id === b), le = [fe, de, ...ce].filter(
                  Boolean
                ).map((Y) => Y.ref.current);
                tI(le, f);
              }
            }
            V.current = !1;
          }),
          onBlur: Le(e.onBlur, () => R(!1))
        }
      )
    }
  );
}), J_ = "RovingFocusGroupItem", eI = C.forwardRef(
  (e, t) => {
    const {
      __scopeRovingFocusGroup: n,
      focusable: r = !0,
      active: i = !1,
      tabStopId: s,
      children: l,
      ...u
    } = e, d = Rl(), h = s || d, f = XG(J_, n), m = f.currentTabStopId === h, g = X_(n), { onFocusableItemAdd: w, onFocusableItemRemove: E, currentTabStopId: b } = f;
    return C.useEffect(() => {
      if (r)
        return w(), () => E();
    }, [r, w, E]), /* @__PURE__ */ I.jsx(
      Jg.ItemSlot,
      {
        scope: n,
        id: h,
        focusable: r,
        active: i,
        children: /* @__PURE__ */ I.jsx(
          ut.span,
          {
            tabIndex: m ? 0 : -1,
            "data-orientation": f.orientation,
            ...u,
            ref: t,
            onMouseDown: Le(e.onMouseDown, (A) => {
              r ? f.onItemFocus(h) : A.preventDefault();
            }),
            onFocus: Le(e.onFocus, () => f.onItemFocus(h)),
            onKeyDown: Le(e.onKeyDown, (A) => {
              if (A.key === "Tab" && A.shiftKey) {
                f.onItemShiftTab();
                return;
              }
              if (A.target !== A.currentTarget) return;
              const x = eY(A, f.orientation, f.dir);
              if (x !== void 0) {
                if (A.metaKey || A.ctrlKey || A.altKey || A.shiftKey) return;
                A.preventDefault();
                let _ = g().filter((L) => L.focusable).map((L) => L.ref.current);
                if (x === "last") _.reverse();
                else if (x === "prev" || x === "next") {
                  x === "prev" && _.reverse();
                  const L = _.indexOf(A.currentTarget);
                  _ = f.loop ? tY(_, L + 1) : _.slice(L + 1);
                }
                setTimeout(() => tI(_));
              }
            }),
            children: typeof l == "function" ? l({ isCurrentTabStop: m, hasTabStop: b != null }) : l
          }
        )
      }
    );
  }
);
eI.displayName = J_;
var QG = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function JG(e, t) {
  return t !== "rtl" ? e : e === "ArrowLeft" ? "ArrowRight" : e === "ArrowRight" ? "ArrowLeft" : e;
}
function eY(e, t, n) {
  const r = JG(e.key, n);
  if (!(t === "vertical" && ["ArrowLeft", "ArrowRight"].includes(r)) && !(t === "horizontal" && ["ArrowUp", "ArrowDown"].includes(r)))
    return QG[r];
}
function tI(e, t = !1) {
  const n = document.activeElement;
  for (const r of e)
    if (r === n || (r.focus({ preventScroll: t }), document.activeElement !== n)) return;
}
function tY(e, t) {
  return e.map((n, r) => e[(t + r) % e.length]);
}
var nY = Q_, rY = eI, ev = ["Enter", " "], iY = ["ArrowDown", "PageUp", "Home"], nI = ["ArrowUp", "PageDown", "End"], oY = [...iY, ...nI], sY = {
  ltr: [...ev, "ArrowRight"],
  rtl: [...ev, "ArrowLeft"]
}, aY = {
  ltr: ["ArrowLeft"],
  rtl: ["ArrowRight"]
}, Eu = "Menu", [ql, lY, uY] = Y_(Eu), [So] = Ys(Eu, [
  uY,
  wf,
  Z_
]), Of = wf(), rI = Z_(), [cY, ca] = So(Eu), [dY, Au] = So(Eu), iI = (e) => {
  const { __scopeMenu: t, open: n = !1, children: r, dir: i, onOpenChange: s, modal: l = !0 } = e, u = Of(t), [d, h] = C.useState(null), f = C.useRef(!1), m = Mr(s), g = q_(i);
  return C.useEffect(() => {
    const w = () => {
      f.current = !0, document.addEventListener("pointerdown", E, { capture: !0, once: !0 }), document.addEventListener("pointermove", E, { capture: !0, once: !0 });
    }, E = () => f.current = !1;
    return document.addEventListener("keydown", w, { capture: !0 }), () => {
      document.removeEventListener("keydown", w, { capture: !0 }), document.removeEventListener("pointerdown", E, { capture: !0 }), document.removeEventListener("pointermove", E, { capture: !0 });
    };
  }, []), /* @__PURE__ */ I.jsx(wT, { ...u, children: /* @__PURE__ */ I.jsx(
    cY,
    {
      scope: t,
      open: n,
      onOpenChange: m,
      content: d,
      onContentChange: h,
      children: /* @__PURE__ */ I.jsx(
        dY,
        {
          scope: t,
          onClose: C.useCallback(() => m(!1), [m]),
          isUsingKeyboardRef: f,
          dir: g,
          modal: l,
          children: r
        }
      )
    }
  ) });
};
iI.displayName = Eu;
var fY = "MenuAnchor", uw = C.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e, i = Of(n);
    return /* @__PURE__ */ I.jsx(bT, { ...i, ...r, ref: t });
  }
);
uw.displayName = fY;
var hY = "MenuPortal", [jie, oI] = So(hY, {
  forceMount: void 0
}), $n = "MenuContent", [pY, cw] = So($n), sI = C.forwardRef(
  (e, t) => {
    const n = oI($n, e.__scopeMenu), { forceMount: r = n.forceMount, ...i } = e, s = ca($n, e.__scopeMenu), l = Au($n, e.__scopeMenu);
    return /* @__PURE__ */ I.jsx(ql.Provider, { scope: e.__scopeMenu, children: /* @__PURE__ */ I.jsx(Ur, { present: r || s.open, children: /* @__PURE__ */ I.jsx(ql.Slot, { scope: e.__scopeMenu, children: l.modal ? /* @__PURE__ */ I.jsx(mY, { ...i, ref: t }) : /* @__PURE__ */ I.jsx(gY, { ...i, ref: t }) }) }) });
  }
), mY = C.forwardRef(
  (e, t) => {
    const n = ca($n, e.__scopeMenu), r = C.useRef(null), i = wt(t, r);
    return C.useEffect(() => {
      const s = r.current;
      if (s) return C_(s);
    }, []), /* @__PURE__ */ I.jsx(
      dw,
      {
        ...e,
        ref: i,
        trapFocus: n.open,
        disableOutsidePointerEvents: n.open,
        disableOutsideScroll: !0,
        onFocusOutside: Le(
          e.onFocusOutside,
          (s) => s.preventDefault(),
          { checkForDefaultPrevented: !1 }
        ),
        onDismiss: () => n.onOpenChange(!1)
      }
    );
  }
), gY = C.forwardRef((e, t) => {
  const n = ca($n, e.__scopeMenu);
  return /* @__PURE__ */ I.jsx(
    dw,
    {
      ...e,
      ref: t,
      trapFocus: !1,
      disableOutsidePointerEvents: !1,
      disableOutsideScroll: !1,
      onDismiss: () => n.onOpenChange(!1)
    }
  );
}), vY = /* @__PURE__ */ Bs("MenuContent.ScrollLock"), dw = C.forwardRef(
  (e, t) => {
    const {
      __scopeMenu: n,
      loop: r = !1,
      trapFocus: i,
      onOpenAutoFocus: s,
      onCloseAutoFocus: l,
      disableOutsidePointerEvents: u,
      onEntryFocus: d,
      onEscapeKeyDown: h,
      onPointerDownOutside: f,
      onFocusOutside: m,
      onInteractOutside: g,
      onDismiss: w,
      disableOutsideScroll: E,
      ...b
    } = e, A = ca($n, n), x = Au($n, n), R = Of(n), _ = rI(n), L = lY(n), [V, O] = C.useState(null), D = C.useRef(null), B = wt(t, D, A.onContentChange), H = C.useRef(0), J = C.useRef(""), ce = C.useRef(0), fe = C.useRef(null), de = C.useRef("right"), he = C.useRef(0), le = E ? K0 : C.Fragment, Y = E ? { as: vY, allowPinchZoom: !0 } : void 0, te = (T) => {
      var q, re;
      const P = J.current + T, $ = L().filter((ve) => !ve.disabled), M = document.activeElement, W = (q = $.find((ve) => ve.ref.current === M)) == null ? void 0 : q.textValue, G = $.map((ve) => ve.textValue), ee = NY(G, P, W), Q = (re = $.find((ve) => ve.textValue === ee)) == null ? void 0 : re.ref.current;
      (function ve(Ce) {
        J.current = Ce, window.clearTimeout(H.current), Ce !== "" && (H.current = window.setTimeout(() => ve(""), 1e3));
      })(P), Q && setTimeout(() => Q.focus());
    };
    C.useEffect(() => () => window.clearTimeout(H.current), []), f_();
    const S = C.useCallback((T) => {
      var $, M;
      return de.current === (($ = fe.current) == null ? void 0 : $.side) && jY(T, (M = fe.current) == null ? void 0 : M.area);
    }, []);
    return /* @__PURE__ */ I.jsx(
      pY,
      {
        scope: n,
        searchRef: J,
        onItemEnter: C.useCallback(
          (T) => {
            S(T) && T.preventDefault();
          },
          [S]
        ),
        onItemLeave: C.useCallback(
          (T) => {
            var P;
            S(T) || ((P = D.current) == null || P.focus(), O(null));
          },
          [S]
        ),
        onTriggerLeave: C.useCallback(
          (T) => {
            S(T) && T.preventDefault();
          },
          [S]
        ),
        pointerGraceTimerRef: ce,
        onPointerGraceIntentChange: C.useCallback((T) => {
          fe.current = T;
        }, []),
        children: /* @__PURE__ */ I.jsx(le, { ...Y, children: /* @__PURE__ */ I.jsx(
          H0,
          {
            asChild: !0,
            trapped: i,
            onMountAutoFocus: Le(s, (T) => {
              var P;
              T.preventDefault(), (P = D.current) == null || P.focus({ preventScroll: !0 });
            }),
            onUnmountAutoFocus: l,
            children: /* @__PURE__ */ I.jsx(
              fu,
              {
                asChild: !0,
                disableOutsidePointerEvents: u,
                onEscapeKeyDown: h,
                onPointerDownOutside: f,
                onFocusOutside: m,
                onInteractOutside: g,
                onDismiss: w,
                children: /* @__PURE__ */ I.jsx(
                  nY,
                  {
                    asChild: !0,
                    ..._,
                    dir: x.dir,
                    orientation: "vertical",
                    loop: r,
                    currentTabStopId: V,
                    onCurrentTabStopIdChange: O,
                    onEntryFocus: Le(d, (T) => {
                      x.isUsingKeyboardRef.current || T.preventDefault();
                    }),
                    preventScrollOnEntryFocus: !0,
                    children: /* @__PURE__ */ I.jsx(
                      CT,
                      {
                        role: "menu",
                        "aria-orientation": "vertical",
                        "data-state": pI(A.open),
                        "data-radix-menu-content": "",
                        dir: x.dir,
                        ...R,
                        ...b,
                        ref: B,
                        style: { outline: "none", ...b.style },
                        onKeyDown: Le(b.onKeyDown, (T) => {
                          const $ = T.target.closest("[data-radix-menu-content]") === T.currentTarget, M = T.ctrlKey || T.altKey || T.metaKey, W = T.key.length === 1;
                          $ && (T.key === "Tab" && T.preventDefault(), !M && W && te(T.key));
                          const G = D.current;
                          if (T.target !== G || !oY.includes(T.key)) return;
                          T.preventDefault();
                          const Q = L().filter((q) => !q.disabled).map((q) => q.ref.current);
                          nI.includes(T.key) && Q.reverse(), OY(Q);
                        }),
                        onBlur: Le(e.onBlur, (T) => {
                          T.currentTarget.contains(T.target) || (window.clearTimeout(H.current), J.current = "");
                        }),
                        onPointerMove: Le(
                          e.onPointerMove,
                          Xl((T) => {
                            const P = T.target, $ = he.current !== T.clientX;
                            if (T.currentTarget.contains(P) && $) {
                              const M = T.clientX > he.current ? "right" : "left";
                              de.current = M, he.current = T.clientX;
                            }
                          })
                        )
                      }
                    )
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
sI.displayName = $n;
var yY = "MenuGroup", aI = C.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e;
    return /* @__PURE__ */ I.jsx(ut.div, { role: "group", ...r, ref: t });
  }
);
aI.displayName = yY;
var wY = "MenuLabel", bY = C.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e;
    return /* @__PURE__ */ I.jsx(ut.div, { ...r, ref: t });
  }
);
bY.displayName = wY;
var Gd = "MenuItem", Gx = "menu.itemSelect", Bf = C.forwardRef(
  (e, t) => {
    const { disabled: n = !1, onSelect: r, ...i } = e, s = C.useRef(null), l = Au(Gd, e.__scopeMenu), u = cw(Gd, e.__scopeMenu), d = wt(t, s), h = C.useRef(!1), f = () => {
      const m = s.current;
      if (!n && m) {
        const g = new CustomEvent(Gx, { bubbles: !0, cancelable: !0 });
        m.addEventListener(Gx, (w) => r == null ? void 0 : r(w), { once: !0 }), qR(m, g), g.defaultPrevented ? h.current = !1 : l.onClose();
      }
    };
    return /* @__PURE__ */ I.jsx(
      lI,
      {
        ...i,
        ref: d,
        disabled: n,
        onClick: Le(e.onClick, f),
        onPointerDown: (m) => {
          var g;
          (g = e.onPointerDown) == null || g.call(e, m), h.current = !0;
        },
        onPointerUp: Le(e.onPointerUp, (m) => {
          var g;
          h.current || (g = m.currentTarget) == null || g.click();
        }),
        onKeyDown: Le(e.onKeyDown, (m) => {
          const g = u.searchRef.current !== "";
          n || g && m.key === " " || ev.includes(m.key) && (m.currentTarget.click(), m.preventDefault());
        })
      }
    );
  }
);
Bf.displayName = Gd;
var lI = C.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, disabled: r = !1, textValue: i, ...s } = e, l = cw(Gd, n), u = rI(n), d = C.useRef(null), h = wt(t, d), [f, m] = C.useState(!1), [g, w] = C.useState("");
    return C.useEffect(() => {
      const E = d.current;
      E && w((E.textContent ?? "").trim());
    }, [s.children]), /* @__PURE__ */ I.jsx(
      ql.ItemSlot,
      {
        scope: n,
        disabled: r,
        textValue: i ?? g,
        children: /* @__PURE__ */ I.jsx(rY, { asChild: !0, ...u, focusable: !r, children: /* @__PURE__ */ I.jsx(
          ut.div,
          {
            role: "menuitem",
            "data-highlighted": f ? "" : void 0,
            "aria-disabled": r || void 0,
            "data-disabled": r ? "" : void 0,
            ...s,
            ref: h,
            onPointerMove: Le(
              e.onPointerMove,
              Xl((E) => {
                r ? l.onItemLeave(E) : (l.onItemEnter(E), E.defaultPrevented || E.currentTarget.focus({ preventScroll: !0 }));
              })
            ),
            onPointerLeave: Le(
              e.onPointerLeave,
              Xl((E) => l.onItemLeave(E))
            ),
            onFocus: Le(e.onFocus, () => m(!0)),
            onBlur: Le(e.onBlur, () => m(!1))
          }
        ) })
      }
    );
  }
), CY = "MenuCheckboxItem", EY = C.forwardRef(
  (e, t) => {
    const { checked: n = !1, onCheckedChange: r, ...i } = e;
    return /* @__PURE__ */ I.jsx(dI, { scope: e.__scopeMenu, checked: n, children: /* @__PURE__ */ I.jsx(
      Bf,
      {
        role: "menuitemcheckbox",
        "aria-checked": Yd(n) ? "mixed" : n,
        ...i,
        ref: t,
        "data-state": hw(n),
        onSelect: Le(
          i.onSelect,
          () => r == null ? void 0 : r(Yd(n) ? !0 : !n),
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
);
EY.displayName = CY;
var uI = "MenuRadioGroup", [AY, xY] = So(
  uI,
  { value: void 0, onValueChange: () => {
  } }
), SY = C.forwardRef(
  (e, t) => {
    const { value: n, onValueChange: r, ...i } = e, s = Mr(r);
    return /* @__PURE__ */ I.jsx(AY, { scope: e.__scopeMenu, value: n, onValueChange: s, children: /* @__PURE__ */ I.jsx(aI, { ...i, ref: t }) });
  }
);
SY.displayName = uI;
var cI = "MenuRadioItem", kY = C.forwardRef(
  (e, t) => {
    const { value: n, ...r } = e, i = xY(cI, e.__scopeMenu), s = n === i.value;
    return /* @__PURE__ */ I.jsx(dI, { scope: e.__scopeMenu, checked: s, children: /* @__PURE__ */ I.jsx(
      Bf,
      {
        role: "menuitemradio",
        "aria-checked": s,
        ...r,
        ref: t,
        "data-state": hw(s),
        onSelect: Le(
          r.onSelect,
          () => {
            var l;
            return (l = i.onValueChange) == null ? void 0 : l.call(i, n);
          },
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
);
kY.displayName = cI;
var fw = "MenuItemIndicator", [dI, RY] = So(
  fw,
  { checked: !1 }
), TY = C.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, forceMount: r, ...i } = e, s = RY(fw, n);
    return /* @__PURE__ */ I.jsx(
      Ur,
      {
        present: r || Yd(s.checked) || s.checked === !0,
        children: /* @__PURE__ */ I.jsx(
          ut.span,
          {
            ...i,
            ref: t,
            "data-state": hw(s.checked)
          }
        )
      }
    );
  }
);
TY.displayName = fw;
var $Y = "MenuSeparator", VY = C.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e;
    return /* @__PURE__ */ I.jsx(
      ut.div,
      {
        role: "separator",
        "aria-orientation": "horizontal",
        ...r,
        ref: t
      }
    );
  }
);
VY.displayName = $Y;
var _Y = "MenuArrow", IY = C.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e, i = Of(n);
    return /* @__PURE__ */ I.jsx(ET, { ...i, ...r, ref: t });
  }
);
IY.displayName = _Y;
var LY = "MenuSub", [Fie, fI] = So(LY), bl = "MenuSubTrigger", PY = C.forwardRef(
  (e, t) => {
    const n = ca(bl, e.__scopeMenu), r = Au(bl, e.__scopeMenu), i = fI(bl, e.__scopeMenu), s = cw(bl, e.__scopeMenu), l = C.useRef(null), { pointerGraceTimerRef: u, onPointerGraceIntentChange: d } = s, h = { __scopeMenu: e.__scopeMenu }, f = C.useCallback(() => {
      l.current && window.clearTimeout(l.current), l.current = null;
    }, []);
    return C.useEffect(() => f, [f]), C.useEffect(() => {
      const m = u.current;
      return () => {
        window.clearTimeout(m), d(null);
      };
    }, [u, d]), /* @__PURE__ */ I.jsx(uw, { asChild: !0, ...h, children: /* @__PURE__ */ I.jsx(
      lI,
      {
        id: i.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": n.open,
        "aria-controls": i.contentId,
        "data-state": pI(n.open),
        ...e,
        ref: pf(t, i.onTriggerChange),
        onClick: (m) => {
          var g;
          (g = e.onClick) == null || g.call(e, m), !(e.disabled || m.defaultPrevented) && (m.currentTarget.focus(), n.open || n.onOpenChange(!0));
        },
        onPointerMove: Le(
          e.onPointerMove,
          Xl((m) => {
            s.onItemEnter(m), !m.defaultPrevented && !e.disabled && !n.open && !l.current && (s.onPointerGraceIntentChange(null), l.current = window.setTimeout(() => {
              n.onOpenChange(!0), f();
            }, 100));
          })
        ),
        onPointerLeave: Le(
          e.onPointerLeave,
          Xl((m) => {
            var w, E;
            f();
            const g = (w = n.content) == null ? void 0 : w.getBoundingClientRect();
            if (g) {
              const b = (E = n.content) == null ? void 0 : E.dataset.side, A = b === "right", x = A ? -5 : 5, R = g[A ? "left" : "right"], _ = g[A ? "right" : "left"];
              s.onPointerGraceIntentChange({
                area: [
                  // Apply a bleed on clientX to ensure that our exit point is
                  // consistently within polygon bounds
                  { x: m.clientX + x, y: m.clientY },
                  { x: R, y: g.top },
                  { x: _, y: g.top },
                  { x: _, y: g.bottom },
                  { x: R, y: g.bottom }
                ],
                side: b
              }), window.clearTimeout(u.current), u.current = window.setTimeout(
                () => s.onPointerGraceIntentChange(null),
                300
              );
            } else {
              if (s.onTriggerLeave(m), m.defaultPrevented) return;
              s.onPointerGraceIntentChange(null);
            }
          })
        ),
        onKeyDown: Le(e.onKeyDown, (m) => {
          var w;
          const g = s.searchRef.current !== "";
          e.disabled || g && m.key === " " || sY[r.dir].includes(m.key) && (n.onOpenChange(!0), (w = n.content) == null || w.focus(), m.preventDefault());
        })
      }
    ) });
  }
);
PY.displayName = bl;
var hI = "MenuSubContent", MY = C.forwardRef(
  (e, t) => {
    const n = oI($n, e.__scopeMenu), { forceMount: r = n.forceMount, ...i } = e, s = ca($n, e.__scopeMenu), l = Au($n, e.__scopeMenu), u = fI(hI, e.__scopeMenu), d = C.useRef(null), h = wt(t, d);
    return /* @__PURE__ */ I.jsx(ql.Provider, { scope: e.__scopeMenu, children: /* @__PURE__ */ I.jsx(Ur, { present: r || s.open, children: /* @__PURE__ */ I.jsx(ql.Slot, { scope: e.__scopeMenu, children: /* @__PURE__ */ I.jsx(
      dw,
      {
        id: u.contentId,
        "aria-labelledby": u.triggerId,
        ...i,
        ref: h,
        align: "start",
        side: l.dir === "rtl" ? "left" : "right",
        disableOutsidePointerEvents: !1,
        disableOutsideScroll: !1,
        trapFocus: !1,
        onOpenAutoFocus: (f) => {
          var m;
          l.isUsingKeyboardRef.current && ((m = d.current) == null || m.focus()), f.preventDefault();
        },
        onCloseAutoFocus: (f) => f.preventDefault(),
        onFocusOutside: Le(e.onFocusOutside, (f) => {
          f.target !== u.trigger && s.onOpenChange(!1);
        }),
        onEscapeKeyDown: Le(e.onEscapeKeyDown, (f) => {
          l.onClose(), f.preventDefault();
        }),
        onKeyDown: Le(e.onKeyDown, (f) => {
          var w;
          const m = f.currentTarget.contains(f.target), g = aY[l.dir].includes(f.key);
          m && g && (s.onOpenChange(!1), (w = u.trigger) == null || w.focus(), f.preventDefault());
        })
      }
    ) }) }) });
  }
);
MY.displayName = hI;
function pI(e) {
  return e ? "open" : "closed";
}
function Yd(e) {
  return e === "indeterminate";
}
function hw(e) {
  return Yd(e) ? "indeterminate" : e ? "checked" : "unchecked";
}
function OY(e) {
  const t = document.activeElement;
  for (const n of e)
    if (n === t || (n.focus(), document.activeElement !== t)) return;
}
function BY(e, t) {
  return e.map((n, r) => e[(t + r) % e.length]);
}
function NY(e, t, n) {
  const i = t.length > 1 && Array.from(t).every((h) => h === t[0]) ? t[0] : t, s = n ? e.indexOf(n) : -1;
  let l = BY(e, Math.max(s, 0));
  i.length === 1 && (l = l.filter((h) => h !== n));
  const d = l.find(
    (h) => h.toLowerCase().startsWith(i.toLowerCase())
  );
  return d !== n ? d : void 0;
}
function DY(e, t) {
  const { x: n, y: r } = e;
  let i = !1;
  for (let s = 0, l = t.length - 1; s < t.length; l = s++) {
    const u = t[s], d = t[l], h = u.x, f = u.y, m = d.x, g = d.y;
    f > r != g > r && n < (m - h) * (r - f) / (g - f) + h && (i = !i);
  }
  return i;
}
function jY(e, t) {
  if (!t) return !1;
  const n = { x: e.clientX, y: e.clientY };
  return DY(n, t);
}
function Xl(e) {
  return (t) => t.pointerType === "mouse" ? e(t) : void 0;
}
var FY = iI, UY = uw, WY = sI, zY = Bf;
const je = {
  display: {
    cssVar: "--display",
    value: "VARIABLE"
  },
  backgroundColor: {
    cssVar: "--background-color",
    value: "var(--tgph-VARIABLE)"
  },
  hover_backgroundColor: {
    cssVar: "--hover_backgroundColor",
    value: "var(--tgph-VARIABLE)",
    interactive: !0
  },
  focus_backgroundColor: {
    cssVar: "--focus_backgroundColor",
    value: "var(--tgph-VARIABLE)",
    interactive: !0
  },
  active_backgroundColor: {
    cssVar: "--active_backgroundColor",
    interactive: !0,
    value: "var(--tgph-VARIABLE)"
  },
  focus_within_backgroundColor: {
    cssVar: "--focus_within_backgroundColor",
    interactive: !0,
    value: "var(--tgph-VARIABLE)"
  },
  borderStyle: {
    cssVar: "--border-style",
    value: "var(--tgph-border-style-VARIABLE)"
  },
  padding: {
    cssVar: "--padding",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "all"
  },
  paddingX: {
    cssVar: "--padding",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "x"
  },
  paddingY: {
    cssVar: "--padding",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "y"
  },
  paddingTop: {
    cssVar: "--padding",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "top"
  },
  paddingBottom: {
    cssVar: "--padding",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "bottom"
  },
  paddingLeft: {
    cssVar: "--padding",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "left"
  },
  paddingRight: {
    cssVar: "--padding",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "right"
  },
  margin: {
    cssVar: "--margin",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "all"
  },
  marginX: {
    cssVar: "--margin",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "x"
  },
  marginY: {
    cssVar: "--margin",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "y"
  },
  marginTop: {
    cssVar: "--margin",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "top"
  },
  marginBottom: {
    cssVar: "--margin",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "bottom"
  },
  marginLeft: {
    cssVar: "--margin",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "left"
  },
  marginRight: {
    cssVar: "--margin",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "right"
  },
  borderColor: {
    cssVar: "--border-color",
    value: "var(--tgph-VARIABLE)"
  },
  hover_borderColor: {
    cssVar: "--hover_borderColor",
    value: "var(--tgph-VARIABLE)",
    interactive: !0
  },
  focus_borderColor: {
    cssVar: "--focus_borderColor",
    value: "var(--tgph-VARIABLE)",
    interactive: !0
  },
  focus_within_borderColor: {
    cssVar: "--focus_within_borderColor",
    interactive: !0,
    value: "var(--tgph-VARIABLE)"
  },
  active_borderColor: {
    cssVar: "--active_borderColor",
    interactive: !0,
    value: "var(--tgph-VARIABLE)"
  },
  borderTopColor: {
    cssVar: "--border-color",
    value: "var(--tgph-VARIABLE)",
    direction: "top"
  },
  borderBottomColor: {
    cssVar: "--border-color",
    value: "var(--tgph-VARIABLE)",
    direction: "bottom"
  },
  borderLeftColor: {
    cssVar: "--border-color",
    value: "var(--tgph-VARIABLE)",
    direction: "left"
  },
  borderRightColor: {
    cssVar: "--border-color",
    value: "var(--tgph-VARIABLE)",
    direction: "right"
  },
  borderWidth: {
    cssVar: "--border-width",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  borderTopWidth: {
    cssVar: "--border-width",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "top"
  },
  borderBottomWidth: {
    cssVar: "--border-width",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "bottom"
  },
  borderLeftWidth: {
    cssVar: "--border-width",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "left"
  },
  borderRightWidth: {
    cssVar: "--border-width",
    value: "var(--tgph-spacing-VARIABLE)",
    direction: "right"
  },
  borderRadius: {
    cssVar: "--border-radius",
    value: "var(--tgph-rounded-VARIABLE)"
  },
  borderTopLeftRadius: {
    cssVar: "--border-radius",
    value: "var(--tgph-rounded-VARIABLE)",
    direction: "top"
  },
  borderTopRightRadius: {
    cssVar: "--border-radius",
    value: "var(--tgph-rounded-VARIABLE)",
    direction: "right"
  },
  borderBottomLeftRadius: {
    cssVar: "--border-radius",
    value: "var(--tgph-rounded-VARIABLE)",
    direction: "left"
  },
  borderBottomRightRadius: {
    cssVar: "--border-radius",
    value: "var(--tgph-rounded-VARIABLE)",
    direction: "bottom"
  },
  borderTopRadius: {
    cssVar: "--border-radius",
    value: "var(--tgph-rounded-VARIABLE)",
    direction: "side-top"
  },
  borderBottomRadius: {
    cssVar: "--border-radius",
    value: "var(--tgph-rounded-VARIABLE)",
    direction: "side-bottom"
  },
  borderLeftRadius: {
    cssVar: "--border-radius",
    value: "var(--tgph-rounded-VARIABLE)",
    direction: "side-left"
  },
  borderRightRadius: {
    cssVar: "--border-radius",
    value: "var(--tgph-rounded-VARIABLE)",
    direction: "side-right"
  },
  boxShadow: {
    cssVar: "--box-shadow",
    value: "var(--tgph-shadow-VARIABLE)"
  },
  width: {
    cssVar: "--width",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  height: {
    cssVar: "--height",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  minWidth: {
    cssVar: "--min-width",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  minHeight: {
    cssVar: "--min-height",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  maxWidth: {
    cssVar: "--max-width",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  maxHeight: {
    cssVar: "--max-height",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  zIndex: {
    cssVar: "--z-index",
    value: "var(--tgph-zIndex-VARIABLE)"
  },
  position: {
    cssVar: "--position",
    value: "VARIABLE"
  },
  top: {
    cssVar: "--top",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  left: {
    cssVar: "--left",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  right: {
    cssVar: "--right",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  bottom: {
    cssVar: "--bottom",
    value: "var(--tgph-spacing-VARIABLE)"
  },
  overflow: {
    cssVar: "--overflow",
    value: "VARIABLE"
  },
  overflowX: {
    cssVar: "--overflow-x",
    value: "VARIABLE"
  },
  overflowY: {
    cssVar: "--overflow-y",
    value: "VARIABLE"
  },
  alignSelf: {
    cssVar: "--align-self",
    value: "VARIABLE"
  }
}, HY = {
  border: je.borderWidth,
  borderX: je.borderLeftWidth,
  borderY: je.borderTopWidth,
  bg: je.backgroundColor,
  p: je.padding,
  m: je.margin,
  px: je.paddingX,
  py: je.paddingY,
  pt: je.paddingTop,
  pb: je.paddingBottom,
  pl: je.paddingLeft,
  pr: je.paddingRight,
  mx: je.marginX,
  my: je.marginY,
  mt: je.marginTop,
  mb: je.marginBottom,
  ml: je.marginLeft,
  mr: je.marginRight,
  shadow: je.boxShadow,
  w: je.width,
  h: je.height,
  minW: je.minWidth,
  minH: je.minHeight,
  maxW: je.maxWidth,
  maxH: je.maxHeight,
  rounded: je.borderRadius,
  roundedTopLeft: je.borderTopLeftRadius,
  roundedTopRight: je.borderTopRightRadius,
  roundedBottomLeft: je.borderBottomLeftRadius,
  roundedBottomRight: je.borderBottomRightRadius,
  roundedTop: je.borderTopRadius,
  roundedBottom: je.borderBottomRadius,
  roundedLeft: je.borderLeftRadius,
  roundedRight: je.borderRightRadius,
  borderTop: je.borderTopWidth,
  borderBottom: je.borderBottomWidth,
  borderLeft: je.borderLeftWidth,
  borderRight: je.borderRightWidth
}, KY = {
  ...je,
  ...HY
}, mI = ({
  as: e,
  className: t,
  tgphRef: n,
  children: r,
  ...i
}) => {
  const s = e || "div", { styleProp: l, otherProps: u, interactive: d } = Wt({
    props: i,
    cssVars: KY
  });
  return /* @__PURE__ */ I.jsx(
    s,
    {
      className: Se(
        "tgph-box",
        d && "tgph-box--interactive",
        t
      ),
      style: l,
      ...u,
      ref: n,
      children: r
    }
  );
}, GY = {
  flexDirection: {
    cssVar: "--direction",
    value: "VARIABLE"
  },
  flexWrap: {
    cssVar: "--wrap",
    value: "VARIABLE"
  },
  justifyContent: {
    cssVar: "--justify",
    value: "VARIABLE"
  },
  alignItems: {
    cssVar: "--align",
    value: "VARIABLE"
  },
  gap: {
    cssVar: "--gap",
    value: "var(--tgph-spacing-VARIABLE)"
  }
}, YY = {
  direction: {
    cssVar: "--direction",
    value: "VARIABLE"
  },
  align: {
    cssVar: "--align",
    value: "VARIABLE"
  },
  justify: {
    cssVar: "--justify",
    value: "VARIABLE"
  },
  wrap: {
    cssVar: "--wrap",
    value: "VARIABLE"
  }
}, qY = {
  ...GY,
  ...YY
}, gI = ({
  className: e,
  ...t
}) => {
  const { styleProp: n, otherProps: r } = Wt({
    props: t,
    cssVars: qY
  });
  return /* @__PURE__ */ I.jsx(
    mI,
    {
      className: Se("tgph-stack", e),
      style: n,
      ...r
    }
  );
};
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const XY = (e) => e.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), ZY = (e) => e.replace(
  /^([A-Z])|[\s-_]+(\w)/g,
  (t, n, r) => r ? r.toUpperCase() : n.toLowerCase()
), Yx = (e) => {
  const t = ZY(e);
  return t.charAt(0).toUpperCase() + t.slice(1);
}, vI = (...e) => e.filter((t, n, r) => !!t && t.trim() !== "" && r.indexOf(t) === n).join(" ").trim(), QY = (e) => {
  for (const t in e)
    if (t.startsWith("aria-") || t === "role" || t === "title")
      return !0;
};
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
var JY = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round"
};
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const eq = C.forwardRef(
  ({
    color: e = "currentColor",
    size: t = 24,
    strokeWidth: n = 2,
    absoluteStrokeWidth: r,
    className: i = "",
    children: s,
    iconNode: l,
    ...u
  }, d) => C.createElement(
    "svg",
    {
      ref: d,
      ...JY,
      width: t,
      height: t,
      stroke: e,
      strokeWidth: r ? Number(n) * 24 / Number(t) : n,
      className: vI("lucide", i),
      ...!s && !QY(u) && { "aria-hidden": "true" },
      ...u
    },
    [
      ...l.map(([h, f]) => C.createElement(h, f)),
      ...Array.isArray(s) ? s : [s]
    ]
  )
);
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const tq = (e, t) => {
  const n = C.forwardRef(
    ({ className: r, ...i }, s) => C.createElement(eq, {
      ref: s,
      iconNode: t,
      className: vI(
        `lucide-${XY(Yx(e))}`,
        `lucide-${e}`,
        r
      ),
      ...i
    })
  );
  return n.displayName = Yx(e), n;
};
/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const nq = [["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }]], rq = tq("check", nq), iq = C.createContext({});
function oq(e) {
  const t = C.useRef(null);
  return t.current === null && (t.current = e()), t.current;
}
const pw = typeof window < "u", sq = pw ? C.useLayoutEffect : C.useEffect, yI = /* @__PURE__ */ C.createContext(null);
function aq(e, t) {
  e.indexOf(t) === -1 && e.push(t);
}
function lq(e, t) {
  const n = e.indexOf(t);
  n > -1 && e.splice(n, 1);
}
const Co = (e, t, n) => n > t ? t : n < e ? e : n;
let mw = () => {
};
const jr = {}, wI = (e) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(e);
function uq(e) {
  return typeof e == "object" && e !== null;
}
const bI = (e) => /^0[^.\s]+$/u.test(e);
// @__NO_SIDE_EFFECTS__
function gw(e) {
  let t;
  return () => (t === void 0 && (t = e()), t);
}
const da = /* @__NO_SIDE_EFFECTS__ */ (e) => e, cq = (e, t) => (n) => t(e(n)), Nf = (...e) => e.reduce(cq), CI = /* @__NO_SIDE_EFFECTS__ */ (e, t, n) => {
  const r = t - e;
  return r === 0 ? 1 : (n - e) / r;
};
let EI = class {
  constructor() {
    this.subscriptions = [];
  }
  add(t) {
    return aq(this.subscriptions, t), () => lq(this.subscriptions, t);
  }
  notify(t, n, r) {
    const i = this.subscriptions.length;
    if (i)
      if (i === 1)
        this.subscriptions[0](t, n, r);
      else
        for (let s = 0; s < i; s++) {
          const l = this.subscriptions[s];
          l && l(t, n, r);
        }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
};
const $r = /* @__NO_SIDE_EFFECTS__ */ (e) => e * 1e3, Vr = /* @__NO_SIDE_EFFECTS__ */ (e) => e / 1e3;
function AI(e, t) {
  return t ? e * (1e3 / t) : 0;
}
const xI = (e, t, n) => (((1 - 3 * n + 3 * t) * e + (3 * n - 6 * t)) * e + 3 * t) * e, dq = 1e-7, fq = 12;
function hq(e, t, n, r, i) {
  let s, l, u = 0;
  do
    l = t + (n - t) / 2, s = xI(l, r, i) - e, s > 0 ? n = l : t = l;
  while (Math.abs(s) > dq && ++u < fq);
  return l;
}
function xu(e, t, n, r) {
  if (e === t && n === r)
    return da;
  const i = (s) => hq(s, 0, 1, e, n);
  return (s) => s === 0 || s === 1 ? s : xI(i(s), t, r);
}
const SI = (e) => (t) => t <= 0.5 ? e(2 * t) / 2 : (2 - e(2 * (1 - t))) / 2, kI = (e) => (t) => 1 - e(1 - t), RI = /* @__PURE__ */ xu(0.33, 1.53, 0.69, 0.99), vw = /* @__PURE__ */ kI(RI), TI = /* @__PURE__ */ SI(vw), $I = (e) => (e *= 2) < 1 ? 0.5 * vw(e) : 0.5 * (2 - Math.pow(2, -10 * (e - 1))), yw = (e) => 1 - Math.sin(Math.acos(e)), pq = kI(yw), VI = SI(yw), mq = /* @__PURE__ */ xu(0.42, 0, 1, 1), gq = /* @__PURE__ */ xu(0, 0, 0.58, 1), _I = /* @__PURE__ */ xu(0.42, 0, 0.58, 1), vq = (e) => Array.isArray(e) && typeof e[0] != "number", II = (e) => Array.isArray(e) && typeof e[0] == "number", yq = {
  linear: da,
  easeIn: mq,
  easeInOut: _I,
  easeOut: gq,
  circIn: yw,
  circInOut: VI,
  circOut: pq,
  backIn: vw,
  backInOut: TI,
  backOut: RI,
  anticipate: $I
}, wq = (e) => typeof e == "string", qx = (e) => {
  if (II(e)) {
    mw(e.length === 4);
    const [t, n, r, i] = e;
    return xu(t, n, r, i);
  } else if (wq(e))
    return yq[e];
  return e;
}, Jc = [
  "setup",
  // Compute
  "read",
  // Read
  "resolveKeyframes",
  // Write/Read/Write/Read
  "preUpdate",
  // Compute
  "update",
  // Compute
  "preRender",
  // Compute
  "render",
  // Write
  "postRender"
  // Compute
];
function bq(e, t) {
  let n = /* @__PURE__ */ new Set(), r = /* @__PURE__ */ new Set(), i = !1, s = !1;
  const l = /* @__PURE__ */ new WeakSet();
  let u = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  };
  function d(f) {
    l.has(f) && (h.schedule(f), e()), f(u);
  }
  const h = {
    /**
     * Schedule a process to run on the next frame.
     */
    schedule: (f, m = !1, g = !1) => {
      const w = g && i ? n : r;
      return m && l.add(f), w.has(f) || w.add(f), f;
    },
    /**
     * Cancel the provided callback from running on the next frame.
     */
    cancel: (f) => {
      r.delete(f), l.delete(f);
    },
    /**
     * Execute all schedule callbacks.
     */
    process: (f) => {
      if (u = f, i) {
        s = !0;
        return;
      }
      i = !0, [n, r] = [r, n], n.forEach(d), n.clear(), i = !1, s && (s = !1, h.process(f));
    }
  };
  return h;
}
const Cq = 40;
function LI(e, t) {
  let n = !1, r = !0;
  const i = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  }, s = () => n = !0, l = Jc.reduce((x, R) => (x[R] = bq(s), x), {}), { setup: u, read: d, resolveKeyframes: h, preUpdate: f, update: m, preRender: g, render: w, postRender: E } = l, b = () => {
    const x = jr.useManualTiming ? i.timestamp : performance.now();
    n = !1, jr.useManualTiming || (i.delta = r ? 1e3 / 60 : Math.max(Math.min(x - i.timestamp, Cq), 1)), i.timestamp = x, i.isProcessing = !0, u.process(i), d.process(i), h.process(i), f.process(i), m.process(i), g.process(i), w.process(i), E.process(i), i.isProcessing = !1, n && t && (r = !1, e(b));
  }, A = () => {
    n = !0, r = !0, i.isProcessing || e(b);
  };
  return { schedule: Jc.reduce((x, R) => {
    const _ = l[R];
    return x[R] = (L, V = !1, O = !1) => (n || A(), _.schedule(L, V, O)), x;
  }, {}), cancel: (x) => {
    for (let R = 0; R < Jc.length; R++)
      l[Jc[R]].cancel(x);
  }, state: i, steps: l };
}
const { schedule: Kn, cancel: tv, state: qd } = /* @__PURE__ */ LI(typeof requestAnimationFrame < "u" ? requestAnimationFrame : da, !0);
let Cd;
function Eq() {
  Cd = void 0;
}
const kn = {
  now: () => (Cd === void 0 && kn.set(qd.isProcessing || jr.useManualTiming ? qd.timestamp : performance.now()), Cd),
  set: (e) => {
    Cd = e, queueMicrotask(Eq);
  }
}, PI = (e) => (t) => typeof t == "string" && t.startsWith(e), MI = /* @__PURE__ */ PI("--"), Aq = /* @__PURE__ */ PI("var(--"), ww = (e) => Aq(e) ? xq.test(e.split("/*")[0].trim()) : !1, xq = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu, fa = {
  test: (e) => typeof e == "number",
  parse: parseFloat,
  transform: (e) => e
}, Zl = {
  ...fa,
  transform: (e) => Co(0, 1, e)
}, ed = {
  ...fa,
  default: 1
}, Il = (e) => Math.round(e * 1e5) / 1e5, bw = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
function Sq(e) {
  return e == null;
}
const kq = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu, Cw = (e, t) => (n) => !!(typeof n == "string" && kq.test(n) && n.startsWith(e) || t && !Sq(n) && Object.prototype.hasOwnProperty.call(n, t)), OI = (e, t, n) => (r) => {
  if (typeof r != "string")
    return r;
  const [i, s, l, u] = r.match(bw);
  return {
    [e]: parseFloat(i),
    [t]: parseFloat(s),
    [n]: parseFloat(l),
    alpha: u !== void 0 ? parseFloat(u) : 1
  };
}, Rq = (e) => Co(0, 255, e), Im = {
  ...fa,
  transform: (e) => Math.round(Rq(e))
}, Zi = {
  test: /* @__PURE__ */ Cw("rgb", "red"),
  parse: /* @__PURE__ */ OI("red", "green", "blue"),
  transform: ({ red: e, green: t, blue: n, alpha: r = 1 }) => "rgba(" + Im.transform(e) + ", " + Im.transform(t) + ", " + Im.transform(n) + ", " + Il(Zl.transform(r)) + ")"
};
function Tq(e) {
  let t = "", n = "", r = "", i = "";
  return e.length > 5 ? (t = e.substring(1, 3), n = e.substring(3, 5), r = e.substring(5, 7), i = e.substring(7, 9)) : (t = e.substring(1, 2), n = e.substring(2, 3), r = e.substring(3, 4), i = e.substring(4, 5), t += t, n += n, r += r, i += i), {
    red: parseInt(t, 16),
    green: parseInt(n, 16),
    blue: parseInt(r, 16),
    alpha: i ? parseInt(i, 16) / 255 : 1
  };
}
const nv = {
  test: /* @__PURE__ */ Cw("#"),
  parse: Tq,
  transform: Zi.transform
}, Su = /* @__NO_SIDE_EFFECTS__ */ (e) => ({
  test: (t) => typeof t == "string" && t.endsWith(e) && t.split(" ").length === 1,
  parse: parseFloat,
  transform: (t) => `${t}${e}`
}), mi = /* @__PURE__ */ Su("deg"), Cs = /* @__PURE__ */ Su("%"), $e = /* @__PURE__ */ Su("px"), $q = /* @__PURE__ */ Su("vh"), Vq = /* @__PURE__ */ Su("vw"), Xx = {
  ...Cs,
  parse: (e) => Cs.parse(e) / 100,
  transform: (e) => Cs.transform(e * 100)
}, cs = {
  test: /* @__PURE__ */ Cw("hsl", "hue"),
  parse: /* @__PURE__ */ OI("hue", "saturation", "lightness"),
  transform: ({ hue: e, saturation: t, lightness: n, alpha: r = 1 }) => "hsla(" + Math.round(e) + ", " + Cs.transform(Il(t)) + ", " + Cs.transform(Il(n)) + ", " + Il(Zl.transform(r)) + ")"
}, ht = {
  test: (e) => Zi.test(e) || nv.test(e) || cs.test(e),
  parse: (e) => Zi.test(e) ? Zi.parse(e) : cs.test(e) ? cs.parse(e) : nv.parse(e),
  transform: (e) => typeof e == "string" ? e : e.hasOwnProperty("red") ? Zi.transform(e) : cs.transform(e),
  getAnimatableNone: (e) => {
    const t = ht.parse(e);
    return t.alpha = 0, ht.transform(t);
  }
}, _q = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
function Iq(e) {
  var t, n;
  return isNaN(e) && typeof e == "string" && (((t = e.match(bw)) == null ? void 0 : t.length) || 0) + (((n = e.match(_q)) == null ? void 0 : n.length) || 0) > 0;
}
const BI = "number", NI = "color", Lq = "var", Pq = "var(", Zx = "${}", Mq = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function Ql(e) {
  const t = e.toString(), n = [], r = {
    color: [],
    number: [],
    var: []
  }, i = [];
  let s = 0;
  const l = t.replace(Mq, (u) => (ht.test(u) ? (r.color.push(s), i.push(NI), n.push(ht.parse(u))) : u.startsWith(Pq) ? (r.var.push(s), i.push(Lq), n.push(u)) : (r.number.push(s), i.push(BI), n.push(parseFloat(u))), ++s, Zx)).split(Zx);
  return { values: n, split: l, indexes: r, types: i };
}
function DI(e) {
  return Ql(e).values;
}
function jI(e) {
  const { split: t, types: n } = Ql(e), r = t.length;
  return (i) => {
    let s = "";
    for (let l = 0; l < r; l++)
      if (s += t[l], i[l] !== void 0) {
        const u = n[l];
        u === BI ? s += Il(i[l]) : u === NI ? s += ht.transform(i[l]) : s += i[l];
      }
    return s;
  };
}
const Oq = (e) => typeof e == "number" ? 0 : ht.test(e) ? ht.getAnimatableNone(e) : e;
function Bq(e) {
  const t = DI(e);
  return jI(e)(t.map(Oq));
}
const ha = {
  test: Iq,
  parse: DI,
  createTransformer: jI,
  getAnimatableNone: Bq
};
function Lm(e, t, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + (t - e) * 6 * n : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e;
}
function Nq({ hue: e, saturation: t, lightness: n, alpha: r }) {
  e /= 360, t /= 100, n /= 100;
  let i = 0, s = 0, l = 0;
  if (!t)
    i = s = l = n;
  else {
    const u = n < 0.5 ? n * (1 + t) : n + t - n * t, d = 2 * n - u;
    i = Lm(d, u, e + 1 / 3), s = Lm(d, u, e), l = Lm(d, u, e - 1 / 3);
  }
  return {
    red: Math.round(i * 255),
    green: Math.round(s * 255),
    blue: Math.round(l * 255),
    alpha: r
  };
}
function Xd(e, t) {
  return (n) => n > 0 ? t : e;
}
const Df = (e, t, n) => e + (t - e) * n, Pm = (e, t, n) => {
  const r = e * e, i = n * (t * t - r) + r;
  return i < 0 ? 0 : Math.sqrt(i);
}, Dq = [nv, Zi, cs], jq = (e) => Dq.find((t) => t.test(e));
function Qx(e) {
  const t = jq(e);
  if (!t)
    return !1;
  let n = t.parse(e);
  return t === cs && (n = Nq(n)), n;
}
const Jx = (e, t) => {
  const n = Qx(e), r = Qx(t);
  if (!n || !r)
    return Xd(e, t);
  const i = { ...n };
  return (s) => (i.red = Pm(n.red, r.red, s), i.green = Pm(n.green, r.green, s), i.blue = Pm(n.blue, r.blue, s), i.alpha = Df(n.alpha, r.alpha, s), Zi.transform(i));
}, rv = /* @__PURE__ */ new Set(["none", "hidden"]);
function Fq(e, t) {
  return rv.has(e) ? (n) => n <= 0 ? e : t : (n) => n >= 1 ? t : e;
}
function Uq(e, t) {
  return (n) => Df(e, t, n);
}
function Ew(e) {
  return typeof e == "number" ? Uq : typeof e == "string" ? ww(e) ? Xd : ht.test(e) ? Jx : Hq : Array.isArray(e) ? FI : typeof e == "object" ? ht.test(e) ? Jx : Wq : Xd;
}
function FI(e, t) {
  const n = [...e], r = n.length, i = e.map((s, l) => Ew(s)(s, t[l]));
  return (s) => {
    for (let l = 0; l < r; l++)
      n[l] = i[l](s);
    return n;
  };
}
function Wq(e, t) {
  const n = { ...e, ...t }, r = {};
  for (const i in n)
    e[i] !== void 0 && t[i] !== void 0 && (r[i] = Ew(e[i])(e[i], t[i]));
  return (i) => {
    for (const s in r)
      n[s] = r[s](i);
    return n;
  };
}
function zq(e, t) {
  const n = [], r = { color: 0, var: 0, number: 0 };
  for (let i = 0; i < t.values.length; i++) {
    const s = t.types[i], l = e.indexes[s][r[s]], u = e.values[l] ?? 0;
    n[i] = u, r[s]++;
  }
  return n;
}
const Hq = (e, t) => {
  const n = ha.createTransformer(t), r = Ql(e), i = Ql(t);
  return r.indexes.var.length === i.indexes.var.length && r.indexes.color.length === i.indexes.color.length && r.indexes.number.length >= i.indexes.number.length ? rv.has(e) && !i.values.length || rv.has(t) && !r.values.length ? Fq(e, t) : Nf(FI(zq(r, i), i.values), n) : Xd(e, t);
};
function UI(e, t, n) {
  return typeof e == "number" && typeof t == "number" && typeof n == "number" ? Df(e, t, n) : Ew(e)(e, t);
}
const Kq = (e) => {
  const t = ({ timestamp: n }) => e(n);
  return {
    start: (n = !0) => Kn.update(t, n),
    stop: () => tv(t),
    /**
     * If we're processing this frame we can use the
     * framelocked timestamp to keep things in sync.
     */
    now: () => qd.isProcessing ? qd.timestamp : kn.now()
  };
}, WI = (e, t, n = 10) => {
  let r = "";
  const i = Math.max(Math.round(t / n), 2);
  for (let s = 0; s < i; s++)
    r += Math.round(e(s / (i - 1)) * 1e4) / 1e4 + ", ";
  return `linear(${r.substring(0, r.length - 2)})`;
}, Zd = 2e4;
function Aw(e) {
  let t = 0;
  const n = 50;
  let r = e.next(t);
  for (; !r.done && t < Zd; )
    t += n, r = e.next(t);
  return t >= Zd ? 1 / 0 : t;
}
function Gq(e, t = 100, n) {
  const r = n({ ...e, keyframes: [0, t] }), i = Math.min(Aw(r), Zd);
  return {
    type: "keyframes",
    ease: (s) => r.next(i * s).value / t,
    duration: /* @__PURE__ */ Vr(i)
  };
}
const Yq = 5;
function zI(e, t, n) {
  const r = Math.max(t - Yq, 0);
  return AI(n - e(r), t - r);
}
const it = {
  // Default spring physics
  stiffness: 100,
  damping: 10,
  mass: 1,
  velocity: 0,
  // Default duration/bounce-based options
  duration: 800,
  // in ms
  bounce: 0.3,
  visualDuration: 0.3,
  // in seconds
  // Rest thresholds
  restSpeed: {
    granular: 0.01,
    default: 2
  },
  restDelta: {
    granular: 5e-3,
    default: 0.5
  },
  // Limits
  minDuration: 0.01,
  // in seconds
  maxDuration: 10,
  // in seconds
  minDamping: 0.05,
  maxDamping: 1
}, Mm = 1e-3;
function qq({ duration: e = it.duration, bounce: t = it.bounce, velocity: n = it.velocity, mass: r = it.mass }) {
  let i, s, l = 1 - t;
  l = Co(it.minDamping, it.maxDamping, l), e = Co(it.minDuration, it.maxDuration, /* @__PURE__ */ Vr(e)), l < 1 ? (i = (h) => {
    const f = h * l, m = f * e, g = f - n, w = iv(h, l), E = Math.exp(-m);
    return Mm - g / w * E;
  }, s = (h) => {
    const f = h * l * e, m = f * n + n, g = Math.pow(l, 2) * Math.pow(h, 2) * e, w = Math.exp(-f), E = iv(Math.pow(h, 2), l);
    return (-i(h) + Mm > 0 ? -1 : 1) * ((m - g) * w) / E;
  }) : (i = (h) => {
    const f = Math.exp(-h * e), m = (h - n) * e + 1;
    return -Mm + f * m;
  }, s = (h) => {
    const f = Math.exp(-h * e), m = (n - h) * (e * e);
    return f * m;
  });
  const u = 5 / e, d = Zq(i, s, u);
  if (e = /* @__PURE__ */ $r(e), isNaN(d))
    return {
      stiffness: it.stiffness,
      damping: it.damping,
      duration: e
    };
  {
    const h = Math.pow(d, 2) * r;
    return {
      stiffness: h,
      damping: l * 2 * Math.sqrt(r * h),
      duration: e
    };
  }
}
const Xq = 12;
function Zq(e, t, n) {
  let r = n;
  for (let i = 1; i < Xq; i++)
    r = r - e(r) / t(r);
  return r;
}
function iv(e, t) {
  return e * Math.sqrt(1 - t * t);
}
const Qq = ["duration", "bounce"], Jq = ["stiffness", "damping", "mass"];
function eS(e, t) {
  return t.some((n) => e[n] !== void 0);
}
function eX(e) {
  let t = {
    velocity: it.velocity,
    stiffness: it.stiffness,
    damping: it.damping,
    mass: it.mass,
    isResolvedFromDuration: !1,
    ...e
  };
  if (!eS(e, Jq) && eS(e, Qq))
    if (e.visualDuration) {
      const n = e.visualDuration, r = 2 * Math.PI / (n * 1.2), i = r * r, s = 2 * Co(0.05, 1, 1 - (e.bounce || 0)) * Math.sqrt(i);
      t = {
        ...t,
        mass: it.mass,
        stiffness: i,
        damping: s
      };
    } else {
      const n = qq(e);
      t = {
        ...t,
        ...n,
        mass: it.mass
      }, t.isResolvedFromDuration = !0;
    }
  return t;
}
function Qd(e = it.visualDuration, t = it.bounce) {
  const n = typeof e != "object" ? {
    visualDuration: e,
    keyframes: [0, 1],
    bounce: t
  } : e;
  let { restSpeed: r, restDelta: i } = n;
  const s = n.keyframes[0], l = n.keyframes[n.keyframes.length - 1], u = { done: !1, value: s }, { stiffness: d, damping: h, mass: f, duration: m, velocity: g, isResolvedFromDuration: w } = eX({
    ...n,
    velocity: -/* @__PURE__ */ Vr(n.velocity || 0)
  }), E = g || 0, b = h / (2 * Math.sqrt(d * f)), A = l - s, x = /* @__PURE__ */ Vr(Math.sqrt(d / f)), R = Math.abs(A) < 5;
  r || (r = R ? it.restSpeed.granular : it.restSpeed.default), i || (i = R ? it.restDelta.granular : it.restDelta.default);
  let _;
  if (b < 1) {
    const V = iv(x, b);
    _ = (O) => {
      const D = Math.exp(-b * x * O);
      return l - D * ((E + b * x * A) / V * Math.sin(V * O) + A * Math.cos(V * O));
    };
  } else if (b === 1)
    _ = (V) => l - Math.exp(-x * V) * (A + (E + x * A) * V);
  else {
    const V = x * Math.sqrt(b * b - 1);
    _ = (O) => {
      const D = Math.exp(-b * x * O), B = Math.min(V * O, 300);
      return l - D * ((E + b * x * A) * Math.sinh(B) + V * A * Math.cosh(B)) / V;
    };
  }
  const L = {
    calculatedDuration: w && m || null,
    next: (V) => {
      const O = _(V);
      if (w)
        u.done = V >= m;
      else {
        let D = V === 0 ? E : 0;
        b < 1 && (D = V === 0 ? /* @__PURE__ */ $r(E) : zI(_, V, O));
        const B = Math.abs(D) <= r, H = Math.abs(l - O) <= i;
        u.done = B && H;
      }
      return u.value = u.done ? l : O, u;
    },
    toString: () => {
      const V = Math.min(Aw(L), Zd), O = WI((D) => L.next(V * D).value, V, 30);
      return V + "ms " + O;
    },
    toTransition: () => {
    }
  };
  return L;
}
Qd.applyToOptions = (e) => {
  const t = Gq(e, 100, Qd);
  return e.ease = t.ease, e.duration = /* @__PURE__ */ $r(t.duration), e.type = "keyframes", e;
};
function ov({ keyframes: e, velocity: t = 0, power: n = 0.8, timeConstant: r = 325, bounceDamping: i = 10, bounceStiffness: s = 500, modifyTarget: l, min: u, max: d, restDelta: h = 0.5, restSpeed: f }) {
  const m = e[0], g = {
    done: !1,
    value: m
  }, w = (B) => u !== void 0 && B < u || d !== void 0 && B > d, E = (B) => u === void 0 ? d : d === void 0 || Math.abs(u - B) < Math.abs(d - B) ? u : d;
  let b = n * t;
  const A = m + b, x = l === void 0 ? A : l(A);
  x !== A && (b = x - m);
  const R = (B) => -b * Math.exp(-B / r), _ = (B) => x + R(B), L = (B) => {
    const H = R(B), J = _(B);
    g.done = Math.abs(H) <= h, g.value = g.done ? x : J;
  };
  let V, O;
  const D = (B) => {
    w(g.value) && (V = B, O = Qd({
      keyframes: [g.value, E(g.value)],
      velocity: zI(_, B, g.value),
      // TODO: This should be passing * 1000
      damping: i,
      stiffness: s,
      restDelta: h,
      restSpeed: f
    }));
  };
  return D(0), {
    calculatedDuration: null,
    next: (B) => {
      let H = !1;
      return !O && V === void 0 && (H = !0, L(B), D(B)), V !== void 0 && B >= V ? O.next(B - V) : (!H && L(B), g);
    }
  };
}
function tX(e, t, n) {
  const r = [], i = n || jr.mix || UI, s = e.length - 1;
  for (let l = 0; l < s; l++) {
    let u = i(e[l], e[l + 1]);
    if (t) {
      const d = Array.isArray(t) ? t[l] || da : t;
      u = Nf(d, u);
    }
    r.push(u);
  }
  return r;
}
function nX(e, t, { clamp: n = !0, ease: r, mixer: i } = {}) {
  const s = e.length;
  if (mw(s === t.length), s === 1)
    return () => t[0];
  if (s === 2 && t[0] === t[1])
    return () => t[1];
  const l = e[0] === e[1];
  e[0] > e[s - 1] && (e = [...e].reverse(), t = [...t].reverse());
  const u = tX(t, r, i), d = u.length, h = (f) => {
    if (l && f < e[0])
      return t[0];
    let m = 0;
    if (d > 1)
      for (; m < e.length - 2 && !(f < e[m + 1]); m++)
        ;
    const g = /* @__PURE__ */ CI(e[m], e[m + 1], f);
    return u[m](g);
  };
  return n ? (f) => h(Co(e[0], e[s - 1], f)) : h;
}
function rX(e, t) {
  const n = e[e.length - 1];
  for (let r = 1; r <= t; r++) {
    const i = /* @__PURE__ */ CI(0, t, r);
    e.push(Df(n, 1, i));
  }
}
function iX(e) {
  const t = [0];
  return rX(t, e.length - 1), t;
}
function oX(e, t) {
  return e.map((n) => n * t);
}
function sX(e, t) {
  return e.map(() => t || _I).splice(0, e.length - 1);
}
function Ll({ duration: e = 300, keyframes: t, times: n, ease: r = "easeInOut" }) {
  const i = vq(r) ? r.map(qx) : qx(r), s = {
    done: !1,
    value: t[0]
  }, l = oX(
    // Only use the provided offsets if they're the correct length
    // TODO Maybe we should warn here if there's a length mismatch
    n && n.length === t.length ? n : iX(t),
    e
  ), u = nX(l, t, {
    ease: Array.isArray(i) ? i : sX(t, i)
  });
  return {
    calculatedDuration: e,
    next: (d) => (s.value = u(d), s.done = d >= e, s)
  };
}
const aX = (e) => e !== null;
function xw(e, { repeat: t, repeatType: n = "loop" }, r, i = 1) {
  const s = e.filter(aX), l = i < 0 || t && n !== "loop" && t % 2 === 1 ? 0 : s.length - 1;
  return !l || r === void 0 ? s[l] : r;
}
const lX = {
  decay: ov,
  inertia: ov,
  tween: Ll,
  keyframes: Ll,
  spring: Qd
};
function HI(e) {
  typeof e.type == "string" && (e.type = lX[e.type]);
}
let Sw = class {
  constructor() {
    this.updateFinished();
  }
  get finished() {
    return this._finished;
  }
  updateFinished() {
    this._finished = new Promise((t) => {
      this.resolve = t;
    });
  }
  notifyFinished() {
    this.resolve();
  }
  /**
   * Allows the animation to be awaited.
   *
   * @deprecated Use `finished` instead.
   */
  then(t, n) {
    return this.finished.then(t, n);
  }
};
const uX = (e) => e / 100;
let kw = class extends Sw {
  constructor(t) {
    super(), this.state = "idle", this.startTime = null, this.isStopped = !1, this.currentTime = 0, this.holdTime = null, this.playbackSpeed = 1, this.stop = () => {
      var n, r;
      const { motionValue: i } = this.options;
      i && i.updatedAt !== kn.now() && this.tick(kn.now()), this.isStopped = !0, this.state !== "idle" && (this.teardown(), (r = (n = this.options).onStop) == null || r.call(n));
    }, this.options = t, this.initAnimation(), this.play(), t.autoplay === !1 && this.pause();
  }
  initAnimation() {
    const { options: t } = this;
    HI(t);
    const { type: n = Ll, repeat: r = 0, repeatDelay: i = 0, repeatType: s, velocity: l = 0 } = t;
    let { keyframes: u } = t;
    const d = n || Ll;
    d !== Ll && typeof u[0] != "number" && (this.mixKeyframes = Nf(uX, UI(u[0], u[1])), u = [0, 100]);
    const h = d({ ...t, keyframes: u });
    s === "mirror" && (this.mirroredGenerator = d({
      ...t,
      keyframes: [...u].reverse(),
      velocity: -l
    })), h.calculatedDuration === null && (h.calculatedDuration = Aw(h));
    const { calculatedDuration: f } = h;
    this.calculatedDuration = f, this.resolvedDuration = f + i, this.totalDuration = this.resolvedDuration * (r + 1) - i, this.generator = h;
  }
  updateTime(t) {
    const n = Math.round(t - this.startTime) * this.playbackSpeed;
    this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = n;
  }
  tick(t, n = !1) {
    const { generator: r, totalDuration: i, mixKeyframes: s, mirroredGenerator: l, resolvedDuration: u, calculatedDuration: d } = this;
    if (this.startTime === null)
      return r.next(0);
    const { delay: h = 0, keyframes: f, repeat: m, repeatType: g, repeatDelay: w, type: E, onUpdate: b, finalKeyframe: A } = this.options;
    this.speed > 0 ? this.startTime = Math.min(this.startTime, t) : this.speed < 0 && (this.startTime = Math.min(t - i / this.speed, this.startTime)), n ? this.currentTime = t : this.updateTime(t);
    const x = this.currentTime - h * (this.playbackSpeed >= 0 ? 1 : -1), R = this.playbackSpeed >= 0 ? x < 0 : x > i;
    this.currentTime = Math.max(x, 0), this.state === "finished" && this.holdTime === null && (this.currentTime = i);
    let _ = this.currentTime, L = r;
    if (m) {
      const B = Math.min(this.currentTime, i) / u;
      let H = Math.floor(B), J = B % 1;
      !J && B >= 1 && (J = 1), J === 1 && H--, H = Math.min(H, m + 1), H % 2 && (g === "reverse" ? (J = 1 - J, w && (J -= w / u)) : g === "mirror" && (L = l)), _ = Co(0, 1, J) * u;
    }
    const V = R ? { done: !1, value: f[0] } : L.next(_);
    s && (V.value = s(V.value));
    let { done: O } = V;
    !R && d !== null && (O = this.playbackSpeed >= 0 ? this.currentTime >= i : this.currentTime <= 0);
    const D = this.holdTime === null && (this.state === "finished" || this.state === "running" && O);
    return D && E !== ov && (V.value = xw(f, this.options, A, this.speed)), b && b(V.value), D && this.finish(), V;
  }
  /**
   * Allows the returned animation to be awaited or promise-chained. Currently
   * resolves when the animation finishes at all but in a future update could/should
   * reject if its cancels.
   */
  then(t, n) {
    return this.finished.then(t, n);
  }
  get duration() {
    return /* @__PURE__ */ Vr(this.calculatedDuration);
  }
  get time() {
    return /* @__PURE__ */ Vr(this.currentTime);
  }
  set time(t) {
    var n;
    t = /* @__PURE__ */ $r(t), this.currentTime = t, this.startTime === null || this.holdTime !== null || this.playbackSpeed === 0 ? this.holdTime = t : this.driver && (this.startTime = this.driver.now() - t / this.playbackSpeed), (n = this.driver) == null || n.start(!1);
  }
  get speed() {
    return this.playbackSpeed;
  }
  set speed(t) {
    this.updateTime(kn.now());
    const n = this.playbackSpeed !== t;
    this.playbackSpeed = t, n && (this.time = /* @__PURE__ */ Vr(this.currentTime));
  }
  play() {
    var t, n;
    if (this.isStopped)
      return;
    const { driver: r = Kq, startTime: i } = this.options;
    this.driver || (this.driver = r((l) => this.tick(l))), (n = (t = this.options).onPlay) == null || n.call(t);
    const s = this.driver.now();
    this.state === "finished" ? (this.updateFinished(), this.startTime = s) : this.holdTime !== null ? this.startTime = s - this.holdTime : this.startTime || (this.startTime = i ?? s), this.state === "finished" && this.speed < 0 && (this.startTime += this.calculatedDuration), this.holdTime = null, this.state = "running", this.driver.start();
  }
  pause() {
    this.state = "paused", this.updateTime(kn.now()), this.holdTime = this.currentTime;
  }
  complete() {
    this.state !== "running" && this.play(), this.state = "finished", this.holdTime = null;
  }
  finish() {
    var t, n;
    this.notifyFinished(), this.teardown(), this.state = "finished", (n = (t = this.options).onComplete) == null || n.call(t);
  }
  cancel() {
    var t, n;
    this.holdTime = null, this.startTime = 0, this.tick(0), this.teardown(), (n = (t = this.options).onCancel) == null || n.call(t);
  }
  teardown() {
    this.state = "idle", this.stopDriver(), this.startTime = this.holdTime = null;
  }
  stopDriver() {
    this.driver && (this.driver.stop(), this.driver = void 0);
  }
  sample(t) {
    return this.startTime = 0, this.tick(t, !0);
  }
  attachTimeline(t) {
    var n;
    return this.options.allowFlatten && (this.options.type = "keyframes", this.options.ease = "linear", this.initAnimation()), (n = this.driver) == null || n.stop(), t.observe(this);
  }
};
function cX(e) {
  for (let t = 1; t < e.length; t++)
    e[t] ?? (e[t] = e[t - 1]);
}
const Qi = (e) => e * 180 / Math.PI, sv = (e) => {
  const t = Qi(Math.atan2(e[1], e[0]));
  return av(t);
}, dX = {
  x: 4,
  y: 5,
  translateX: 4,
  translateY: 5,
  scaleX: 0,
  scaleY: 3,
  scale: (e) => (Math.abs(e[0]) + Math.abs(e[3])) / 2,
  rotate: sv,
  rotateZ: sv,
  skewX: (e) => Qi(Math.atan(e[1])),
  skewY: (e) => Qi(Math.atan(e[2])),
  skew: (e) => (Math.abs(e[1]) + Math.abs(e[2])) / 2
}, av = (e) => (e = e % 360, e < 0 && (e += 360), e), tS = sv, nS = (e) => Math.sqrt(e[0] * e[0] + e[1] * e[1]), rS = (e) => Math.sqrt(e[4] * e[4] + e[5] * e[5]), fX = {
  x: 12,
  y: 13,
  z: 14,
  translateX: 12,
  translateY: 13,
  translateZ: 14,
  scaleX: nS,
  scaleY: rS,
  scale: (e) => (nS(e) + rS(e)) / 2,
  rotateX: (e) => av(Qi(Math.atan2(e[6], e[5]))),
  rotateY: (e) => av(Qi(Math.atan2(-e[2], e[0]))),
  rotateZ: tS,
  rotate: tS,
  skewX: (e) => Qi(Math.atan(e[4])),
  skewY: (e) => Qi(Math.atan(e[1])),
  skew: (e) => (Math.abs(e[1]) + Math.abs(e[4])) / 2
};
function lv(e) {
  return e.includes("scale") ? 1 : 0;
}
function uv(e, t) {
  if (!e || e === "none")
    return lv(t);
  const n = e.match(/^matrix3d\(([-\d.e\s,]+)\)$/u);
  let r, i;
  if (n)
    r = fX, i = n;
  else {
    const u = e.match(/^matrix\(([-\d.e\s,]+)\)$/u);
    r = dX, i = u;
  }
  if (!i)
    return lv(t);
  const s = r[t], l = i[1].split(",").map(pX);
  return typeof s == "function" ? s(l) : l[s];
}
const hX = (e, t) => {
  const { transform: n = "none" } = getComputedStyle(e);
  return uv(n, t);
};
function pX(e) {
  return parseFloat(e.trim());
}
const pa = [
  "transformPerspective",
  "x",
  "y",
  "z",
  "translateX",
  "translateY",
  "translateZ",
  "scale",
  "scaleX",
  "scaleY",
  "rotate",
  "rotateX",
  "rotateY",
  "rotateZ",
  "skew",
  "skewX",
  "skewY"
], ma = new Set(pa), iS = (e) => e === fa || e === $e, mX = /* @__PURE__ */ new Set(["x", "y", "z"]), gX = pa.filter((e) => !mX.has(e));
function vX(e) {
  const t = [];
  return gX.forEach((n) => {
    const r = e.getValue(n);
    r !== void 0 && (t.push([n, r.get()]), r.set(n.startsWith("scale") ? 1 : 0));
  }), t;
}
const co = {
  // Dimensions
  width: ({ x: e }, { paddingLeft: t = "0", paddingRight: n = "0" }) => e.max - e.min - parseFloat(t) - parseFloat(n),
  height: ({ y: e }, { paddingTop: t = "0", paddingBottom: n = "0" }) => e.max - e.min - parseFloat(t) - parseFloat(n),
  top: (e, { top: t }) => parseFloat(t),
  left: (e, { left: t }) => parseFloat(t),
  bottom: ({ y: e }, { top: t }) => parseFloat(t) + (e.max - e.min),
  right: ({ x: e }, { left: t }) => parseFloat(t) + (e.max - e.min),
  // Transform
  x: (e, { transform: t }) => uv(t, "x"),
  y: (e, { transform: t }) => uv(t, "y")
};
co.translateX = co.x;
co.translateY = co.y;
const fo = /* @__PURE__ */ new Set();
let cv = !1, dv = !1, fv = !1;
function KI() {
  if (dv) {
    const e = Array.from(fo).filter((r) => r.needsMeasurement), t = new Set(e.map((r) => r.element)), n = /* @__PURE__ */ new Map();
    t.forEach((r) => {
      const i = vX(r);
      i.length && (n.set(r, i), r.render());
    }), e.forEach((r) => r.measureInitialState()), t.forEach((r) => {
      r.render();
      const i = n.get(r);
      i && i.forEach(([s, l]) => {
        var u;
        (u = r.getValue(s)) == null || u.set(l);
      });
    }), e.forEach((r) => r.measureEndState()), e.forEach((r) => {
      r.suspendedScrollY !== void 0 && window.scrollTo(0, r.suspendedScrollY);
    });
  }
  dv = !1, cv = !1, fo.forEach((e) => e.complete(fv)), fo.clear();
}
function GI() {
  fo.forEach((e) => {
    e.readKeyframes(), e.needsMeasurement && (dv = !0);
  });
}
function yX() {
  fv = !0, GI(), KI(), fv = !1;
}
let Rw = class {
  constructor(t, n, r, i, s, l = !1) {
    this.state = "pending", this.isAsync = !1, this.needsMeasurement = !1, this.unresolvedKeyframes = [...t], this.onComplete = n, this.name = r, this.motionValue = i, this.element = s, this.isAsync = l;
  }
  scheduleResolve() {
    this.state = "scheduled", this.isAsync ? (fo.add(this), cv || (cv = !0, Kn.read(GI), Kn.resolveKeyframes(KI))) : (this.readKeyframes(), this.complete());
  }
  readKeyframes() {
    const { unresolvedKeyframes: t, name: n, element: r, motionValue: i } = this;
    if (t[0] === null) {
      const s = i == null ? void 0 : i.get(), l = t[t.length - 1];
      if (s !== void 0)
        t[0] = s;
      else if (r && n) {
        const u = r.readValue(n, l);
        u != null && (t[0] = u);
      }
      t[0] === void 0 && (t[0] = l), i && s === void 0 && i.set(t[0]);
    }
    cX(t);
  }
  setFinalKeyframe() {
  }
  measureInitialState() {
  }
  renderEndStyles() {
  }
  measureEndState() {
  }
  complete(t = !1) {
    this.state = "complete", this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, t), fo.delete(this);
  }
  cancel() {
    this.state === "scheduled" && (fo.delete(this), this.state = "pending");
  }
  resume() {
    this.state === "pending" && this.scheduleResolve();
  }
};
const wX = (e) => e.startsWith("--");
function bX(e, t, n) {
  wX(t) ? e.style.setProperty(t, n) : e.style[t] = n;
}
const CX = /* @__PURE__ */ gw(() => window.ScrollTimeline !== void 0), EX = {};
function AX(e, t) {
  const n = /* @__PURE__ */ gw(e);
  return () => EX[t] ?? n();
}
const YI = /* @__PURE__ */ AX(() => {
  try {
    document.createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" });
  } catch {
    return !1;
  }
  return !0;
}, "linearEasing"), Cl = ([e, t, n, r]) => `cubic-bezier(${e}, ${t}, ${n}, ${r})`, oS = {
  linear: "linear",
  ease: "ease",
  easeIn: "ease-in",
  easeOut: "ease-out",
  easeInOut: "ease-in-out",
  circIn: /* @__PURE__ */ Cl([0, 0.65, 0.55, 1]),
  circOut: /* @__PURE__ */ Cl([0.55, 0, 1, 0.45]),
  backIn: /* @__PURE__ */ Cl([0.31, 0.01, 0.66, -0.59]),
  backOut: /* @__PURE__ */ Cl([0.33, 1.53, 0.69, 0.99])
};
function qI(e, t) {
  if (e)
    return typeof e == "function" ? YI() ? WI(e, t) : "ease-out" : II(e) ? Cl(e) : Array.isArray(e) ? e.map((n) => qI(n, t) || oS.easeOut) : oS[e];
}
function xX(e, t, n, { delay: r = 0, duration: i = 300, repeat: s = 0, repeatType: l = "loop", ease: u = "easeOut", times: d } = {}, h = void 0) {
  const f = {
    [t]: n
  };
  d && (f.offset = d);
  const m = qI(u, i);
  Array.isArray(m) && (f.easing = m);
  const g = {
    delay: r,
    duration: i,
    easing: Array.isArray(m) ? "linear" : m,
    fill: "both",
    iterations: s + 1,
    direction: l === "reverse" ? "alternate" : "normal"
  };
  return h && (g.pseudoElement = h), e.animate(f, g);
}
function XI(e) {
  return typeof e == "function" && "applyToOptions" in e;
}
function SX({ type: e, ...t }) {
  return XI(e) && YI() ? e.applyToOptions(t) : (t.duration ?? (t.duration = 300), t.ease ?? (t.ease = "easeOut"), t);
}
class kX extends Sw {
  constructor(t) {
    if (super(), this.finishedTime = null, this.isStopped = !1, !t)
      return;
    const { element: n, name: r, keyframes: i, pseudoElement: s, allowFlatten: l = !1, finalKeyframe: u, onComplete: d } = t;
    this.isPseudoElement = !!s, this.allowFlatten = l, this.options = t, mw(typeof t.type != "string");
    const h = SX(t);
    this.animation = xX(n, r, i, h, s), h.autoplay === !1 && this.animation.pause(), this.animation.onfinish = () => {
      if (this.finishedTime = this.time, !s) {
        const f = xw(i, this.options, u, this.speed);
        this.updateMotionValue ? this.updateMotionValue(f) : bX(n, r, f), this.animation.cancel();
      }
      d == null || d(), this.notifyFinished();
    };
  }
  play() {
    this.isStopped || (this.animation.play(), this.state === "finished" && this.updateFinished());
  }
  pause() {
    this.animation.pause();
  }
  complete() {
    var t, n;
    (n = (t = this.animation).finish) == null || n.call(t);
  }
  cancel() {
    try {
      this.animation.cancel();
    } catch {
    }
  }
  stop() {
    if (this.isStopped)
      return;
    this.isStopped = !0;
    const { state: t } = this;
    t === "idle" || t === "finished" || (this.updateMotionValue ? this.updateMotionValue() : this.commitStyles(), this.isPseudoElement || this.cancel());
  }
  /**
   * WAAPI doesn't natively have any interruption capabilities.
   *
   * In this method, we commit styles back to the DOM before cancelling
   * the animation.
   *
   * This is designed to be overridden by NativeAnimationExtended, which
   * will create a renderless JS animation and sample it twice to calculate
   * its current value, "previous" value, and therefore allow
   * Motion to also correctly calculate velocity for any subsequent animation
   * while deferring the commit until the next animation frame.
   */
  commitStyles() {
    var t, n;
    this.isPseudoElement || (n = (t = this.animation).commitStyles) == null || n.call(t);
  }
  get duration() {
    var t, n;
    const r = ((n = (t = this.animation.effect) == null ? void 0 : t.getComputedTiming) == null ? void 0 : n.call(t).duration) || 0;
    return /* @__PURE__ */ Vr(Number(r));
  }
  get time() {
    return /* @__PURE__ */ Vr(Number(this.animation.currentTime) || 0);
  }
  set time(t) {
    this.finishedTime = null, this.animation.currentTime = /* @__PURE__ */ $r(t);
  }
  /**
   * The playback speed of the animation.
   * 1 = normal speed, 2 = double speed, 0.5 = half speed.
   */
  get speed() {
    return this.animation.playbackRate;
  }
  set speed(t) {
    t < 0 && (this.finishedTime = null), this.animation.playbackRate = t;
  }
  get state() {
    return this.finishedTime !== null ? "finished" : this.animation.playState;
  }
  get startTime() {
    return Number(this.animation.startTime);
  }
  set startTime(t) {
    this.animation.startTime = t;
  }
  /**
   * Attaches a timeline to the animation, for instance the `ScrollTimeline`.
   */
  attachTimeline({ timeline: t, observe: n }) {
    var r;
    return this.allowFlatten && ((r = this.animation.effect) == null || r.updateTiming({ easing: "linear" })), this.animation.onfinish = null, t && CX() ? (this.animation.timeline = t, da) : n(this);
  }
}
const ZI = {
  anticipate: $I,
  backInOut: TI,
  circInOut: VI
};
function RX(e) {
  return e in ZI;
}
function TX(e) {
  typeof e.ease == "string" && RX(e.ease) && (e.ease = ZI[e.ease]);
}
const sS = 10;
class $X extends kX {
  constructor(t) {
    TX(t), HI(t), super(t), t.startTime && (this.startTime = t.startTime), this.options = t;
  }
  /**
   * WAAPI doesn't natively have any interruption capabilities.
   *
   * Rather than read commited styles back out of the DOM, we can
   * create a renderless JS animation and sample it twice to calculate
   * its current value, "previous" value, and therefore allow
   * Motion to calculate velocity for any subsequent animation.
   */
  updateMotionValue(t) {
    const { motionValue: n, onUpdate: r, onComplete: i, element: s, ...l } = this.options;
    if (!n)
      return;
    if (t !== void 0) {
      n.set(t);
      return;
    }
    const u = new kw({
      ...l,
      autoplay: !1
    }), d = /* @__PURE__ */ $r(this.finishedTime ?? this.time);
    n.setWithVelocity(u.sample(d - sS).value, u.sample(d).value, sS), u.stop();
  }
}
const aS = (e, t) => t === "zIndex" ? !1 : !!(typeof e == "number" || Array.isArray(e) || typeof e == "string" && // It's animatable if we have a string
(ha.test(e) || e === "0") && // And it contains numbers and/or colors
!e.startsWith("url("));
function VX(e) {
  const t = e[0];
  if (e.length === 1)
    return !0;
  for (let n = 0; n < e.length; n++)
    if (e[n] !== t)
      return !0;
}
function _X(e, t, n, r) {
  const i = e[0];
  if (i === null)
    return !1;
  if (t === "display" || t === "visibility")
    return !0;
  const s = e[e.length - 1], l = aS(i, t), u = aS(s, t);
  return !l || !u ? !1 : VX(e) || (n === "spring" || XI(n)) && r;
}
function hv(e) {
  e.duration = 0, e.type;
}
const IX = /* @__PURE__ */ new Set([
  "opacity",
  "clipPath",
  "filter",
  "transform"
  // TODO: Could be re-enabled now we have support for linear() easing
  // "background-color"
]), LX = /* @__PURE__ */ gw(() => Object.hasOwnProperty.call(Element.prototype, "animate"));
function PX(e) {
  var t;
  const { motionValue: n, name: r, repeatDelay: i, repeatType: s, damping: l, type: u } = e;
  if (!(((t = n == null ? void 0 : n.owner) == null ? void 0 : t.current) instanceof HTMLElement))
    return !1;
  const { onUpdate: d, transformTemplate: h } = n.owner.getProps();
  return LX() && r && IX.has(r) && (r !== "transform" || !h) && /**
  * If we're outputting values to onUpdate then we can't use WAAPI as there's
  * no way to read the value from WAAPI every frame.
  */
  !d && !i && s !== "mirror" && l !== 0 && u !== "inertia";
}
const MX = 40;
let OX = class extends Sw {
  constructor({ autoplay: t = !0, delay: n = 0, type: r = "keyframes", repeat: i = 0, repeatDelay: s = 0, repeatType: l = "loop", keyframes: u, name: d, motionValue: h, element: f, ...m }) {
    var g;
    super(), this.stop = () => {
      var b, A;
      this._animation && (this._animation.stop(), (b = this.stopTimeline) == null || b.call(this)), (A = this.keyframeResolver) == null || A.cancel();
    }, this.createdAt = kn.now();
    const w = {
      autoplay: t,
      delay: n,
      type: r,
      repeat: i,
      repeatDelay: s,
      repeatType: l,
      name: d,
      motionValue: h,
      element: f,
      ...m
    }, E = (f == null ? void 0 : f.KeyframeResolver) || Rw;
    this.keyframeResolver = new E(u, (b, A, x) => this.onKeyframesResolved(b, A, w, !x), d, h, f), (g = this.keyframeResolver) == null || g.scheduleResolve();
  }
  onKeyframesResolved(t, n, r, i) {
    this.keyframeResolver = void 0;
    const { name: s, type: l, velocity: u, delay: d, isHandoff: h, onUpdate: f } = r;
    this.resolvedAt = kn.now(), _X(t, s, l, u) || ((jr.instantAnimations || !d) && (f == null || f(xw(t, r, n))), t[0] = t[t.length - 1], hv(r), r.repeat = 0);
    const m = {
      startTime: i ? this.resolvedAt ? this.resolvedAt - this.createdAt > MX ? this.resolvedAt : this.createdAt : this.createdAt : void 0,
      finalKeyframe: n,
      ...r,
      keyframes: t
    }, g = !h && PX(m) ? new $X({
      ...m,
      element: m.motionValue.owner.current
    }) : new kw(m);
    g.finished.then(() => this.notifyFinished()).catch(da), this.pendingTimeline && (this.stopTimeline = g.attachTimeline(this.pendingTimeline), this.pendingTimeline = void 0), this._animation = g;
  }
  get finished() {
    return this._animation ? this.animation.finished : this._finished;
  }
  then(t, n) {
    return this.finished.finally(t).then(() => {
    });
  }
  get animation() {
    var t;
    return this._animation || ((t = this.keyframeResolver) == null || t.resume(), yX()), this._animation;
  }
  get duration() {
    return this.animation.duration;
  }
  get time() {
    return this.animation.time;
  }
  set time(t) {
    this.animation.time = t;
  }
  get speed() {
    return this.animation.speed;
  }
  get state() {
    return this.animation.state;
  }
  set speed(t) {
    this.animation.speed = t;
  }
  get startTime() {
    return this.animation.startTime;
  }
  attachTimeline(t) {
    return this._animation ? this.stopTimeline = this.animation.attachTimeline(t) : this.pendingTimeline = t, () => this.stop();
  }
  play() {
    this.animation.play();
  }
  pause() {
    this.animation.pause();
  }
  complete() {
    this.animation.complete();
  }
  cancel() {
    var t;
    this._animation && this.animation.cancel(), (t = this.keyframeResolver) == null || t.cancel();
  }
};
const BX = (
  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words
  /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u
);
function NX(e) {
  const t = BX.exec(e);
  if (!t)
    return [,];
  const [, n, r, i] = t;
  return [`--${n ?? r}`, i];
}
function QI(e, t, n = 1) {
  const [r, i] = NX(e);
  if (!r)
    return;
  const s = window.getComputedStyle(t).getPropertyValue(r);
  if (s) {
    const l = s.trim();
    return wI(l) ? parseFloat(l) : l;
  }
  return ww(i) ? QI(i, t, n + 1) : i;
}
function JI(e, t) {
  return (e == null ? void 0 : e[t]) ?? (e == null ? void 0 : e.default) ?? e;
}
const eL = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  ...pa
]), DX = {
  test: (e) => e === "auto",
  parse: (e) => e
}, tL = (e) => (t) => t.test(e), nL = [fa, $e, Cs, mi, Vq, $q, DX], lS = (e) => nL.find(tL(e));
function jX(e) {
  return typeof e == "number" ? e === 0 : e !== null ? e === "none" || e === "0" || bI(e) : !0;
}
const FX = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
function UX(e) {
  const [t, n] = e.slice(0, -1).split("(");
  if (t === "drop-shadow")
    return e;
  const [r] = n.match(bw) || [];
  if (!r)
    return e;
  const i = n.replace(r, "");
  let s = FX.has(t) ? 1 : 0;
  return r !== n && (s *= 100), t + "(" + s + i + ")";
}
const WX = /\b([a-z-]*)\(.*?\)/gu, pv = {
  ...ha,
  getAnimatableNone: (e) => {
    const t = e.match(WX);
    return t ? t.map(UX).join(" ") : e;
  }
}, uS = {
  ...fa,
  transform: Math.round
}, zX = {
  rotate: mi,
  rotateX: mi,
  rotateY: mi,
  rotateZ: mi,
  scale: ed,
  scaleX: ed,
  scaleY: ed,
  scaleZ: ed,
  skew: mi,
  skewX: mi,
  skewY: mi,
  distance: $e,
  translateX: $e,
  translateY: $e,
  translateZ: $e,
  x: $e,
  y: $e,
  z: $e,
  perspective: $e,
  transformPerspective: $e,
  opacity: Zl,
  originX: Xx,
  originY: Xx,
  originZ: $e
}, Tw = {
  // Border props
  borderWidth: $e,
  borderTopWidth: $e,
  borderRightWidth: $e,
  borderBottomWidth: $e,
  borderLeftWidth: $e,
  borderRadius: $e,
  radius: $e,
  borderTopLeftRadius: $e,
  borderTopRightRadius: $e,
  borderBottomRightRadius: $e,
  borderBottomLeftRadius: $e,
  // Positioning props
  width: $e,
  maxWidth: $e,
  height: $e,
  maxHeight: $e,
  top: $e,
  right: $e,
  bottom: $e,
  left: $e,
  // Spacing props
  padding: $e,
  paddingTop: $e,
  paddingRight: $e,
  paddingBottom: $e,
  paddingLeft: $e,
  margin: $e,
  marginTop: $e,
  marginRight: $e,
  marginBottom: $e,
  marginLeft: $e,
  // Misc
  backgroundPositionX: $e,
  backgroundPositionY: $e,
  ...zX,
  zIndex: uS,
  // SVG
  fillOpacity: Zl,
  strokeOpacity: Zl,
  numOctaves: uS
}, HX = {
  ...Tw,
  // Color props
  color: ht,
  backgroundColor: ht,
  outlineColor: ht,
  fill: ht,
  stroke: ht,
  // Border props
  borderColor: ht,
  borderTopColor: ht,
  borderRightColor: ht,
  borderBottomColor: ht,
  borderLeftColor: ht,
  filter: pv,
  WebkitFilter: pv
}, rL = (e) => HX[e];
function iL(e, t) {
  let n = rL(e);
  return n !== pv && (n = ha), n.getAnimatableNone ? n.getAnimatableNone(t) : void 0;
}
const KX = /* @__PURE__ */ new Set(["auto", "none", "0"]);
function GX(e, t, n) {
  let r = 0, i;
  for (; r < e.length && !i; ) {
    const s = e[r];
    typeof s == "string" && !KX.has(s) && Ql(s).values.length && (i = e[r]), r++;
  }
  if (i && n)
    for (const s of t)
      e[s] = iL(n, i);
}
let YX = class extends Rw {
  constructor(t, n, r, i, s) {
    super(t, n, r, i, s, !0);
  }
  readKeyframes() {
    const { unresolvedKeyframes: t, element: n, name: r } = this;
    if (!n || !n.current)
      return;
    super.readKeyframes();
    for (let d = 0; d < t.length; d++) {
      let h = t[d];
      if (typeof h == "string" && (h = h.trim(), ww(h))) {
        const f = QI(h, n.current);
        f !== void 0 && (t[d] = f), d === t.length - 1 && (this.finalKeyframe = h);
      }
    }
    if (this.resolveNoneKeyframes(), !eL.has(r) || t.length !== 2)
      return;
    const [i, s] = t, l = lS(i), u = lS(s);
    if (l !== u)
      if (iS(l) && iS(u))
        for (let d = 0; d < t.length; d++) {
          const h = t[d];
          typeof h == "string" && (t[d] = parseFloat(h));
        }
      else co[r] && (this.needsMeasurement = !0);
  }
  resolveNoneKeyframes() {
    const { unresolvedKeyframes: t, name: n } = this, r = [];
    for (let i = 0; i < t.length; i++)
      (t[i] === null || jX(t[i])) && r.push(i);
    r.length && GX(t, r, n);
  }
  measureInitialState() {
    const { element: t, unresolvedKeyframes: n, name: r } = this;
    if (!t || !t.current)
      return;
    r === "height" && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = co[r](t.measureViewportBox(), window.getComputedStyle(t.current)), n[0] = this.measuredOrigin;
    const i = n[n.length - 1];
    i !== void 0 && t.getValue(r, i).jump(i, !1);
  }
  measureEndState() {
    var t;
    const { element: n, name: r, unresolvedKeyframes: i } = this;
    if (!n || !n.current)
      return;
    const s = n.getValue(r);
    s && s.jump(this.measuredOrigin, !1);
    const l = i.length - 1, u = i[l];
    i[l] = co[r](n.measureViewportBox(), window.getComputedStyle(n.current)), u !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = u), (t = this.removedTransforms) != null && t.length && this.removedTransforms.forEach(([d, h]) => {
      n.getValue(d).set(h);
    }), this.resolveNoneKeyframes();
  }
};
function qX(e, t, n) {
  if (e instanceof EventTarget)
    return [e];
  if (typeof e == "string") {
    const i = document.querySelectorAll(e);
    return i ? Array.from(i) : [];
  }
  return Array.from(e);
}
const oL = (e, t) => t && typeof e == "number" ? t.transform(e) : e;
function XX(e) {
  return uq(e) && "offsetHeight" in e;
}
const cS = 30, ZX = (e) => !isNaN(parseFloat(e));
let QX = class {
  /**
   * @param init - The initiating value
   * @param config - Optional configuration options
   *
   * -  `transformer`: A function to transform incoming values with.
   */
  constructor(t, n = {}) {
    this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = (r) => {
      var i;
      const s = kn.now();
      if (this.updatedAt !== s && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(r), this.current !== this.prev && ((i = this.events.change) == null || i.notify(this.current), this.dependents))
        for (const l of this.dependents)
          l.dirty();
    }, this.hasAnimated = !1, this.setCurrent(t), this.owner = n.owner;
  }
  setCurrent(t) {
    this.current = t, this.updatedAt = kn.now(), this.canTrackVelocity === null && t !== void 0 && (this.canTrackVelocity = ZX(this.current));
  }
  setPrevFrameValue(t = this.current) {
    this.prevFrameValue = t, this.prevUpdatedAt = this.updatedAt;
  }
  /**
   * Adds a function that will be notified when the `MotionValue` is updated.
   *
   * It returns a function that, when called, will cancel the subscription.
   *
   * When calling `onChange` inside a React component, it should be wrapped with the
   * `useEffect` hook. As it returns an unsubscribe function, this should be returned
   * from the `useEffect` function to ensure you don't add duplicate subscribers..
   *
   * ```jsx
   * export const MyComponent = () => {
   *   const x = useMotionValue(0)
   *   const y = useMotionValue(0)
   *   const opacity = useMotionValue(1)
   *
   *   useEffect(() => {
   *     function updateOpacity() {
   *       const maxXY = Math.max(x.get(), y.get())
   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
   *       opacity.set(newOpacity)
   *     }
   *
   *     const unsubscribeX = x.on("change", updateOpacity)
   *     const unsubscribeY = y.on("change", updateOpacity)
   *
   *     return () => {
   *       unsubscribeX()
   *       unsubscribeY()
   *     }
   *   }, [])
   *
   *   return <motion.div style={{ x }} />
   * }
   * ```
   *
   * @param subscriber - A function that receives the latest value.
   * @returns A function that, when called, will cancel this subscription.
   *
   * @deprecated
   */
  onChange(t) {
    return this.on("change", t);
  }
  on(t, n) {
    this.events[t] || (this.events[t] = new EI());
    const r = this.events[t].add(n);
    return t === "change" ? () => {
      r(), Kn.read(() => {
        this.events.change.getSize() || this.stop();
      });
    } : r;
  }
  clearListeners() {
    for (const t in this.events)
      this.events[t].clear();
  }
  /**
   * Attaches a passive effect to the `MotionValue`.
   */
  attach(t, n) {
    this.passiveEffect = t, this.stopPassiveEffect = n;
  }
  /**
   * Sets the state of the `MotionValue`.
   *
   * @remarks
   *
   * ```jsx
   * const x = useMotionValue(0)
   * x.set(10)
   * ```
   *
   * @param latest - Latest value to set.
   * @param render - Whether to notify render subscribers. Defaults to `true`
   *
   * @public
   */
  set(t) {
    this.passiveEffect ? this.passiveEffect(t, this.updateAndNotify) : this.updateAndNotify(t);
  }
  setWithVelocity(t, n, r) {
    this.set(n), this.prev = void 0, this.prevFrameValue = t, this.prevUpdatedAt = this.updatedAt - r;
  }
  /**
   * Set the state of the `MotionValue`, stopping any active animations,
   * effects, and resets velocity to `0`.
   */
  jump(t, n = !0) {
    this.updateAndNotify(t), this.prev = t, this.prevUpdatedAt = this.prevFrameValue = void 0, n && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
  dirty() {
    var t;
    (t = this.events.change) == null || t.notify(this.current);
  }
  addDependent(t) {
    this.dependents || (this.dependents = /* @__PURE__ */ new Set()), this.dependents.add(t);
  }
  removeDependent(t) {
    this.dependents && this.dependents.delete(t);
  }
  /**
   * Returns the latest state of `MotionValue`
   *
   * @returns - The latest state of `MotionValue`
   *
   * @public
   */
  get() {
    return this.current;
  }
  /**
   * @public
   */
  getPrevious() {
    return this.prev;
  }
  /**
   * Returns the latest velocity of `MotionValue`
   *
   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
   *
   * @public
   */
  getVelocity() {
    const t = kn.now();
    if (!this.canTrackVelocity || this.prevFrameValue === void 0 || t - this.updatedAt > cS)
      return 0;
    const n = Math.min(this.updatedAt - this.prevUpdatedAt, cS);
    return AI(parseFloat(this.current) - parseFloat(this.prevFrameValue), n);
  }
  /**
   * Registers a new animation to control this `MotionValue`. Only one
   * animation can drive a `MotionValue` at one time.
   *
   * ```jsx
   * value.start()
   * ```
   *
   * @param animation - A function that starts the provided animation
   */
  start(t) {
    return this.stop(), new Promise((n) => {
      this.hasAnimated = !0, this.animation = t(n), this.events.animationStart && this.events.animationStart.notify();
    }).then(() => {
      this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation();
    });
  }
  /**
   * Stop the currently active animation.
   *
   * @public
   */
  stop() {
    this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation();
  }
  /**
   * Returns `true` if this value is currently animating.
   *
   * @public
   */
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  /**
   * Destroy and clean up subscribers to this `MotionValue`.
   *
   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
   * created a `MotionValue` via the `motionValue` function.
   *
   * @public
   */
  destroy() {
    var t, n;
    (t = this.dependents) == null || t.clear(), (n = this.events.destroy) == null || n.notify(), this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
};
function Jd(e, t) {
  return new QX(e, t);
}
const { schedule: JX } = /* @__PURE__ */ LI(queueMicrotask, !1), eZ = {
  y: !1
};
function tZ() {
  return eZ.y;
}
function sL(e, t) {
  const n = qX(e), r = new AbortController(), i = {
    passive: !0,
    ...t,
    signal: r.signal
  };
  return [n, i, () => r.abort()];
}
function dS(e) {
  return !(e.pointerType === "touch" || tZ());
}
function nZ(e, t, n = {}) {
  const [r, i, s] = sL(e, n), l = (u) => {
    if (!dS(u))
      return;
    const { target: d } = u, h = t(d, u);
    if (typeof h != "function" || !d)
      return;
    const f = (m) => {
      dS(m) && (h(m), d.removeEventListener("pointerleave", f));
    };
    d.addEventListener("pointerleave", f, i);
  };
  return r.forEach((u) => {
    u.addEventListener("pointerenter", l, i);
  }), s;
}
const aL = (e, t) => t ? e === t ? !0 : aL(e, t.parentElement) : !1, rZ = (e) => e.pointerType === "mouse" ? typeof e.button != "number" || e.button <= 0 : e.isPrimary !== !1, iZ = /* @__PURE__ */ new Set([
  "BUTTON",
  "INPUT",
  "SELECT",
  "TEXTAREA",
  "A"
]);
function oZ(e) {
  return iZ.has(e.tagName) || e.tabIndex !== -1;
}
const Ed = /* @__PURE__ */ new WeakSet();
function fS(e) {
  return (t) => {
    t.key === "Enter" && e(t);
  };
}
function Om(e, t) {
  e.dispatchEvent(new PointerEvent("pointer" + t, { isPrimary: !0, bubbles: !0 }));
}
const sZ = (e, t) => {
  const n = e.currentTarget;
  if (!n)
    return;
  const r = fS(() => {
    if (Ed.has(n))
      return;
    Om(n, "down");
    const i = fS(() => {
      Om(n, "up");
    }), s = () => Om(n, "cancel");
    n.addEventListener("keyup", i, t), n.addEventListener("blur", s, t);
  });
  n.addEventListener("keydown", r, t), n.addEventListener("blur", () => n.removeEventListener("keydown", r), t);
};
function hS(e) {
  return rZ(e) && !0;
}
function aZ(e, t, n = {}) {
  const [r, i, s] = sL(e, n), l = (u) => {
    const d = u.currentTarget;
    if (!hS(u))
      return;
    Ed.add(d);
    const h = t(d, u), f = (w, E) => {
      window.removeEventListener("pointerup", m), window.removeEventListener("pointercancel", g), Ed.has(d) && Ed.delete(d), hS(w) && typeof h == "function" && h(w, { success: E });
    }, m = (w) => {
      f(w, d === window || d === document || n.useGlobalTarget || aL(d, w.target));
    }, g = (w) => {
      f(w, !1);
    };
    window.addEventListener("pointerup", m, i), window.addEventListener("pointercancel", g, i);
  };
  return r.forEach((u) => {
    (n.useGlobalTarget ? window : u).addEventListener("pointerdown", l, i), XX(u) && (u.addEventListener("focus", (d) => sZ(d, i)), !oZ(u) && !u.hasAttribute("tabindex") && (u.tabIndex = 0));
  }), s;
}
const jt = (e) => !!(e && e.getVelocity), lZ = [...nL, ht, ha], uZ = (e) => lZ.find(tL(e)), lL = C.createContext({
  transformPagePoint: (e) => e,
  isStatic: !1,
  reducedMotion: "never"
}), $w = C.createContext({ strict: !1 }), pS = {
  animation: [
    "animate",
    "variants",
    "whileHover",
    "whileTap",
    "exit",
    "whileInView",
    "whileFocus",
    "whileDrag"
  ],
  exit: ["exit"],
  drag: ["drag", "dragControls"],
  focus: ["whileFocus"],
  hover: ["whileHover", "onHoverStart", "onHoverEnd"],
  tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
  pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
  inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
  layout: ["layout", "layoutId"]
}, Ws = {};
for (const e in pS)
  Ws[e] = {
    isEnabled: (t) => pS[e].some((n) => !!t[n])
  };
function mS(e) {
  for (const t in e)
    Ws[t] = {
      ...Ws[t],
      ...e[t]
    };
}
function cZ({ children: e, features: t, strict: n = !1 }) {
  const [, r] = C.useState(!Bm(t)), i = C.useRef(void 0);
  if (!Bm(t)) {
    const { renderer: s, ...l } = t;
    i.current = s, mS(l);
  }
  return C.useEffect(() => {
    Bm(t) && t().then(({ renderer: s, ...l }) => {
      mS(l), i.current = s, r(!0);
    });
  }, []), I.jsx($w.Provider, { value: { renderer: i.current, strict: n }, children: e });
}
function Bm(e) {
  return typeof e == "function";
}
const dZ = /* @__PURE__ */ new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "custom",
  "inherit",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "globalTapTarget",
  "ignoreStrict",
  "viewport"
]);
function Vw(e) {
  return e.startsWith("while") || e.startsWith("drag") && e !== "draggable" || e.startsWith("layout") || e.startsWith("onTap") || e.startsWith("onPan") || e.startsWith("onLayout") || dZ.has(e);
}
let uL = (e) => !Vw(e);
function fZ(e) {
  typeof e == "function" && (uL = (t) => t.startsWith("on") ? !Vw(t) : e(t));
}
try {
  fZ(require("@emotion/is-prop-valid").default);
} catch {
}
function hZ(e, t, n) {
  const r = {};
  for (const i in e)
    i === "values" && typeof e.values == "object" || (uL(i) || n === !0 && Vw(i) || // If trying to use native HTML drag events, forward drag listeners
    e.draggable && i.startsWith("onDrag")) && (r[i] = e[i]);
  return r;
}
const jf = /* @__PURE__ */ C.createContext({});
function Ff(e) {
  return e !== null && typeof e == "object" && typeof e.start == "function";
}
function Jl(e) {
  return typeof e == "string" || Array.isArray(e);
}
const _w = [
  "animate",
  "whileInView",
  "whileFocus",
  "whileHover",
  "whileTap",
  "whileDrag",
  "exit"
], Iw = ["initial", ..._w];
function Uf(e) {
  return Ff(e.animate) || Iw.some((t) => Jl(e[t]));
}
function cL(e) {
  return !!(Uf(e) || e.variants);
}
function pZ(e, t) {
  if (Uf(e)) {
    const { initial: n, animate: r } = e;
    return {
      initial: n === !1 || Jl(n) ? n : void 0,
      animate: Jl(r) ? r : void 0
    };
  }
  return e.inherit !== !1 ? t : {};
}
function mZ(e) {
  const { initial: t, animate: n } = pZ(e, C.useContext(jf));
  return C.useMemo(() => ({ initial: t, animate: n }), [gS(t), gS(n)]);
}
function gS(e) {
  return Array.isArray(e) ? e.join(" ") : e;
}
const gZ = {};
function dL(e, { layout: t, layoutId: n }) {
  return ma.has(e) || e.startsWith("origin") || (t || n !== void 0) && (!!gZ[e] || e === "opacity");
}
const vZ = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
}, yZ = pa.length;
function wZ(e, t, n) {
  let r = "", i = !0;
  for (let s = 0; s < yZ; s++) {
    const l = pa[s], u = e[l];
    if (u === void 0)
      continue;
    let d = !0;
    if (typeof u == "number" ? d = u === (l.startsWith("scale") ? 1 : 0) : d = parseFloat(u) === 0, !d || n) {
      const h = oL(u, Tw[l]);
      if (!d) {
        i = !1;
        const f = vZ[l] || l;
        r += `${f}(${h}) `;
      }
      n && (t[l] = h);
    }
  }
  return r = r.trim(), n ? r = n(t, i ? "" : r) : i && (r = "none"), r;
}
function Lw(e, t, n) {
  const { style: r, vars: i, transformOrigin: s } = e;
  let l = !1, u = !1;
  for (const d in t) {
    const h = t[d];
    if (ma.has(d)) {
      l = !0;
      continue;
    } else if (MI(d)) {
      i[d] = h;
      continue;
    } else {
      const f = oL(h, Tw[d]);
      d.startsWith("origin") ? (u = !0, s[d] = f) : r[d] = f;
    }
  }
  if (t.transform || (l || n ? r.transform = wZ(t, e.transform, n) : r.transform && (r.transform = "none")), u) {
    const { originX: d = "50%", originY: h = "50%", originZ: f = 0 } = s;
    r.transformOrigin = `${d} ${h} ${f}`;
  }
}
const Pw = () => ({
  style: {},
  transform: {},
  transformOrigin: {},
  vars: {}
});
function fL(e, t, n) {
  for (const r in t)
    !jt(t[r]) && !dL(r, n) && (e[r] = t[r]);
}
function bZ({ transformTemplate: e }, t) {
  return C.useMemo(() => {
    const n = Pw();
    return Lw(n, t, e), Object.assign({}, n.vars, n.style);
  }, [t]);
}
function CZ(e, t) {
  const n = e.style || {}, r = {};
  return fL(r, n, e), Object.assign(r, bZ(e, t)), r;
}
function EZ(e, t) {
  const n = {}, r = CZ(e, t);
  return e.drag && e.dragListener !== !1 && (n.draggable = !1, r.userSelect = r.WebkitUserSelect = r.WebkitTouchCallout = "none", r.touchAction = e.drag === !0 ? "none" : `pan-${e.drag === "x" ? "y" : "x"}`), e.tabIndex === void 0 && (e.onTap || e.onTapStart || e.whileTap) && (n.tabIndex = 0), n.style = r, n;
}
const AZ = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
}, xZ = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function SZ(e, t, n = 1, r = 0, i = !0) {
  e.pathLength = 1;
  const s = i ? AZ : xZ;
  e[s.offset] = $e.transform(-r);
  const l = $e.transform(t), u = $e.transform(n);
  e[s.array] = `${l} ${u}`;
}
function hL(e, {
  attrX: t,
  attrY: n,
  attrScale: r,
  pathLength: i,
  pathSpacing: s = 1,
  pathOffset: l = 0,
  // This is object creation, which we try to avoid per-frame.
  ...u
}, d, h, f) {
  if (Lw(e, u, h), d) {
    e.style.viewBox && (e.attrs.viewBox = e.style.viewBox);
    return;
  }
  e.attrs = e.style, e.style = {};
  const { attrs: m, style: g } = e;
  m.transform && (g.transform = m.transform, delete m.transform), (g.transform || m.transformOrigin) && (g.transformOrigin = m.transformOrigin ?? "50% 50%", delete m.transformOrigin), g.transform && (g.transformBox = (f == null ? void 0 : f.transformBox) ?? "fill-box", delete m.transformBox), t !== void 0 && (m.x = t), n !== void 0 && (m.y = n), r !== void 0 && (m.scale = r), i !== void 0 && SZ(m, i, s, l, !1);
}
const pL = () => ({
  ...Pw(),
  attrs: {}
}), mL = (e) => typeof e == "string" && e.toLowerCase() === "svg";
function kZ(e, t, n, r) {
  const i = C.useMemo(() => {
    const s = pL();
    return hL(s, t, mL(r), e.transformTemplate, e.style), {
      ...s.attrs,
      style: { ...s.style }
    };
  }, [t]);
  if (e.style) {
    const s = {};
    fL(s, e.style, e), i.style = { ...s, ...i.style };
  }
  return i;
}
const RZ = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view"
];
function Mw(e) {
  return (
    /**
     * If it's not a string, it's a custom React component. Currently we only support
     * HTML custom React components.
     */
    typeof e != "string" || /**
    * If it contains a dash, the element is a custom HTML webcomponent.
    */
    e.includes("-") ? !1 : (
      /**
       * If it's in our list of lowercase SVG tags, it's an SVG component
       */
      !!(RZ.indexOf(e) > -1 || /**
      * If it contains a capital letter, it's an SVG component
      */
      /[A-Z]/u.test(e))
    )
  );
}
function TZ(e, t, n, { latestValues: r }, i, s = !1) {
  const l = (Mw(e) ? kZ : EZ)(t, r, i, e), u = hZ(t, typeof e == "string", s), d = e !== C.Fragment ? { ...u, ...l, ref: n } : {}, { children: h } = t, f = C.useMemo(() => jt(h) ? h.get() : h, [h]);
  return C.createElement(e, {
    ...d,
    children: f
  });
}
function vS(e) {
  const t = [{}, {}];
  return e == null || e.values.forEach((n, r) => {
    t[0][r] = n.get(), t[1][r] = n.getVelocity();
  }), t;
}
function Ow(e, t, n, r) {
  if (typeof t == "function") {
    const [i, s] = vS(r);
    t = t(n !== void 0 ? n : e.custom, i, s);
  }
  if (typeof t == "string" && (t = e.variants && e.variants[t]), typeof t == "function") {
    const [i, s] = vS(r);
    t = t(n !== void 0 ? n : e.custom, i, s);
  }
  return t;
}
function $Z(e) {
  return jt(e) ? e.get() : e;
}
function VZ({ scrapeMotionValuesFromProps: e, createRenderState: t }, n, r, i) {
  return {
    latestValues: _Z(n, r, i, e),
    renderState: t()
  };
}
function _Z(e, t, n, r) {
  const i = {}, s = r(e, {});
  for (const g in s)
    i[g] = $Z(s[g]);
  let { initial: l, animate: u } = e;
  const d = Uf(e), h = cL(e);
  t && h && !d && e.inherit !== !1 && (l === void 0 && (l = t.initial), u === void 0 && (u = t.animate));
  let f = n ? n.initial === !1 : !1;
  f = f || l === !1;
  const m = f ? u : l;
  if (m && typeof m != "boolean" && !Ff(m)) {
    const g = Array.isArray(m) ? m : [m];
    for (let w = 0; w < g.length; w++) {
      const E = Ow(e, g[w]);
      if (E) {
        const { transitionEnd: b, transition: A, ...x } = E;
        for (const R in x) {
          let _ = x[R];
          if (Array.isArray(_)) {
            const L = f ? _.length - 1 : 0;
            _ = _[L];
          }
          _ !== null && (i[R] = _);
        }
        for (const R in b)
          i[R] = b[R];
      }
    }
  }
  return i;
}
const gL = (e) => (t, n) => {
  const r = C.useContext(jf), i = C.useContext(yI), s = () => VZ(e, t, r, i);
  return n ? s() : oq(s);
};
function Bw(e, t, n) {
  var r;
  const { style: i } = e, s = {};
  for (const l in i)
    (jt(i[l]) || t.style && jt(t.style[l]) || dL(l, e) || ((r = n == null ? void 0 : n.getValue(l)) == null ? void 0 : r.liveStyle) !== void 0) && (s[l] = i[l]);
  return s;
}
const IZ = /* @__PURE__ */ gL({
  scrapeMotionValuesFromProps: Bw,
  createRenderState: Pw
});
function vL(e, t, n) {
  const r = Bw(e, t, n);
  for (const i in e)
    if (jt(e[i]) || jt(t[i])) {
      const s = pa.indexOf(i) !== -1 ? "attr" + i.charAt(0).toUpperCase() + i.substring(1) : i;
      r[s] = e[i];
    }
  return r;
}
const LZ = /* @__PURE__ */ gL({
  scrapeMotionValuesFromProps: vL,
  createRenderState: pL
}), PZ = Symbol.for("motionComponentSymbol");
function yL(e) {
  return e && typeof e == "object" && Object.prototype.hasOwnProperty.call(e, "current");
}
function MZ(e, t, n) {
  return C.useCallback(
    (r) => {
      r && e.onMount && e.onMount(r), t && (r ? t.mount(r) : t.unmount()), n && (typeof n == "function" ? n(r) : yL(n) && (n.current = r));
    },
    /**
     * Only pass a new ref callback to React if we've received a visual element
     * factory. Otherwise we'll be mounting/remounting every time externalRef
     * or other dependencies change.
     */
    [t]
  );
}
const Nw = (e) => e.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(), OZ = "framerAppearId", wL = "data-" + Nw(OZ), BZ = C.createContext({});
function NZ(e, t, n, r, i) {
  var s, l;
  const { visualElement: u } = C.useContext(jf), d = C.useContext($w), h = C.useContext(yI), f = C.useContext(lL).reducedMotion, m = C.useRef(null);
  r = r || d.renderer, !m.current && r && (m.current = r(e, {
    visualState: t,
    parent: u,
    props: n,
    presenceContext: h,
    blockInitialAnimation: h ? h.initial === !1 : !1,
    reducedMotionConfig: f
  }));
  const g = m.current, w = C.useContext(BZ);
  g && !g.projection && i && (g.type === "html" || g.type === "svg") && DZ(m.current, n, i, w);
  const E = C.useRef(!1);
  C.useInsertionEffect(() => {
    g && E.current && g.update(n, h);
  });
  const b = n[wL], A = C.useRef(!!b && !((s = window.MotionHandoffIsComplete) != null && s.call(window, b)) && ((l = window.MotionHasOptimisedAnimation) == null ? void 0 : l.call(window, b)));
  return sq(() => {
    g && (E.current = !0, window.MotionIsMounted = !0, g.updateFeatures(), g.scheduleRenderMicrotask(), A.current && g.animationState && g.animationState.animateChanges());
  }), C.useEffect(() => {
    g && (!A.current && g.animationState && g.animationState.animateChanges(), A.current && (queueMicrotask(() => {
      var x;
      (x = window.MotionHandoffMarkAsComplete) == null || x.call(window, b);
    }), A.current = !1), g.enteringChildren = void 0);
  }), g;
}
function DZ(e, t, n, r) {
  const { layoutId: i, layout: s, drag: l, dragConstraints: u, layoutScroll: d, layoutRoot: h, layoutCrossfade: f } = t;
  e.projection = new n(e.latestValues, t["data-framer-portal-id"] ? void 0 : bL(e.parent)), e.projection.setOptions({
    layoutId: i,
    layout: s,
    alwaysMeasureLayout: !!l || u && yL(u),
    visualElement: e,
    /**
     * TODO: Update options in an effect. This could be tricky as it'll be too late
     * to update by the time layout animations run.
     * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
     * ensuring it gets called if there's no potential layout animations.
     *
     */
    animationType: typeof s == "string" ? s : "both",
    initialPromotionConfig: r,
    crossfade: f,
    layoutScroll: d,
    layoutRoot: h
  });
}
function bL(e) {
  if (e)
    return e.options.allowProjection !== !1 ? e.projection : bL(e.parent);
}
function jZ(e, { forwardMotionProps: t = !1 } = {}, n, r) {
  const i = Mw(e) ? LZ : IZ;
  function s(u, d) {
    let h;
    const f = {
      ...C.useContext(lL),
      ...u,
      layoutId: FZ(u)
    }, { isStatic: m } = f, g = mZ(u), w = i(u, m);
    if (!m && pw) {
      UZ();
      const E = WZ(f);
      h = E.MeasureLayout, g.visualElement = NZ(e, w, f, r, E.ProjectionNode);
    }
    return I.jsxs(jf.Provider, { value: g, children: [h && g.visualElement ? I.jsx(h, { visualElement: g.visualElement, ...f }) : null, TZ(e, u, MZ(w, g.visualElement, d), w, m, t)] });
  }
  s.displayName = `motion.${e}`;
  const l = C.forwardRef(s);
  return l[PZ] = e, l;
}
function FZ({ layoutId: e }) {
  const t = C.useContext(iq).id;
  return t && e !== void 0 ? t + "-" + e : e;
}
function UZ(e, t) {
  C.useContext($w).strict;
}
function WZ(e) {
  const { drag: t, layout: n } = Ws;
  if (!t && !n)
    return {};
  const r = { ...t, ...n };
  return {
    MeasureLayout: t != null && t.isEnabled(e) || n != null && n.isEnabled(e) ? r.MeasureLayout : void 0,
    ProjectionNode: r.ProjectionNode
  };
}
function zZ({ top: e, left: t, right: n, bottom: r }) {
  return {
    x: { min: t, max: n },
    y: { min: e, max: r }
  };
}
function HZ(e, t) {
  if (!t)
    return e;
  const n = t({ x: e.left, y: e.top }), r = t({ x: e.right, y: e.bottom });
  return {
    top: n.y,
    left: n.x,
    bottom: r.y,
    right: r.x
  };
}
function KZ(e, t) {
  return zZ(HZ(e.getBoundingClientRect(), t));
}
const yS = () => ({ min: 0, max: 0 }), CL = () => ({
  x: yS(),
  y: yS()
}), mv = { current: null }, EL = { current: !1 };
function GZ() {
  if (EL.current = !0, !!pw)
    if (window.matchMedia) {
      const e = window.matchMedia("(prefers-reduced-motion)"), t = () => mv.current = e.matches;
      e.addEventListener("change", t), t();
    } else
      mv.current = !1;
}
const YZ = /* @__PURE__ */ new WeakMap();
function qZ(e, t, n) {
  for (const r in t) {
    const i = t[r], s = n[r];
    if (jt(i))
      e.addValue(r, i);
    else if (jt(s))
      e.addValue(r, Jd(i, { owner: e }));
    else if (s !== i)
      if (e.hasValue(r)) {
        const l = e.getValue(r);
        l.liveStyle === !0 ? l.jump(i) : l.hasAnimated || l.set(i);
      } else {
        const l = e.getStaticValue(r);
        e.addValue(r, Jd(l !== void 0 ? l : i, { owner: e }));
      }
  }
  for (const r in n)
    t[r] === void 0 && e.removeValue(r);
  return t;
}
const wS = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete"
];
let XZ = class {
  /**
   * This method takes React props and returns found MotionValues. For example, HTML
   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
   *
   * This isn't an abstract method as it needs calling in the constructor, but it is
   * intended to be one.
   */
  scrapeMotionValuesFromProps(t, n, r) {
    return {};
  }
  constructor({ parent: t, props: n, presenceContext: r, reducedMotionConfig: i, blockInitialAnimation: s, visualState: l }, u = {}) {
    this.current = null, this.children = /* @__PURE__ */ new Set(), this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = /* @__PURE__ */ new Map(), this.KeyframeResolver = Rw, this.features = {}, this.valueSubscriptions = /* @__PURE__ */ new Map(), this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => {
      this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection));
    }, this.renderScheduledAt = 0, this.scheduleRender = () => {
      const g = kn.now();
      this.renderScheduledAt < g && (this.renderScheduledAt = g, Kn.render(this.render, !1, !0));
    };
    const { latestValues: d, renderState: h } = l;
    this.latestValues = d, this.baseTarget = { ...d }, this.initialValues = n.initial ? { ...d } : {}, this.renderState = h, this.parent = t, this.props = n, this.presenceContext = r, this.depth = t ? t.depth + 1 : 0, this.reducedMotionConfig = i, this.options = u, this.blockInitialAnimation = !!s, this.isControllingVariants = Uf(n), this.isVariantNode = cL(n), this.isVariantNode && (this.variantChildren = /* @__PURE__ */ new Set()), this.manuallyAnimateOnMount = !!(t && t.current);
    const { willChange: f, ...m } = this.scrapeMotionValuesFromProps(n, {}, this);
    for (const g in m) {
      const w = m[g];
      d[g] !== void 0 && jt(w) && w.set(d[g]);
    }
  }
  mount(t) {
    var n;
    this.current = t, YZ.set(t, this), this.projection && !this.projection.instance && this.projection.mount(t), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((r, i) => this.bindToMotionValue(i, r)), EL.current || GZ(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : mv.current, (n = this.parent) == null || n.addChild(this), this.update(this.props, this.presenceContext);
  }
  unmount() {
    var t;
    this.projection && this.projection.unmount(), tv(this.notifyUpdate), tv(this.render), this.valueSubscriptions.forEach((n) => n()), this.valueSubscriptions.clear(), this.removeFromVariantTree && this.removeFromVariantTree(), (t = this.parent) == null || t.removeChild(this);
    for (const n in this.events)
      this.events[n].clear();
    for (const n in this.features) {
      const r = this.features[n];
      r && (r.unmount(), r.isMounted = !1);
    }
    this.current = null;
  }
  addChild(t) {
    this.children.add(t), this.enteringChildren ?? (this.enteringChildren = /* @__PURE__ */ new Set()), this.enteringChildren.add(t);
  }
  removeChild(t) {
    this.children.delete(t), this.enteringChildren && this.enteringChildren.delete(t);
  }
  bindToMotionValue(t, n) {
    this.valueSubscriptions.has(t) && this.valueSubscriptions.get(t)();
    const r = ma.has(t);
    r && this.onBindTransform && this.onBindTransform();
    const i = n.on("change", (l) => {
      this.latestValues[t] = l, this.props.onUpdate && Kn.preRender(this.notifyUpdate), r && this.projection && (this.projection.isTransformDirty = !0), this.scheduleRender();
    });
    let s;
    window.MotionCheckAppearSync && (s = window.MotionCheckAppearSync(this, t, n)), this.valueSubscriptions.set(t, () => {
      i(), s && s(), n.owner && n.stop();
    });
  }
  sortNodePosition(t) {
    return !this.current || !this.sortInstanceNodePosition || this.type !== t.type ? 0 : this.sortInstanceNodePosition(this.current, t.current);
  }
  updateFeatures() {
    let t = "animation";
    for (t in Ws) {
      const n = Ws[t];
      if (!n)
        continue;
      const { isEnabled: r, Feature: i } = n;
      if (!this.features[t] && i && r(this.props) && (this.features[t] = new i(this)), this.features[t]) {
        const s = this.features[t];
        s.isMounted ? s.update() : (s.mount(), s.isMounted = !0);
      }
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.props);
  }
  /**
   * Measure the current viewport box with or without transforms.
   * Only measures axis-aligned boxes, rotate and skew must be manually
   * removed with a re-render to work.
   */
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : CL();
  }
  getStaticValue(t) {
    return this.latestValues[t];
  }
  setStaticValue(t, n) {
    this.latestValues[t] = n;
  }
  /**
   * Update the provided props. Ensure any newly-added motion values are
   * added to our map, old ones removed, and listeners updated.
   */
  update(t, n) {
    (t.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = t, this.prevPresenceContext = this.presenceContext, this.presenceContext = n;
    for (let r = 0; r < wS.length; r++) {
      const i = wS[r];
      this.propEventSubscriptions[i] && (this.propEventSubscriptions[i](), delete this.propEventSubscriptions[i]);
      const s = "on" + i, l = t[s];
      l && (this.propEventSubscriptions[i] = this.on(i, l));
    }
    this.prevMotionValues = qZ(this, this.scrapeMotionValuesFromProps(t, this.prevProps, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue();
  }
  getProps() {
    return this.props;
  }
  /**
   * Returns the variant definition with a given name.
   */
  getVariant(t) {
    return this.props.variants ? this.props.variants[t] : void 0;
  }
  /**
   * Returns the defined default transition on this component.
   */
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
  }
  /**
   * Add a child visual element to our set of children.
   */
  addVariantChild(t) {
    const n = this.getClosestVariantNode();
    if (n)
      return n.variantChildren && n.variantChildren.add(t), () => n.variantChildren.delete(t);
  }
  /**
   * Add a motion value and bind it to this visual element.
   */
  addValue(t, n) {
    const r = this.values.get(t);
    n !== r && (r && this.removeValue(t), this.bindToMotionValue(t, n), this.values.set(t, n), this.latestValues[t] = n.get());
  }
  /**
   * Remove a motion value and unbind any active subscriptions.
   */
  removeValue(t) {
    this.values.delete(t);
    const n = this.valueSubscriptions.get(t);
    n && (n(), this.valueSubscriptions.delete(t)), delete this.latestValues[t], this.removeValueFromRenderState(t, this.renderState);
  }
  /**
   * Check whether we have a motion value for this key
   */
  hasValue(t) {
    return this.values.has(t);
  }
  getValue(t, n) {
    if (this.props.values && this.props.values[t])
      return this.props.values[t];
    let r = this.values.get(t);
    return r === void 0 && n !== void 0 && (r = Jd(n === null ? void 0 : n, { owner: this }), this.addValue(t, r)), r;
  }
  /**
   * If we're trying to animate to a previously unencountered value,
   * we need to check for it in our state and as a last resort read it
   * directly from the instance (which might have performance implications).
   */
  readValue(t, n) {
    let r = this.latestValues[t] !== void 0 || !this.current ? this.latestValues[t] : this.getBaseTargetFromProps(this.props, t) ?? this.readValueFromInstance(this.current, t, this.options);
    return r != null && (typeof r == "string" && (wI(r) || bI(r)) ? r = parseFloat(r) : !uZ(r) && ha.test(n) && (r = iL(t, n)), this.setBaseTarget(t, jt(r) ? r.get() : r)), jt(r) ? r.get() : r;
  }
  /**
   * Set the base target to later animate back to. This is currently
   * only hydrated on creation and when we first read a value.
   */
  setBaseTarget(t, n) {
    this.baseTarget[t] = n;
  }
  /**
   * Find the base target for a value thats been removed from all animation
   * props.
   */
  getBaseTarget(t) {
    var n;
    const { initial: r } = this.props;
    let i;
    if (typeof r == "string" || typeof r == "object") {
      const l = Ow(this.props, r, (n = this.presenceContext) == null ? void 0 : n.custom);
      l && (i = l[t]);
    }
    if (r && i !== void 0)
      return i;
    const s = this.getBaseTargetFromProps(this.props, t);
    return s !== void 0 && !jt(s) ? s : this.initialValues[t] !== void 0 && i === void 0 ? void 0 : this.baseTarget[t];
  }
  on(t, n) {
    return this.events[t] || (this.events[t] = new EI()), this.events[t].add(n);
  }
  notify(t, ...n) {
    this.events[t] && this.events[t].notify(...n);
  }
  scheduleRenderMicrotask() {
    JX.render(this.render);
  }
}, AL = class extends XZ {
  constructor() {
    super(...arguments), this.KeyframeResolver = YX;
  }
  sortInstanceNodePosition(t, n) {
    return t.compareDocumentPosition(n) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(t, n) {
    return t.style ? t.style[n] : void 0;
  }
  removeValueFromRenderState(t, { vars: n, style: r }) {
    delete n[t], delete r[t];
  }
  handleChildMotionValue() {
    this.childSubscription && (this.childSubscription(), delete this.childSubscription);
    const { children: t } = this.props;
    jt(t) && (this.childSubscription = t.on("change", (n) => {
      this.current && (this.current.textContent = `${n}`);
    }));
  }
};
function xL(e, { style: t, vars: n }, r, i) {
  const s = e.style;
  let l;
  for (l in t)
    s[l] = t[l];
  i == null || i.applyProjectionStyles(s, r);
  for (l in n)
    s.setProperty(l, n[l]);
}
function ZZ(e) {
  return window.getComputedStyle(e);
}
let QZ = class extends AL {
  constructor() {
    super(...arguments), this.type = "html", this.renderInstance = xL;
  }
  readValueFromInstance(t, n) {
    var r;
    if (ma.has(n))
      return (r = this.projection) != null && r.isProjecting ? lv(n) : hX(t, n);
    {
      const i = ZZ(t), s = (MI(n) ? i.getPropertyValue(n) : i[n]) || 0;
      return typeof s == "string" ? s.trim() : s;
    }
  }
  measureInstanceViewportBox(t, { transformPagePoint: n }) {
    return KZ(t, n);
  }
  build(t, n, r) {
    Lw(t, n, r.transformTemplate);
  }
  scrapeMotionValuesFromProps(t, n, r) {
    return Bw(t, n, r);
  }
};
const SL = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust"
]);
function JZ(e, t, n, r) {
  xL(e, t, void 0, r);
  for (const i in t.attrs)
    e.setAttribute(SL.has(i) ? i : Nw(i), t.attrs[i]);
}
let eQ = class extends AL {
  constructor() {
    super(...arguments), this.type = "svg", this.isSVGTag = !1, this.measureInstanceViewportBox = CL;
  }
  getBaseTargetFromProps(t, n) {
    return t[n];
  }
  readValueFromInstance(t, n) {
    if (ma.has(n)) {
      const r = rL(n);
      return r && r.default || 0;
    }
    return n = SL.has(n) ? n : Nw(n), t.getAttribute(n);
  }
  scrapeMotionValuesFromProps(t, n, r) {
    return vL(t, n, r);
  }
  build(t, n, r) {
    hL(t, n, this.isSVGTag, r.transformTemplate, r.style);
  }
  renderInstance(t, n, r, i) {
    JZ(t, n, r, i);
  }
  mount(t) {
    this.isSVGTag = mL(t.tagName), super.mount(t);
  }
};
const tQ = (e, t) => Mw(e) ? new eQ(t) : new QZ(t, {
  allowProjection: e !== C.Fragment
});
function Es(e, t, n) {
  const r = e.getProps();
  return Ow(r, t, n !== void 0 ? n : r.custom, e);
}
const gv = (e) => Array.isArray(e);
function nQ(e, t, n) {
  e.hasValue(t) ? e.getValue(t).set(n) : e.addValue(t, Jd(n));
}
function rQ(e) {
  return gv(e) ? e[e.length - 1] || 0 : e;
}
function iQ(e, t) {
  const n = Es(e, t);
  let { transitionEnd: r = {}, transition: i = {}, ...s } = n || {};
  s = { ...s, ...r };
  for (const l in s) {
    const u = rQ(s[l]);
    nQ(e, l, u);
  }
}
function oQ(e) {
  return !!(jt(e) && e.add);
}
function sQ(e, t) {
  const n = e.getValue("willChange");
  if (oQ(n))
    return n.add(t);
  if (!n && jr.WillChange) {
    const r = new jr.WillChange("auto");
    e.addValue("willChange", r), r.add(t);
  }
}
function aQ(e) {
  return e.props[wL];
}
const lQ = (e) => e !== null;
function uQ(e, { repeat: t, repeatType: n = "loop" }, r) {
  const i = e.filter(lQ), s = t && n !== "loop" && t % 2 === 1 ? 0 : i.length - 1;
  return i[s];
}
const cQ = {
  type: "spring",
  stiffness: 500,
  damping: 25,
  restSpeed: 10
}, dQ = (e) => ({
  type: "spring",
  stiffness: 550,
  damping: e === 0 ? 2 * Math.sqrt(550) : 30,
  restSpeed: 10
}), fQ = {
  type: "keyframes",
  duration: 0.8
}, hQ = {
  type: "keyframes",
  ease: [0.25, 0.1, 0.35, 1],
  duration: 0.3
}, pQ = (e, { keyframes: t }) => t.length > 2 ? fQ : ma.has(e) ? e.startsWith("scale") ? dQ(t[1]) : cQ : hQ;
function mQ({ when: e, delay: t, delayChildren: n, staggerChildren: r, staggerDirection: i, repeat: s, repeatType: l, repeatDelay: u, from: d, elapsed: h, ...f }) {
  return !!Object.keys(f).length;
}
const gQ = (e, t, n, r = {}, i, s) => (l) => {
  const u = JI(r, e) || {}, d = u.delay || r.delay || 0;
  let { elapsed: h = 0 } = r;
  h = h - /* @__PURE__ */ $r(d);
  const f = {
    keyframes: Array.isArray(n) ? n : [null, n],
    ease: "easeOut",
    velocity: t.getVelocity(),
    ...u,
    delay: -h,
    onUpdate: (g) => {
      t.set(g), u.onUpdate && u.onUpdate(g);
    },
    onComplete: () => {
      l(), u.onComplete && u.onComplete();
    },
    name: e,
    motionValue: t,
    element: s ? void 0 : i
  };
  mQ(u) || Object.assign(f, pQ(e, f)), f.duration && (f.duration = /* @__PURE__ */ $r(f.duration)), f.repeatDelay && (f.repeatDelay = /* @__PURE__ */ $r(f.repeatDelay)), f.from !== void 0 && (f.keyframes[0] = f.from);
  let m = !1;
  if ((f.type === !1 || f.duration === 0 && !f.repeatDelay) && (hv(f), f.delay === 0 && (m = !0)), (jr.instantAnimations || jr.skipAnimations) && (m = !0, hv(f), f.delay = 0), f.allowFlatten = !u.type && !u.ease, m && !s && t.get() !== void 0) {
    const g = uQ(f.keyframes, u);
    if (g !== void 0) {
      Kn.update(() => {
        f.onUpdate(g), f.onComplete();
      });
      return;
    }
  }
  return u.isSync ? new kw(f) : new OX(f);
};
function vQ({ protectedKeys: e, needsAnimating: t }, n) {
  const r = e.hasOwnProperty(n) && t[n] !== !0;
  return t[n] = !1, r;
}
function kL(e, t, { delay: n = 0, transitionOverride: r, type: i } = {}) {
  let { transition: s = e.getDefaultTransition(), transitionEnd: l, ...u } = t;
  r && (s = r);
  const d = [], h = i && e.animationState && e.animationState.getState()[i];
  for (const f in u) {
    const m = e.getValue(f, e.latestValues[f] ?? null), g = u[f];
    if (g === void 0 || h && vQ(h, f))
      continue;
    const w = {
      delay: n,
      ...JI(s || {}, f)
    }, E = m.get();
    if (E !== void 0 && !m.isAnimating && !Array.isArray(g) && g === E && !w.velocity)
      continue;
    let b = !1;
    if (window.MotionHandoffAnimation) {
      const x = aQ(e);
      if (x) {
        const R = window.MotionHandoffAnimation(x, f, Kn);
        R !== null && (w.startTime = R, b = !0);
      }
    }
    sQ(e, f), m.start(gQ(f, m, g, e.shouldReduceMotion && eL.has(f) ? { type: !1 } : w, e, b));
    const A = m.animation;
    A && d.push(A);
  }
  return l && Promise.all(d).then(() => {
    Kn.update(() => {
      l && iQ(e, l);
    });
  }), d;
}
function RL(e, t, n, r = 0, i = 1) {
  const s = Array.from(e).sort((d, h) => d.sortNodePosition(h)).indexOf(t), l = e.size, u = (l - 1) * r;
  return typeof n == "function" ? n(s, l) : i === 1 ? s * r : u - s * r;
}
function vv(e, t, n = {}) {
  var r;
  const i = Es(e, t, n.type === "exit" ? (r = e.presenceContext) == null ? void 0 : r.custom : void 0);
  let { transition: s = e.getDefaultTransition() || {} } = i || {};
  n.transitionOverride && (s = n.transitionOverride);
  const l = i ? () => Promise.all(kL(e, i, n)) : () => Promise.resolve(), u = e.variantChildren && e.variantChildren.size ? (h = 0) => {
    const { delayChildren: f = 0, staggerChildren: m, staggerDirection: g } = s;
    return yQ(e, t, h, f, m, g, n);
  } : () => Promise.resolve(), { when: d } = s;
  if (d) {
    const [h, f] = d === "beforeChildren" ? [l, u] : [u, l];
    return h().then(() => f());
  } else
    return Promise.all([l(), u(n.delay)]);
}
function yQ(e, t, n = 0, r = 0, i = 0, s = 1, l) {
  const u = [];
  for (const d of e.variantChildren)
    d.notify("AnimationStart", t), u.push(vv(d, t, {
      ...l,
      delay: n + (typeof r == "function" ? 0 : r) + RL(e.variantChildren, d, r, i, s)
    }).then(() => d.notify("AnimationComplete", t)));
  return Promise.all(u);
}
function wQ(e, t, n = {}) {
  e.notify("AnimationStart", t);
  let r;
  if (Array.isArray(t)) {
    const i = t.map((s) => vv(e, s, n));
    r = Promise.all(i);
  } else if (typeof t == "string")
    r = vv(e, t, n);
  else {
    const i = typeof t == "function" ? Es(e, t, n.custom) : t;
    r = Promise.all(kL(e, i, n));
  }
  return r.then(() => {
    e.notify("AnimationComplete", t);
  });
}
function TL(e, t) {
  if (!Array.isArray(t))
    return !1;
  const n = t.length;
  if (n !== e.length)
    return !1;
  for (let r = 0; r < n; r++)
    if (t[r] !== e[r])
      return !1;
  return !0;
}
const bQ = Iw.length;
function $L(e) {
  if (!e)
    return;
  if (!e.isControllingVariants) {
    const n = e.parent ? $L(e.parent) || {} : {};
    return e.props.initial !== void 0 && (n.initial = e.props.initial), n;
  }
  const t = {};
  for (let n = 0; n < bQ; n++) {
    const r = Iw[n], i = e.props[r];
    (Jl(i) || i === !1) && (t[r] = i);
  }
  return t;
}
const CQ = [..._w].reverse(), EQ = _w.length;
function AQ(e) {
  return (t) => Promise.all(t.map(({ animation: n, options: r }) => wQ(e, n, r)));
}
function xQ(e) {
  let t = AQ(e), n = bS(), r = !0;
  const i = (d) => (h, f) => {
    var m;
    const g = Es(e, f, d === "exit" ? (m = e.presenceContext) == null ? void 0 : m.custom : void 0);
    if (g) {
      const { transition: w, transitionEnd: E, ...b } = g;
      h = { ...h, ...b, ...E };
    }
    return h;
  };
  function s(d) {
    t = d(e);
  }
  function l(d) {
    const { props: h } = e, f = $L(e.parent) || {}, m = [], g = /* @__PURE__ */ new Set();
    let w = {}, E = 1 / 0;
    for (let A = 0; A < EQ; A++) {
      const x = CQ[A], R = n[x], _ = h[x] !== void 0 ? h[x] : f[x], L = Jl(_), V = x === d ? R.isActive : null;
      V === !1 && (E = A);
      let O = _ === f[x] && _ !== h[x] && L;
      if (O && r && e.manuallyAnimateOnMount && (O = !1), R.protectedKeys = { ...w }, // If it isn't active and hasn't *just* been set as inactive
      !R.isActive && V === null || // If we didn't and don't have any defined prop for this animation type
      !_ && !R.prevProp || // Or if the prop doesn't define an animation
      Ff(_) || typeof _ == "boolean")
        continue;
      const D = SQ(R.prevProp, _);
      let B = D || // If we're making this variant active, we want to always make it active
      x === d && R.isActive && !O && L || // If we removed a higher-priority variant (i is in reverse order)
      A > E && L, H = !1;
      const J = Array.isArray(_) ? _ : [_];
      let ce = J.reduce(i(x), {});
      V === !1 && (ce = {});
      const { prevResolvedValues: fe = {} } = R, de = {
        ...fe,
        ...ce
      }, he = (Y) => {
        B = !0, g.has(Y) && (H = !0, g.delete(Y)), R.needsAnimating[Y] = !0;
        const te = e.getValue(Y);
        te && (te.liveStyle = !1);
      };
      for (const Y in de) {
        const te = ce[Y], S = fe[Y];
        if (w.hasOwnProperty(Y))
          continue;
        let T = !1;
        gv(te) && gv(S) ? T = !TL(te, S) : T = te !== S, T ? te != null ? he(Y) : g.add(Y) : te !== void 0 && g.has(Y) ? he(Y) : R.protectedKeys[Y] = !0;
      }
      R.prevProp = _, R.prevResolvedValues = ce, R.isActive && (w = { ...w, ...ce }), r && e.blockInitialAnimation && (B = !1);
      const le = O && D;
      B && (!le || H) && m.push(...J.map((Y) => {
        const te = { type: x };
        if (typeof Y == "string" && r && !le && e.manuallyAnimateOnMount && e.parent) {
          const { parent: S } = e, T = Es(S, Y);
          if (S.enteringChildren && T) {
            const { delayChildren: P } = T.transition || {};
            te.delay = RL(S.enteringChildren, e, P);
          }
        }
        return {
          animation: Y,
          options: te
        };
      }));
    }
    if (g.size) {
      const A = {};
      if (typeof h.initial != "boolean") {
        const x = Es(e, Array.isArray(h.initial) ? h.initial[0] : h.initial);
        x && x.transition && (A.transition = x.transition);
      }
      g.forEach((x) => {
        const R = e.getBaseTarget(x), _ = e.getValue(x);
        _ && (_.liveStyle = !0), A[x] = R ?? null;
      }), m.push({ animation: A });
    }
    let b = !!m.length;
    return r && (h.initial === !1 || h.initial === h.animate) && !e.manuallyAnimateOnMount && (b = !1), r = !1, b ? t(m) : Promise.resolve();
  }
  function u(d, h) {
    var f;
    if (n[d].isActive === h)
      return Promise.resolve();
    (f = e.variantChildren) == null || f.forEach((g) => {
      var w;
      return (w = g.animationState) == null ? void 0 : w.setActive(d, h);
    }), n[d].isActive = h;
    const m = l(d);
    for (const g in n)
      n[g].protectedKeys = {};
    return m;
  }
  return {
    animateChanges: l,
    setActive: u,
    setAnimateFunction: s,
    getState: () => n,
    reset: () => {
      n = bS(), r = !0;
    }
  };
}
function SQ(e, t) {
  return typeof t == "string" ? t !== e : Array.isArray(t) ? !TL(t, e) : !1;
}
function Fi(e = !1) {
  return {
    isActive: e,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function bS() {
  return {
    animate: Fi(!0),
    whileInView: Fi(),
    whileHover: Fi(),
    whileTap: Fi(),
    whileDrag: Fi(),
    whileFocus: Fi(),
    exit: Fi()
  };
}
let ga = class {
  constructor(t) {
    this.isMounted = !1, this.node = t;
  }
  update() {
  }
}, kQ = class extends ga {
  /**
   * We dynamically generate the AnimationState manager as it contains a reference
   * to the underlying animation library. We only want to load that if we load this,
   * so people can optionally code split it out using the `m` component.
   */
  constructor(t) {
    super(t), t.animationState || (t.animationState = xQ(t));
  }
  updateAnimationControlsSubscription() {
    const { animate: t } = this.node.getProps();
    Ff(t) && (this.unmountControls = t.subscribe(this.node));
  }
  /**
   * Subscribe any provided AnimationControls to the component's VisualElement
   */
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate: t } = this.node.getProps(), { animate: n } = this.node.prevProps || {};
    t !== n && this.updateAnimationControlsSubscription();
  }
  unmount() {
    var t;
    this.node.animationState.reset(), (t = this.unmountControls) == null || t.call(this);
  }
}, RQ = 0, TQ = class extends ga {
  constructor() {
    super(...arguments), this.id = RQ++;
  }
  update() {
    if (!this.node.presenceContext)
      return;
    const { isPresent: t, onExitComplete: n } = this.node.presenceContext, { isPresent: r } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || t === r)
      return;
    const i = this.node.animationState.setActive("exit", !t);
    n && !t && i.then(() => {
      n(this.id);
    });
  }
  mount() {
    const { register: t, onExitComplete: n } = this.node.presenceContext || {};
    n && n(this.id), t && (this.unmount = t(this.id));
  }
  unmount() {
  }
};
const $Q = {
  animation: {
    Feature: kQ
  },
  exit: {
    Feature: TQ
  }
};
function CS(e, t, n, r = { passive: !0 }) {
  return e.addEventListener(t, n, r), () => e.removeEventListener(t, n);
}
function VL(e) {
  return {
    point: {
      x: e.pageX,
      y: e.pageY
    }
  };
}
function ES(e, t, n) {
  const { props: r } = e;
  e.animationState && r.whileHover && e.animationState.setActive("whileHover", n === "Start");
  const i = "onHover" + n, s = r[i];
  s && Kn.postRender(() => s(t, VL(t)));
}
let VQ = class extends ga {
  mount() {
    const { current: t } = this.node;
    t && (this.unmount = nZ(t, (n, r) => (ES(this.node, r, "Start"), (i) => ES(this.node, i, "End"))));
  }
  unmount() {
  }
}, _Q = class extends ga {
  constructor() {
    super(...arguments), this.isActive = !1;
  }
  onFocus() {
    let t = !1;
    try {
      t = this.node.current.matches(":focus-visible");
    } catch {
      t = !0;
    }
    !t || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0);
  }
  onBlur() {
    !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1);
  }
  mount() {
    this.unmount = Nf(CS(this.node.current, "focus", () => this.onFocus()), CS(this.node.current, "blur", () => this.onBlur()));
  }
  unmount() {
  }
};
function AS(e, t, n) {
  const { props: r } = e;
  if (e.current instanceof HTMLButtonElement && e.current.disabled)
    return;
  e.animationState && r.whileTap && e.animationState.setActive("whileTap", n === "Start");
  const i = "onTap" + (n === "End" ? "" : n), s = r[i];
  s && Kn.postRender(() => s(t, VL(t)));
}
let IQ = class extends ga {
  mount() {
    const { current: t } = this.node;
    t && (this.unmount = aZ(t, (n, r) => (AS(this.node, r, "Start"), (i, { success: s }) => AS(this.node, i, s ? "End" : "Cancel")), { useGlobalTarget: this.node.props.globalTapTarget }));
  }
  unmount() {
  }
};
const yv = /* @__PURE__ */ new WeakMap(), Nm = /* @__PURE__ */ new WeakMap(), LQ = (e) => {
  const t = yv.get(e.target);
  t && t(e);
}, PQ = (e) => {
  e.forEach(LQ);
};
function MQ({ root: e, ...t }) {
  const n = e || document;
  Nm.has(n) || Nm.set(n, {});
  const r = Nm.get(n), i = JSON.stringify(t);
  return r[i] || (r[i] = new IntersectionObserver(PQ, { root: e, ...t })), r[i];
}
function OQ(e, t, n) {
  const r = MQ(t);
  return yv.set(e, n), r.observe(e), () => {
    yv.delete(e), r.unobserve(e);
  };
}
const BQ = {
  some: 0,
  all: 1
};
let NQ = class extends ga {
  constructor() {
    super(...arguments), this.hasEnteredView = !1, this.isInView = !1;
  }
  startObserver() {
    this.unmount();
    const { viewport: t = {} } = this.node.getProps(), { root: n, margin: r, amount: i = "some", once: s } = t, l = {
      root: n ? n.current : void 0,
      rootMargin: r,
      threshold: typeof i == "number" ? i : BQ[i]
    }, u = (d) => {
      const { isIntersecting: h } = d;
      if (this.isInView === h || (this.isInView = h, s && !h && this.hasEnteredView))
        return;
      h && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", h);
      const { onViewportEnter: f, onViewportLeave: m } = this.node.getProps(), g = h ? f : m;
      g && g(d);
    };
    return OQ(this.node.current, l, u);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver > "u")
      return;
    const { props: t, prevProps: n } = this.node;
    ["amount", "margin", "root"].some(DQ(t, n)) && this.startObserver();
  }
  unmount() {
  }
};
function DQ({ viewport: e = {} }, { viewport: t = {} } = {}) {
  return (n) => e[n] !== t[n];
}
const jQ = {
  inView: {
    Feature: NQ
  },
  tap: {
    Feature: IQ
  },
  focus: {
    Feature: _Q
  },
  hover: {
    Feature: VQ
  }
}, FQ = {
  renderer: tQ,
  ...$Q,
  ...jQ
};
function UQ(e, t) {
  return jZ(e, t);
}
const WQ = /* @__PURE__ */ UQ("span"), zQ = ({
  variant: e = "ghost",
  size: t = "2",
  px: n = "2",
  gap: r = "1_5",
  justify: i = "space-between",
  w: s = "auto",
  selected: l,
  icon: u,
  leadingIcon: d,
  leadingComponent: h,
  trailingIcon: f,
  trailingComponent: m,
  textProps: g,
  ...w
}) => /* @__PURE__ */ I.jsxs(
  Ut.Root,
  {
    size: t,
    variant: e,
    gap: r,
    px: n,
    justify: i,
    w: s,
    ...w,
    children: [
      /* @__PURE__ */ I.jsxs(gI, { gap: r, align: "center", w: "full", children: [
        /* @__PURE__ */ I.jsx(
          HQ,
          {
            icon: u,
            selected: l,
            leadingIcon: d,
            leadingComponent: h
          }
        ),
        /* @__PURE__ */ I.jsx(
          Ut.Text,
          {
            weight: (w == null ? void 0 : w.fontWeight) || "medium",
            w: "full",
            overflow: "hidden",
            textOverflow: "ellipsis",
            ...g,
            children: w.children
          }
        )
      ] }),
      /* @__PURE__ */ I.jsx(
        KQ,
        {
          trailingIcon: f,
          trailingComponent: m
        }
      )
    ]
  }
), HQ = ({
  icon: e,
  selected: t,
  leadingIcon: n,
  leadingComponent: r
}) => {
  if (t === !0 || t === !1)
    return /* @__PURE__ */ I.jsx(cZ, { features: FQ, children: /* @__PURE__ */ I.jsx(
      Ut.Icon,
      {
        as: WQ,
        variant: "primary",
        icon: rq,
        "aria-hidden": !0,
        animate: t ? {
          opacity: 1,
          rotate: 0,
          scale: 1
        } : {
          opacity: 0,
          rotate: -45,
          scale: 0.3
        },
        transition: { duration: 0.15, type: "spring", bounce: 0 },
        style: { transformOrigin: "center" },
        display: "block"
      }
    ) });
  const i = n || e;
  if (i)
    return /* @__PURE__ */ I.jsx(Ut.Icon, { variant: "primary", ...i });
  if (r)
    return r;
}, KQ = ({
  trailingIcon: e,
  trailingComponent: t
}) => {
  if (e)
    return /* @__PURE__ */ I.jsx(Ut.Icon, { variant: "primary", ...e });
  if (t)
    return t;
}, _L = j.createContext({
  open: !1,
  setOpen: () => {
  }
}), GQ = ({
  open: e,
  onOpenChange: t,
  defaultOpen: n,
  modal: r = !0,
  children: i,
  ...s
}) => {
  const [l = !1, u] = Zs({
    prop: e,
    defaultProp: n ?? !1,
    onChange: t
  });
  return /* @__PURE__ */ I.jsx(_L.Provider, { value: { open: l, setOpen: u }, children: /* @__PURE__ */ I.jsx(
    FY,
    {
      open: l,
      onOpenChange: u,
      modal: r,
      ...s,
      children: i
    }
  ) });
}, YQ = ({ asChild: e = !0, tgphRef: t, children: n, ...r }) => {
  const i = j.useContext(_L);
  return /* @__PURE__ */ I.jsx(
    UY,
    {
      onClick: () => {
        i.setOpen(!i.open);
      },
      asChild: e,
      ...r,
      ref: t,
      children: /* @__PURE__ */ I.jsx(Gs, { children: n })
    }
  );
}, qQ = ({
  direction: e = "column",
  gap: t = "1",
  rounded: n = "4",
  py: r = "1",
  border: i = "px",
  borderColor: s = "gray-8",
  shadow: l = "2",
  sideOffset: u = 4,
  children: d,
  onInteractOutside: h,
  onKeyDown: f,
  onCloseAutoFocus: m,
  tgphRef: g,
  ...w
}) => /* @__PURE__ */ I.jsx(
  WY,
  {
    onInteractOutside: h,
    onKeyDown: f,
    onCloseAutoFocus: m,
    asChild: !0,
    sideOffset: u,
    ...w,
    ref: g,
    children: /* @__PURE__ */ I.jsx(Gs, { children: /* @__PURE__ */ I.jsx(
      gI,
      {
        bg: "surface-1",
        direction: e,
        gap: t,
        rounded: n,
        border: i,
        borderColor: s,
        py: r,
        shadow: l,
        style: {
          overflowY: "auto"
        },
        zIndex: "popover",
        children: d
      }
    ) })
  }
), XQ = ({
  mx: e = "1",
  asChild: t = !0,
  icon: n,
  leadingIcon: r,
  trailingIcon: i,
  leadingComponent: s,
  trailingComponent: l,
  selected: u,
  tgphRef: d,
  onClick: h,
  ...f
}) => {
  const m = r || n;
  return /* @__PURE__ */ I.jsx(
    zY,
    {
      ...f,
      asChild: t,
      ref: d,
      children: /* @__PURE__ */ I.jsx(Gs, { children: /* @__PURE__ */ I.jsx(
        zQ,
        {
          onClick: h,
          selected: u,
          leadingIcon: m,
          trailingIcon: i,
          leadingComponent: s,
          trailingComponent: l,
          "data-tgph-menu-button": !0,
          mx: e,
          style: {
            flexShrink: 0
          },
          ...f
        }
      ) })
    }
  );
}, ZQ = ({
  w: e = "full",
  borderBottom: t = "px",
  ...n
}) => /* @__PURE__ */ I.jsx(mI, { as: "hr", w: e, borderBottom: t, ...n }), ku = {};
Object.assign(ku, {
  Root: GQ,
  Trigger: YQ,
  Content: qQ,
  Button: XQ,
  Divider: ZQ
});
const QQ = ({ tgphRef: e }, t = []) => {
  const [n, r] = j.useState(!1);
  return j.useEffect(() => {
    if (!e.current) return r(!1);
    const i = e.current, s = () => {
      r(i.scrollWidth > i.clientWidth);
    };
    s();
    const l = new ResizeObserver(s);
    return l.observe(i), () => {
      l.disconnect();
    };
  }, [e, ...t]), { truncated: n };
}, IL = ({
  label: e,
  children: t,
  ...n
}) => {
  const r = j.useRef(null), { truncated: i } = QQ(
    { tgphRef: r },
    [t]
  ), s = j.useMemo(() => typeof t == "string" ? t : j.isValidElement(t) ? t.props.children : e, [t, e]);
  return /* @__PURE__ */ I.jsx(
    y0,
    {
      label: /* @__PURE__ */ I.jsx(qn, { as: "span", size: "1", children: s }),
      enabled: i,
      triggerRef: r,
      ...n,
      children: /* @__PURE__ */ I.jsx(Gs, { children: t })
    }
  );
}, JQ = {
  0: "5",
  1: "6",
  2: "8",
  3: "10"
}, _r = (e) => Array.isArray(e), Eo = (e) => typeof e == "object" && !Array.isArray(e) || typeof e == "string" || !e, eJ = (e) => {
  const t = (n, r = []) => (j.Children.toArray(n).forEach((i) => {
    if (j.isValidElement(i)) {
      const s = i.props;
      s.value ? r.push(i) : s.children && t(
        s.children,
        r
      );
    }
  }), r);
  return t(e).map((n) => {
    var r;
    const i = n;
    return {
      value: i.props.value,
      label: ((r = i.props) == null ? void 0 : r.label) || i.props.children || i.props.value
    };
  });
}, yi = (e, t) => {
  if (e)
    return t === !0 ? e == null ? void 0 : e.value : e;
}, wv = (e, t, n) => {
  if (!e || !t || t.length === 0) return;
  const r = t.find(
    (i) => i.value === yi(e, n)
  );
  if (r)
    return r;
}, tJ = ({
  children: e,
  value: t,
  searchQuery: n
}) => {
  const r = LL(e);
  return (t == null ? void 0 : t.toLowerCase().includes(n.toLowerCase())) || r.some(
    (i) => i.toLowerCase().includes(n.toLowerCase())
  );
}, LL = (e) => {
  const t = j.Children.toArray(e), n = [];
  return t.forEach((r) => {
    if (typeof r == "string" && n.push(r), j.isValidElement(r)) {
      const i = r.props;
      i.children && n.push(
        ...LL(i.children)
      );
    }
  }), n;
}, nJ = C.createContext({});
function rJ(e) {
  const t = C.useRef(null);
  return t.current === null && (t.current = e()), t.current;
}
const Dw = typeof window < "u", iJ = Dw ? C.useLayoutEffect : C.useEffect, PL = /* @__PURE__ */ C.createContext(null);
function oJ(e, t) {
  e.indexOf(t) === -1 && e.push(t);
}
function sJ(e, t) {
  const n = e.indexOf(t);
  n > -1 && e.splice(n, 1);
}
const Ao = (e, t, n) => n > t ? t : n < e ? e : n;
let jw = () => {
};
const Fr = {}, ML = (e) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(e);
function aJ(e) {
  return typeof e == "object" && e !== null;
}
const OL = (e) => /^0[^.\s]+$/u.test(e);
// @__NO_SIDE_EFFECTS__
function Fw(e) {
  let t;
  return () => (t === void 0 && (t = e()), t);
}
const va = /* @__NO_SIDE_EFFECTS__ */ (e) => e, lJ = (e, t) => (n) => t(e(n)), Wf = (...e) => e.reduce(lJ), BL = /* @__NO_SIDE_EFFECTS__ */ (e, t, n) => {
  const r = t - e;
  return r === 0 ? 1 : (n - e) / r;
};
class NL {
  constructor() {
    this.subscriptions = [];
  }
  add(t) {
    return oJ(this.subscriptions, t), () => sJ(this.subscriptions, t);
  }
  notify(t, n, r) {
    const i = this.subscriptions.length;
    if (i)
      if (i === 1)
        this.subscriptions[0](t, n, r);
      else
        for (let s = 0; s < i; s++) {
          const l = this.subscriptions[s];
          l && l(t, n, r);
        }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
}
const Ir = /* @__NO_SIDE_EFFECTS__ */ (e) => e * 1e3, Lr = /* @__NO_SIDE_EFFECTS__ */ (e) => e / 1e3;
function DL(e, t) {
  return t ? e * (1e3 / t) : 0;
}
const jL = (e, t, n) => (((1 - 3 * n + 3 * t) * e + (3 * n - 6 * t)) * e + 3 * t) * e, uJ = 1e-7, cJ = 12;
function dJ(e, t, n, r, i) {
  let s, l, u = 0;
  do
    l = t + (n - t) / 2, s = jL(l, r, i) - e, s > 0 ? n = l : t = l;
  while (Math.abs(s) > uJ && ++u < cJ);
  return l;
}
function Ru(e, t, n, r) {
  if (e === t && n === r)
    return va;
  const i = (s) => dJ(s, 0, 1, e, n);
  return (s) => s === 0 || s === 1 ? s : jL(i(s), t, r);
}
const FL = (e) => (t) => t <= 0.5 ? e(2 * t) / 2 : (2 - e(2 * (1 - t))) / 2, UL = (e) => (t) => 1 - e(1 - t), WL = /* @__PURE__ */ Ru(0.33, 1.53, 0.69, 0.99), Uw = /* @__PURE__ */ UL(WL), zL = /* @__PURE__ */ FL(Uw), HL = (e) => (e *= 2) < 1 ? 0.5 * Uw(e) : 0.5 * (2 - Math.pow(2, -10 * (e - 1))), Ww = (e) => 1 - Math.sin(Math.acos(e)), fJ = UL(Ww), KL = FL(Ww), hJ = /* @__PURE__ */ Ru(0.42, 0, 1, 1), pJ = /* @__PURE__ */ Ru(0, 0, 0.58, 1), GL = /* @__PURE__ */ Ru(0.42, 0, 0.58, 1), mJ = (e) => Array.isArray(e) && typeof e[0] != "number", YL = (e) => Array.isArray(e) && typeof e[0] == "number", gJ = {
  linear: va,
  easeIn: hJ,
  easeInOut: GL,
  easeOut: pJ,
  circIn: Ww,
  circInOut: KL,
  circOut: fJ,
  backIn: Uw,
  backInOut: zL,
  backOut: WL,
  anticipate: HL
}, vJ = (e) => typeof e == "string", xS = (e) => {
  if (YL(e)) {
    jw(e.length === 4);
    const [t, n, r, i] = e;
    return Ru(t, n, r, i);
  } else if (vJ(e))
    return gJ[e];
  return e;
}, td = [
  "setup",
  // Compute
  "read",
  // Read
  "resolveKeyframes",
  // Write/Read/Write/Read
  "preUpdate",
  // Compute
  "update",
  // Compute
  "preRender",
  // Compute
  "render",
  // Write
  "postRender"
  // Compute
];
function yJ(e, t) {
  let n = /* @__PURE__ */ new Set(), r = /* @__PURE__ */ new Set(), i = !1, s = !1;
  const l = /* @__PURE__ */ new WeakSet();
  let u = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  };
  function d(f) {
    l.has(f) && (h.schedule(f), e()), f(u);
  }
  const h = {
    /**
     * Schedule a process to run on the next frame.
     */
    schedule: (f, m = !1, g = !1) => {
      const w = g && i ? n : r;
      return m && l.add(f), w.has(f) || w.add(f), f;
    },
    /**
     * Cancel the provided callback from running on the next frame.
     */
    cancel: (f) => {
      r.delete(f), l.delete(f);
    },
    /**
     * Execute all schedule callbacks.
     */
    process: (f) => {
      if (u = f, i) {
        s = !0;
        return;
      }
      i = !0, [n, r] = [r, n], n.forEach(d), n.clear(), i = !1, s && (s = !1, h.process(f));
    }
  };
  return h;
}
const wJ = 40;
function qL(e, t) {
  let n = !1, r = !0;
  const i = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  }, s = () => n = !0, l = td.reduce((x, R) => (x[R] = yJ(s), x), {}), { setup: u, read: d, resolveKeyframes: h, preUpdate: f, update: m, preRender: g, render: w, postRender: E } = l, b = () => {
    const x = Fr.useManualTiming ? i.timestamp : performance.now();
    n = !1, Fr.useManualTiming || (i.delta = r ? 1e3 / 60 : Math.max(Math.min(x - i.timestamp, wJ), 1)), i.timestamp = x, i.isProcessing = !0, u.process(i), d.process(i), h.process(i), f.process(i), m.process(i), g.process(i), w.process(i), E.process(i), i.isProcessing = !1, n && t && (r = !1, e(b));
  }, A = () => {
    n = !0, r = !0, i.isProcessing || e(b);
  };
  return { schedule: td.reduce((x, R) => {
    const _ = l[R];
    return x[R] = (L, V = !1, O = !1) => (n || A(), _.schedule(L, V, O)), x;
  }, {}), cancel: (x) => {
    for (let R = 0; R < td.length; R++)
      l[td[R]].cancel(x);
  }, state: i, steps: l };
}
const { schedule: Gn, cancel: bv, state: ef } = /* @__PURE__ */ qL(typeof requestAnimationFrame < "u" ? requestAnimationFrame : va, !0);
let Ad;
function bJ() {
  Ad = void 0;
}
const Rn = {
  now: () => (Ad === void 0 && Rn.set(ef.isProcessing || Fr.useManualTiming ? ef.timestamp : performance.now()), Ad),
  set: (e) => {
    Ad = e, queueMicrotask(bJ);
  }
}, XL = (e) => (t) => typeof t == "string" && t.startsWith(e), ZL = /* @__PURE__ */ XL("--"), CJ = /* @__PURE__ */ XL("var(--"), zw = (e) => CJ(e) ? EJ.test(e.split("/*")[0].trim()) : !1, EJ = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu, ya = {
  test: (e) => typeof e == "number",
  parse: parseFloat,
  transform: (e) => e
}, eu = {
  ...ya,
  transform: (e) => Ao(0, 1, e)
}, nd = {
  ...ya,
  default: 1
}, Pl = (e) => Math.round(e * 1e5) / 1e5, Hw = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
function AJ(e) {
  return e == null;
}
const xJ = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu, Kw = (e, t) => (n) => !!(typeof n == "string" && xJ.test(n) && n.startsWith(e) || t && !AJ(n) && Object.prototype.hasOwnProperty.call(n, t)), QL = (e, t, n) => (r) => {
  if (typeof r != "string")
    return r;
  const [i, s, l, u] = r.match(Hw);
  return {
    [e]: parseFloat(i),
    [t]: parseFloat(s),
    [n]: parseFloat(l),
    alpha: u !== void 0 ? parseFloat(u) : 1
  };
}, SJ = (e) => Ao(0, 255, e), Dm = {
  ...ya,
  transform: (e) => Math.round(SJ(e))
}, Ji = {
  test: /* @__PURE__ */ Kw("rgb", "red"),
  parse: /* @__PURE__ */ QL("red", "green", "blue"),
  transform: ({ red: e, green: t, blue: n, alpha: r = 1 }) => "rgba(" + Dm.transform(e) + ", " + Dm.transform(t) + ", " + Dm.transform(n) + ", " + Pl(eu.transform(r)) + ")"
};
function kJ(e) {
  let t = "", n = "", r = "", i = "";
  return e.length > 5 ? (t = e.substring(1, 3), n = e.substring(3, 5), r = e.substring(5, 7), i = e.substring(7, 9)) : (t = e.substring(1, 2), n = e.substring(2, 3), r = e.substring(3, 4), i = e.substring(4, 5), t += t, n += n, r += r, i += i), {
    red: parseInt(t, 16),
    green: parseInt(n, 16),
    blue: parseInt(r, 16),
    alpha: i ? parseInt(i, 16) / 255 : 1
  };
}
const Cv = {
  test: /* @__PURE__ */ Kw("#"),
  parse: kJ,
  transform: Ji.transform
}, Tu = /* @__NO_SIDE_EFFECTS__ */ (e) => ({
  test: (t) => typeof t == "string" && t.endsWith(e) && t.split(" ").length === 1,
  parse: parseFloat,
  transform: (t) => `${t}${e}`
}), gi = /* @__PURE__ */ Tu("deg"), As = /* @__PURE__ */ Tu("%"), Ve = /* @__PURE__ */ Tu("px"), RJ = /* @__PURE__ */ Tu("vh"), TJ = /* @__PURE__ */ Tu("vw"), SS = {
  ...As,
  parse: (e) => As.parse(e) / 100,
  transform: (e) => As.transform(e * 100)
}, ds = {
  test: /* @__PURE__ */ Kw("hsl", "hue"),
  parse: /* @__PURE__ */ QL("hue", "saturation", "lightness"),
  transform: ({ hue: e, saturation: t, lightness: n, alpha: r = 1 }) => "hsla(" + Math.round(e) + ", " + As.transform(Pl(t)) + ", " + As.transform(Pl(n)) + ", " + Pl(eu.transform(r)) + ")"
}, pt = {
  test: (e) => Ji.test(e) || Cv.test(e) || ds.test(e),
  parse: (e) => Ji.test(e) ? Ji.parse(e) : ds.test(e) ? ds.parse(e) : Cv.parse(e),
  transform: (e) => typeof e == "string" ? e : e.hasOwnProperty("red") ? Ji.transform(e) : ds.transform(e),
  getAnimatableNone: (e) => {
    const t = pt.parse(e);
    return t.alpha = 0, pt.transform(t);
  }
}, $J = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
function VJ(e) {
  var t, n;
  return isNaN(e) && typeof e == "string" && (((t = e.match(Hw)) == null ? void 0 : t.length) || 0) + (((n = e.match($J)) == null ? void 0 : n.length) || 0) > 0;
}
const JL = "number", e2 = "color", _J = "var", IJ = "var(", kS = "${}", LJ = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function tu(e) {
  const t = e.toString(), n = [], r = {
    color: [],
    number: [],
    var: []
  }, i = [];
  let s = 0;
  const l = t.replace(LJ, (u) => (pt.test(u) ? (r.color.push(s), i.push(e2), n.push(pt.parse(u))) : u.startsWith(IJ) ? (r.var.push(s), i.push(_J), n.push(u)) : (r.number.push(s), i.push(JL), n.push(parseFloat(u))), ++s, kS)).split(kS);
  return { values: n, split: l, indexes: r, types: i };
}
function t2(e) {
  return tu(e).values;
}
function n2(e) {
  const { split: t, types: n } = tu(e), r = t.length;
  return (i) => {
    let s = "";
    for (let l = 0; l < r; l++)
      if (s += t[l], i[l] !== void 0) {
        const u = n[l];
        u === JL ? s += Pl(i[l]) : u === e2 ? s += pt.transform(i[l]) : s += i[l];
      }
    return s;
  };
}
const PJ = (e) => typeof e == "number" ? 0 : pt.test(e) ? pt.getAnimatableNone(e) : e;
function MJ(e) {
  const t = t2(e);
  return n2(e)(t.map(PJ));
}
const wa = {
  test: VJ,
  parse: t2,
  createTransformer: n2,
  getAnimatableNone: MJ
};
function jm(e, t, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + (t - e) * 6 * n : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e;
}
function OJ({ hue: e, saturation: t, lightness: n, alpha: r }) {
  e /= 360, t /= 100, n /= 100;
  let i = 0, s = 0, l = 0;
  if (!t)
    i = s = l = n;
  else {
    const u = n < 0.5 ? n * (1 + t) : n + t - n * t, d = 2 * n - u;
    i = jm(d, u, e + 1 / 3), s = jm(d, u, e), l = jm(d, u, e - 1 / 3);
  }
  return {
    red: Math.round(i * 255),
    green: Math.round(s * 255),
    blue: Math.round(l * 255),
    alpha: r
  };
}
function tf(e, t) {
  return (n) => n > 0 ? t : e;
}
const zf = (e, t, n) => e + (t - e) * n, Fm = (e, t, n) => {
  const r = e * e, i = n * (t * t - r) + r;
  return i < 0 ? 0 : Math.sqrt(i);
}, BJ = [Cv, Ji, ds], NJ = (e) => BJ.find((t) => t.test(e));
function RS(e) {
  const t = NJ(e);
  if (!t)
    return !1;
  let n = t.parse(e);
  return t === ds && (n = OJ(n)), n;
}
const TS = (e, t) => {
  const n = RS(e), r = RS(t);
  if (!n || !r)
    return tf(e, t);
  const i = { ...n };
  return (s) => (i.red = Fm(n.red, r.red, s), i.green = Fm(n.green, r.green, s), i.blue = Fm(n.blue, r.blue, s), i.alpha = zf(n.alpha, r.alpha, s), Ji.transform(i));
}, Ev = /* @__PURE__ */ new Set(["none", "hidden"]);
function DJ(e, t) {
  return Ev.has(e) ? (n) => n <= 0 ? e : t : (n) => n >= 1 ? t : e;
}
function jJ(e, t) {
  return (n) => zf(e, t, n);
}
function Gw(e) {
  return typeof e == "number" ? jJ : typeof e == "string" ? zw(e) ? tf : pt.test(e) ? TS : WJ : Array.isArray(e) ? r2 : typeof e == "object" ? pt.test(e) ? TS : FJ : tf;
}
function r2(e, t) {
  const n = [...e], r = n.length, i = e.map((s, l) => Gw(s)(s, t[l]));
  return (s) => {
    for (let l = 0; l < r; l++)
      n[l] = i[l](s);
    return n;
  };
}
function FJ(e, t) {
  const n = { ...e, ...t }, r = {};
  for (const i in n)
    e[i] !== void 0 && t[i] !== void 0 && (r[i] = Gw(e[i])(e[i], t[i]));
  return (i) => {
    for (const s in r)
      n[s] = r[s](i);
    return n;
  };
}
function UJ(e, t) {
  const n = [], r = { color: 0, var: 0, number: 0 };
  for (let i = 0; i < t.values.length; i++) {
    const s = t.types[i], l = e.indexes[s][r[s]], u = e.values[l] ?? 0;
    n[i] = u, r[s]++;
  }
  return n;
}
const WJ = (e, t) => {
  const n = wa.createTransformer(t), r = tu(e), i = tu(t);
  return r.indexes.var.length === i.indexes.var.length && r.indexes.color.length === i.indexes.color.length && r.indexes.number.length >= i.indexes.number.length ? Ev.has(e) && !i.values.length || Ev.has(t) && !r.values.length ? DJ(e, t) : Wf(r2(UJ(r, i), i.values), n) : tf(e, t);
};
function i2(e, t, n) {
  return typeof e == "number" && typeof t == "number" && typeof n == "number" ? zf(e, t, n) : Gw(e)(e, t);
}
const zJ = (e) => {
  const t = ({ timestamp: n }) => e(n);
  return {
    start: (n = !0) => Gn.update(t, n),
    stop: () => bv(t),
    /**
     * If we're processing this frame we can use the
     * framelocked timestamp to keep things in sync.
     */
    now: () => ef.isProcessing ? ef.timestamp : Rn.now()
  };
}, o2 = (e, t, n = 10) => {
  let r = "";
  const i = Math.max(Math.round(t / n), 2);
  for (let s = 0; s < i; s++)
    r += Math.round(e(s / (i - 1)) * 1e4) / 1e4 + ", ";
  return `linear(${r.substring(0, r.length - 2)})`;
}, nf = 2e4;
function Yw(e) {
  let t = 0;
  const n = 50;
  let r = e.next(t);
  for (; !r.done && t < nf; )
    t += n, r = e.next(t);
  return t >= nf ? 1 / 0 : t;
}
function HJ(e, t = 100, n) {
  const r = n({ ...e, keyframes: [0, t] }), i = Math.min(Yw(r), nf);
  return {
    type: "keyframes",
    ease: (s) => r.next(i * s).value / t,
    duration: /* @__PURE__ */ Lr(i)
  };
}
const KJ = 5;
function s2(e, t, n) {
  const r = Math.max(t - KJ, 0);
  return DL(n - e(r), t - r);
}
const ot = {
  // Default spring physics
  stiffness: 100,
  damping: 10,
  mass: 1,
  velocity: 0,
  // Default duration/bounce-based options
  duration: 800,
  // in ms
  bounce: 0.3,
  visualDuration: 0.3,
  // in seconds
  // Rest thresholds
  restSpeed: {
    granular: 0.01,
    default: 2
  },
  restDelta: {
    granular: 5e-3,
    default: 0.5
  },
  // Limits
  minDuration: 0.01,
  // in seconds
  maxDuration: 10,
  // in seconds
  minDamping: 0.05,
  maxDamping: 1
}, Um = 1e-3;
function GJ({ duration: e = ot.duration, bounce: t = ot.bounce, velocity: n = ot.velocity, mass: r = ot.mass }) {
  let i, s, l = 1 - t;
  l = Ao(ot.minDamping, ot.maxDamping, l), e = Ao(ot.minDuration, ot.maxDuration, /* @__PURE__ */ Lr(e)), l < 1 ? (i = (h) => {
    const f = h * l, m = f * e, g = f - n, w = Av(h, l), E = Math.exp(-m);
    return Um - g / w * E;
  }, s = (h) => {
    const f = h * l * e, m = f * n + n, g = Math.pow(l, 2) * Math.pow(h, 2) * e, w = Math.exp(-f), E = Av(Math.pow(h, 2), l);
    return (-i(h) + Um > 0 ? -1 : 1) * ((m - g) * w) / E;
  }) : (i = (h) => {
    const f = Math.exp(-h * e), m = (h - n) * e + 1;
    return -Um + f * m;
  }, s = (h) => {
    const f = Math.exp(-h * e), m = (n - h) * (e * e);
    return f * m;
  });
  const u = 5 / e, d = qJ(i, s, u);
  if (e = /* @__PURE__ */ Ir(e), isNaN(d))
    return {
      stiffness: ot.stiffness,
      damping: ot.damping,
      duration: e
    };
  {
    const h = Math.pow(d, 2) * r;
    return {
      stiffness: h,
      damping: l * 2 * Math.sqrt(r * h),
      duration: e
    };
  }
}
const YJ = 12;
function qJ(e, t, n) {
  let r = n;
  for (let i = 1; i < YJ; i++)
    r = r - e(r) / t(r);
  return r;
}
function Av(e, t) {
  return e * Math.sqrt(1 - t * t);
}
const XJ = ["duration", "bounce"], ZJ = ["stiffness", "damping", "mass"];
function $S(e, t) {
  return t.some((n) => e[n] !== void 0);
}
function QJ(e) {
  let t = {
    velocity: ot.velocity,
    stiffness: ot.stiffness,
    damping: ot.damping,
    mass: ot.mass,
    isResolvedFromDuration: !1,
    ...e
  };
  if (!$S(e, ZJ) && $S(e, XJ))
    if (e.visualDuration) {
      const n = e.visualDuration, r = 2 * Math.PI / (n * 1.2), i = r * r, s = 2 * Ao(0.05, 1, 1 - (e.bounce || 0)) * Math.sqrt(i);
      t = {
        ...t,
        mass: ot.mass,
        stiffness: i,
        damping: s
      };
    } else {
      const n = GJ(e);
      t = {
        ...t,
        ...n,
        mass: ot.mass
      }, t.isResolvedFromDuration = !0;
    }
  return t;
}
function rf(e = ot.visualDuration, t = ot.bounce) {
  const n = typeof e != "object" ? {
    visualDuration: e,
    keyframes: [0, 1],
    bounce: t
  } : e;
  let { restSpeed: r, restDelta: i } = n;
  const s = n.keyframes[0], l = n.keyframes[n.keyframes.length - 1], u = { done: !1, value: s }, { stiffness: d, damping: h, mass: f, duration: m, velocity: g, isResolvedFromDuration: w } = QJ({
    ...n,
    velocity: -/* @__PURE__ */ Lr(n.velocity || 0)
  }), E = g || 0, b = h / (2 * Math.sqrt(d * f)), A = l - s, x = /* @__PURE__ */ Lr(Math.sqrt(d / f)), R = Math.abs(A) < 5;
  r || (r = R ? ot.restSpeed.granular : ot.restSpeed.default), i || (i = R ? ot.restDelta.granular : ot.restDelta.default);
  let _;
  if (b < 1) {
    const V = Av(x, b);
    _ = (O) => {
      const D = Math.exp(-b * x * O);
      return l - D * ((E + b * x * A) / V * Math.sin(V * O) + A * Math.cos(V * O));
    };
  } else if (b === 1)
    _ = (V) => l - Math.exp(-x * V) * (A + (E + x * A) * V);
  else {
    const V = x * Math.sqrt(b * b - 1);
    _ = (O) => {
      const D = Math.exp(-b * x * O), B = Math.min(V * O, 300);
      return l - D * ((E + b * x * A) * Math.sinh(B) + V * A * Math.cosh(B)) / V;
    };
  }
  const L = {
    calculatedDuration: w && m || null,
    next: (V) => {
      const O = _(V);
      if (w)
        u.done = V >= m;
      else {
        let D = V === 0 ? E : 0;
        b < 1 && (D = V === 0 ? /* @__PURE__ */ Ir(E) : s2(_, V, O));
        const B = Math.abs(D) <= r, H = Math.abs(l - O) <= i;
        u.done = B && H;
      }
      return u.value = u.done ? l : O, u;
    },
    toString: () => {
      const V = Math.min(Yw(L), nf), O = o2((D) => L.next(V * D).value, V, 30);
      return V + "ms " + O;
    },
    toTransition: () => {
    }
  };
  return L;
}
rf.applyToOptions = (e) => {
  const t = HJ(e, 100, rf);
  return e.ease = t.ease, e.duration = /* @__PURE__ */ Ir(t.duration), e.type = "keyframes", e;
};
function xv({ keyframes: e, velocity: t = 0, power: n = 0.8, timeConstant: r = 325, bounceDamping: i = 10, bounceStiffness: s = 500, modifyTarget: l, min: u, max: d, restDelta: h = 0.5, restSpeed: f }) {
  const m = e[0], g = {
    done: !1,
    value: m
  }, w = (B) => u !== void 0 && B < u || d !== void 0 && B > d, E = (B) => u === void 0 ? d : d === void 0 || Math.abs(u - B) < Math.abs(d - B) ? u : d;
  let b = n * t;
  const A = m + b, x = l === void 0 ? A : l(A);
  x !== A && (b = x - m);
  const R = (B) => -b * Math.exp(-B / r), _ = (B) => x + R(B), L = (B) => {
    const H = R(B), J = _(B);
    g.done = Math.abs(H) <= h, g.value = g.done ? x : J;
  };
  let V, O;
  const D = (B) => {
    w(g.value) && (V = B, O = rf({
      keyframes: [g.value, E(g.value)],
      velocity: s2(_, B, g.value),
      // TODO: This should be passing * 1000
      damping: i,
      stiffness: s,
      restDelta: h,
      restSpeed: f
    }));
  };
  return D(0), {
    calculatedDuration: null,
    next: (B) => {
      let H = !1;
      return !O && V === void 0 && (H = !0, L(B), D(B)), V !== void 0 && B >= V ? O.next(B - V) : (!H && L(B), g);
    }
  };
}
function JJ(e, t, n) {
  const r = [], i = n || Fr.mix || i2, s = e.length - 1;
  for (let l = 0; l < s; l++) {
    let u = i(e[l], e[l + 1]);
    if (t) {
      const d = Array.isArray(t) ? t[l] || va : t;
      u = Wf(d, u);
    }
    r.push(u);
  }
  return r;
}
function eee(e, t, { clamp: n = !0, ease: r, mixer: i } = {}) {
  const s = e.length;
  if (jw(s === t.length), s === 1)
    return () => t[0];
  if (s === 2 && t[0] === t[1])
    return () => t[1];
  const l = e[0] === e[1];
  e[0] > e[s - 1] && (e = [...e].reverse(), t = [...t].reverse());
  const u = JJ(t, r, i), d = u.length, h = (f) => {
    if (l && f < e[0])
      return t[0];
    let m = 0;
    if (d > 1)
      for (; m < e.length - 2 && !(f < e[m + 1]); m++)
        ;
    const g = /* @__PURE__ */ BL(e[m], e[m + 1], f);
    return u[m](g);
  };
  return n ? (f) => h(Ao(e[0], e[s - 1], f)) : h;
}
function tee(e, t) {
  const n = e[e.length - 1];
  for (let r = 1; r <= t; r++) {
    const i = /* @__PURE__ */ BL(0, t, r);
    e.push(zf(n, 1, i));
  }
}
function nee(e) {
  const t = [0];
  return tee(t, e.length - 1), t;
}
function ree(e, t) {
  return e.map((n) => n * t);
}
function iee(e, t) {
  return e.map(() => t || GL).splice(0, e.length - 1);
}
function Ml({ duration: e = 300, keyframes: t, times: n, ease: r = "easeInOut" }) {
  const i = mJ(r) ? r.map(xS) : xS(r), s = {
    done: !1,
    value: t[0]
  }, l = ree(
    // Only use the provided offsets if they're the correct length
    // TODO Maybe we should warn here if there's a length mismatch
    n && n.length === t.length ? n : nee(t),
    e
  ), u = eee(l, t, {
    ease: Array.isArray(i) ? i : iee(t, i)
  });
  return {
    calculatedDuration: e,
    next: (d) => (s.value = u(d), s.done = d >= e, s)
  };
}
const oee = (e) => e !== null;
function qw(e, { repeat: t, repeatType: n = "loop" }, r, i = 1) {
  const s = e.filter(oee), l = i < 0 || t && n !== "loop" && t % 2 === 1 ? 0 : s.length - 1;
  return !l || r === void 0 ? s[l] : r;
}
const see = {
  decay: xv,
  inertia: xv,
  tween: Ml,
  keyframes: Ml,
  spring: rf
};
function a2(e) {
  typeof e.type == "string" && (e.type = see[e.type]);
}
class Xw {
  constructor() {
    this.updateFinished();
  }
  get finished() {
    return this._finished;
  }
  updateFinished() {
    this._finished = new Promise((t) => {
      this.resolve = t;
    });
  }
  notifyFinished() {
    this.resolve();
  }
  /**
   * Allows the animation to be awaited.
   *
   * @deprecated Use `finished` instead.
   */
  then(t, n) {
    return this.finished.then(t, n);
  }
}
const aee = (e) => e / 100;
class Zw extends Xw {
  constructor(t) {
    super(), this.state = "idle", this.startTime = null, this.isStopped = !1, this.currentTime = 0, this.holdTime = null, this.playbackSpeed = 1, this.stop = () => {
      var n, r;
      const { motionValue: i } = this.options;
      i && i.updatedAt !== Rn.now() && this.tick(Rn.now()), this.isStopped = !0, this.state !== "idle" && (this.teardown(), (r = (n = this.options).onStop) == null || r.call(n));
    }, this.options = t, this.initAnimation(), this.play(), t.autoplay === !1 && this.pause();
  }
  initAnimation() {
    const { options: t } = this;
    a2(t);
    const { type: n = Ml, repeat: r = 0, repeatDelay: i = 0, repeatType: s, velocity: l = 0 } = t;
    let { keyframes: u } = t;
    const d = n || Ml;
    d !== Ml && typeof u[0] != "number" && (this.mixKeyframes = Wf(aee, i2(u[0], u[1])), u = [0, 100]);
    const h = d({ ...t, keyframes: u });
    s === "mirror" && (this.mirroredGenerator = d({
      ...t,
      keyframes: [...u].reverse(),
      velocity: -l
    })), h.calculatedDuration === null && (h.calculatedDuration = Yw(h));
    const { calculatedDuration: f } = h;
    this.calculatedDuration = f, this.resolvedDuration = f + i, this.totalDuration = this.resolvedDuration * (r + 1) - i, this.generator = h;
  }
  updateTime(t) {
    const n = Math.round(t - this.startTime) * this.playbackSpeed;
    this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = n;
  }
  tick(t, n = !1) {
    const { generator: r, totalDuration: i, mixKeyframes: s, mirroredGenerator: l, resolvedDuration: u, calculatedDuration: d } = this;
    if (this.startTime === null)
      return r.next(0);
    const { delay: h = 0, keyframes: f, repeat: m, repeatType: g, repeatDelay: w, type: E, onUpdate: b, finalKeyframe: A } = this.options;
    this.speed > 0 ? this.startTime = Math.min(this.startTime, t) : this.speed < 0 && (this.startTime = Math.min(t - i / this.speed, this.startTime)), n ? this.currentTime = t : this.updateTime(t);
    const x = this.currentTime - h * (this.playbackSpeed >= 0 ? 1 : -1), R = this.playbackSpeed >= 0 ? x < 0 : x > i;
    this.currentTime = Math.max(x, 0), this.state === "finished" && this.holdTime === null && (this.currentTime = i);
    let _ = this.currentTime, L = r;
    if (m) {
      const B = Math.min(this.currentTime, i) / u;
      let H = Math.floor(B), J = B % 1;
      !J && B >= 1 && (J = 1), J === 1 && H--, H = Math.min(H, m + 1), H % 2 && (g === "reverse" ? (J = 1 - J, w && (J -= w / u)) : g === "mirror" && (L = l)), _ = Ao(0, 1, J) * u;
    }
    const V = R ? { done: !1, value: f[0] } : L.next(_);
    s && (V.value = s(V.value));
    let { done: O } = V;
    !R && d !== null && (O = this.playbackSpeed >= 0 ? this.currentTime >= i : this.currentTime <= 0);
    const D = this.holdTime === null && (this.state === "finished" || this.state === "running" && O);
    return D && E !== xv && (V.value = qw(f, this.options, A, this.speed)), b && b(V.value), D && this.finish(), V;
  }
  /**
   * Allows the returned animation to be awaited or promise-chained. Currently
   * resolves when the animation finishes at all but in a future update could/should
   * reject if its cancels.
   */
  then(t, n) {
    return this.finished.then(t, n);
  }
  get duration() {
    return /* @__PURE__ */ Lr(this.calculatedDuration);
  }
  get time() {
    return /* @__PURE__ */ Lr(this.currentTime);
  }
  set time(t) {
    var n;
    t = /* @__PURE__ */ Ir(t), this.currentTime = t, this.startTime === null || this.holdTime !== null || this.playbackSpeed === 0 ? this.holdTime = t : this.driver && (this.startTime = this.driver.now() - t / this.playbackSpeed), (n = this.driver) == null || n.start(!1);
  }
  get speed() {
    return this.playbackSpeed;
  }
  set speed(t) {
    this.updateTime(Rn.now());
    const n = this.playbackSpeed !== t;
    this.playbackSpeed = t, n && (this.time = /* @__PURE__ */ Lr(this.currentTime));
  }
  play() {
    var t, n;
    if (this.isStopped)
      return;
    const { driver: r = zJ, startTime: i } = this.options;
    this.driver || (this.driver = r((l) => this.tick(l))), (n = (t = this.options).onPlay) == null || n.call(t);
    const s = this.driver.now();
    this.state === "finished" ? (this.updateFinished(), this.startTime = s) : this.holdTime !== null ? this.startTime = s - this.holdTime : this.startTime || (this.startTime = i ?? s), this.state === "finished" && this.speed < 0 && (this.startTime += this.calculatedDuration), this.holdTime = null, this.state = "running", this.driver.start();
  }
  pause() {
    this.state = "paused", this.updateTime(Rn.now()), this.holdTime = this.currentTime;
  }
  complete() {
    this.state !== "running" && this.play(), this.state = "finished", this.holdTime = null;
  }
  finish() {
    var t, n;
    this.notifyFinished(), this.teardown(), this.state = "finished", (n = (t = this.options).onComplete) == null || n.call(t);
  }
  cancel() {
    var t, n;
    this.holdTime = null, this.startTime = 0, this.tick(0), this.teardown(), (n = (t = this.options).onCancel) == null || n.call(t);
  }
  teardown() {
    this.state = "idle", this.stopDriver(), this.startTime = this.holdTime = null;
  }
  stopDriver() {
    this.driver && (this.driver.stop(), this.driver = void 0);
  }
  sample(t) {
    return this.startTime = 0, this.tick(t, !0);
  }
  attachTimeline(t) {
    var n;
    return this.options.allowFlatten && (this.options.type = "keyframes", this.options.ease = "linear", this.initAnimation()), (n = this.driver) == null || n.stop(), t.observe(this);
  }
}
function lee(e) {
  for (let t = 1; t < e.length; t++)
    e[t] ?? (e[t] = e[t - 1]);
}
const eo = (e) => e * 180 / Math.PI, Sv = (e) => {
  const t = eo(Math.atan2(e[1], e[0]));
  return kv(t);
}, uee = {
  x: 4,
  y: 5,
  translateX: 4,
  translateY: 5,
  scaleX: 0,
  scaleY: 3,
  scale: (e) => (Math.abs(e[0]) + Math.abs(e[3])) / 2,
  rotate: Sv,
  rotateZ: Sv,
  skewX: (e) => eo(Math.atan(e[1])),
  skewY: (e) => eo(Math.atan(e[2])),
  skew: (e) => (Math.abs(e[1]) + Math.abs(e[2])) / 2
}, kv = (e) => (e = e % 360, e < 0 && (e += 360), e), VS = Sv, _S = (e) => Math.sqrt(e[0] * e[0] + e[1] * e[1]), IS = (e) => Math.sqrt(e[4] * e[4] + e[5] * e[5]), cee = {
  x: 12,
  y: 13,
  z: 14,
  translateX: 12,
  translateY: 13,
  translateZ: 14,
  scaleX: _S,
  scaleY: IS,
  scale: (e) => (_S(e) + IS(e)) / 2,
  rotateX: (e) => kv(eo(Math.atan2(e[6], e[5]))),
  rotateY: (e) => kv(eo(Math.atan2(-e[2], e[0]))),
  rotateZ: VS,
  rotate: VS,
  skewX: (e) => eo(Math.atan(e[4])),
  skewY: (e) => eo(Math.atan(e[1])),
  skew: (e) => (Math.abs(e[1]) + Math.abs(e[4])) / 2
};
function Rv(e) {
  return e.includes("scale") ? 1 : 0;
}
function Tv(e, t) {
  if (!e || e === "none")
    return Rv(t);
  const n = e.match(/^matrix3d\(([-\d.e\s,]+)\)$/u);
  let r, i;
  if (n)
    r = cee, i = n;
  else {
    const u = e.match(/^matrix\(([-\d.e\s,]+)\)$/u);
    r = uee, i = u;
  }
  if (!i)
    return Rv(t);
  const s = r[t], l = i[1].split(",").map(fee);
  return typeof s == "function" ? s(l) : l[s];
}
const dee = (e, t) => {
  const { transform: n = "none" } = getComputedStyle(e);
  return Tv(n, t);
};
function fee(e) {
  return parseFloat(e.trim());
}
const ba = [
  "transformPerspective",
  "x",
  "y",
  "z",
  "translateX",
  "translateY",
  "translateZ",
  "scale",
  "scaleX",
  "scaleY",
  "rotate",
  "rotateX",
  "rotateY",
  "rotateZ",
  "skew",
  "skewX",
  "skewY"
], Ca = new Set(ba), LS = (e) => e === ya || e === Ve, hee = /* @__PURE__ */ new Set(["x", "y", "z"]), pee = ba.filter((e) => !hee.has(e));
function mee(e) {
  const t = [];
  return pee.forEach((n) => {
    const r = e.getValue(n);
    r !== void 0 && (t.push([n, r.get()]), r.set(n.startsWith("scale") ? 1 : 0));
  }), t;
}
const ho = {
  // Dimensions
  width: ({ x: e }, { paddingLeft: t = "0", paddingRight: n = "0" }) => e.max - e.min - parseFloat(t) - parseFloat(n),
  height: ({ y: e }, { paddingTop: t = "0", paddingBottom: n = "0" }) => e.max - e.min - parseFloat(t) - parseFloat(n),
  top: (e, { top: t }) => parseFloat(t),
  left: (e, { left: t }) => parseFloat(t),
  bottom: ({ y: e }, { top: t }) => parseFloat(t) + (e.max - e.min),
  right: ({ x: e }, { left: t }) => parseFloat(t) + (e.max - e.min),
  // Transform
  x: (e, { transform: t }) => Tv(t, "x"),
  y: (e, { transform: t }) => Tv(t, "y")
};
ho.translateX = ho.x;
ho.translateY = ho.y;
const po = /* @__PURE__ */ new Set();
let $v = !1, Vv = !1, _v = !1;
function l2() {
  if (Vv) {
    const e = Array.from(po).filter((r) => r.needsMeasurement), t = new Set(e.map((r) => r.element)), n = /* @__PURE__ */ new Map();
    t.forEach((r) => {
      const i = mee(r);
      i.length && (n.set(r, i), r.render());
    }), e.forEach((r) => r.measureInitialState()), t.forEach((r) => {
      r.render();
      const i = n.get(r);
      i && i.forEach(([s, l]) => {
        var u;
        (u = r.getValue(s)) == null || u.set(l);
      });
    }), e.forEach((r) => r.measureEndState()), e.forEach((r) => {
      r.suspendedScrollY !== void 0 && window.scrollTo(0, r.suspendedScrollY);
    });
  }
  Vv = !1, $v = !1, po.forEach((e) => e.complete(_v)), po.clear();
}
function u2() {
  po.forEach((e) => {
    e.readKeyframes(), e.needsMeasurement && (Vv = !0);
  });
}
function gee() {
  _v = !0, u2(), l2(), _v = !1;
}
class Qw {
  constructor(t, n, r, i, s, l = !1) {
    this.state = "pending", this.isAsync = !1, this.needsMeasurement = !1, this.unresolvedKeyframes = [...t], this.onComplete = n, this.name = r, this.motionValue = i, this.element = s, this.isAsync = l;
  }
  scheduleResolve() {
    this.state = "scheduled", this.isAsync ? (po.add(this), $v || ($v = !0, Gn.read(u2), Gn.resolveKeyframes(l2))) : (this.readKeyframes(), this.complete());
  }
  readKeyframes() {
    const { unresolvedKeyframes: t, name: n, element: r, motionValue: i } = this;
    if (t[0] === null) {
      const s = i == null ? void 0 : i.get(), l = t[t.length - 1];
      if (s !== void 0)
        t[0] = s;
      else if (r && n) {
        const u = r.readValue(n, l);
        u != null && (t[0] = u);
      }
      t[0] === void 0 && (t[0] = l), i && s === void 0 && i.set(t[0]);
    }
    lee(t);
  }
  setFinalKeyframe() {
  }
  measureInitialState() {
  }
  renderEndStyles() {
  }
  measureEndState() {
  }
  complete(t = !1) {
    this.state = "complete", this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, t), po.delete(this);
  }
  cancel() {
    this.state === "scheduled" && (po.delete(this), this.state = "pending");
  }
  resume() {
    this.state === "pending" && this.scheduleResolve();
  }
}
const vee = (e) => e.startsWith("--");
function yee(e, t, n) {
  vee(t) ? e.style.setProperty(t, n) : e.style[t] = n;
}
const wee = /* @__PURE__ */ Fw(() => window.ScrollTimeline !== void 0), bee = {};
function Cee(e, t) {
  const n = /* @__PURE__ */ Fw(e);
  return () => bee[t] ?? n();
}
const c2 = /* @__PURE__ */ Cee(() => {
  try {
    document.createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" });
  } catch {
    return !1;
  }
  return !0;
}, "linearEasing"), El = ([e, t, n, r]) => `cubic-bezier(${e}, ${t}, ${n}, ${r})`, PS = {
  linear: "linear",
  ease: "ease",
  easeIn: "ease-in",
  easeOut: "ease-out",
  easeInOut: "ease-in-out",
  circIn: /* @__PURE__ */ El([0, 0.65, 0.55, 1]),
  circOut: /* @__PURE__ */ El([0.55, 0, 1, 0.45]),
  backIn: /* @__PURE__ */ El([0.31, 0.01, 0.66, -0.59]),
  backOut: /* @__PURE__ */ El([0.33, 1.53, 0.69, 0.99])
};
function d2(e, t) {
  if (e)
    return typeof e == "function" ? c2() ? o2(e, t) : "ease-out" : YL(e) ? El(e) : Array.isArray(e) ? e.map((n) => d2(n, t) || PS.easeOut) : PS[e];
}
function Eee(e, t, n, { delay: r = 0, duration: i = 300, repeat: s = 0, repeatType: l = "loop", ease: u = "easeOut", times: d } = {}, h = void 0) {
  const f = {
    [t]: n
  };
  d && (f.offset = d);
  const m = d2(u, i);
  Array.isArray(m) && (f.easing = m);
  const g = {
    delay: r,
    duration: i,
    easing: Array.isArray(m) ? "linear" : m,
    fill: "both",
    iterations: s + 1,
    direction: l === "reverse" ? "alternate" : "normal"
  };
  return h && (g.pseudoElement = h), e.animate(f, g);
}
function f2(e) {
  return typeof e == "function" && "applyToOptions" in e;
}
function Aee({ type: e, ...t }) {
  return f2(e) && c2() ? e.applyToOptions(t) : (t.duration ?? (t.duration = 300), t.ease ?? (t.ease = "easeOut"), t);
}
class xee extends Xw {
  constructor(t) {
    if (super(), this.finishedTime = null, this.isStopped = !1, !t)
      return;
    const { element: n, name: r, keyframes: i, pseudoElement: s, allowFlatten: l = !1, finalKeyframe: u, onComplete: d } = t;
    this.isPseudoElement = !!s, this.allowFlatten = l, this.options = t, jw(typeof t.type != "string");
    const h = Aee(t);
    this.animation = Eee(n, r, i, h, s), h.autoplay === !1 && this.animation.pause(), this.animation.onfinish = () => {
      if (this.finishedTime = this.time, !s) {
        const f = qw(i, this.options, u, this.speed);
        this.updateMotionValue ? this.updateMotionValue(f) : yee(n, r, f), this.animation.cancel();
      }
      d == null || d(), this.notifyFinished();
    };
  }
  play() {
    this.isStopped || (this.animation.play(), this.state === "finished" && this.updateFinished());
  }
  pause() {
    this.animation.pause();
  }
  complete() {
    var t, n;
    (n = (t = this.animation).finish) == null || n.call(t);
  }
  cancel() {
    try {
      this.animation.cancel();
    } catch {
    }
  }
  stop() {
    if (this.isStopped)
      return;
    this.isStopped = !0;
    const { state: t } = this;
    t === "idle" || t === "finished" || (this.updateMotionValue ? this.updateMotionValue() : this.commitStyles(), this.isPseudoElement || this.cancel());
  }
  /**
   * WAAPI doesn't natively have any interruption capabilities.
   *
   * In this method, we commit styles back to the DOM before cancelling
   * the animation.
   *
   * This is designed to be overridden by NativeAnimationExtended, which
   * will create a renderless JS animation and sample it twice to calculate
   * its current value, "previous" value, and therefore allow
   * Motion to also correctly calculate velocity for any subsequent animation
   * while deferring the commit until the next animation frame.
   */
  commitStyles() {
    var t, n;
    this.isPseudoElement || (n = (t = this.animation).commitStyles) == null || n.call(t);
  }
  get duration() {
    var t, n;
    const r = ((n = (t = this.animation.effect) == null ? void 0 : t.getComputedTiming) == null ? void 0 : n.call(t).duration) || 0;
    return /* @__PURE__ */ Lr(Number(r));
  }
  get time() {
    return /* @__PURE__ */ Lr(Number(this.animation.currentTime) || 0);
  }
  set time(t) {
    this.finishedTime = null, this.animation.currentTime = /* @__PURE__ */ Ir(t);
  }
  /**
   * The playback speed of the animation.
   * 1 = normal speed, 2 = double speed, 0.5 = half speed.
   */
  get speed() {
    return this.animation.playbackRate;
  }
  set speed(t) {
    t < 0 && (this.finishedTime = null), this.animation.playbackRate = t;
  }
  get state() {
    return this.finishedTime !== null ? "finished" : this.animation.playState;
  }
  get startTime() {
    return Number(this.animation.startTime);
  }
  set startTime(t) {
    this.animation.startTime = t;
  }
  /**
   * Attaches a timeline to the animation, for instance the `ScrollTimeline`.
   */
  attachTimeline({ timeline: t, observe: n }) {
    var r;
    return this.allowFlatten && ((r = this.animation.effect) == null || r.updateTiming({ easing: "linear" })), this.animation.onfinish = null, t && wee() ? (this.animation.timeline = t, va) : n(this);
  }
}
const h2 = {
  anticipate: HL,
  backInOut: zL,
  circInOut: KL
};
function See(e) {
  return e in h2;
}
function kee(e) {
  typeof e.ease == "string" && See(e.ease) && (e.ease = h2[e.ease]);
}
const MS = 10;
class Ree extends xee {
  constructor(t) {
    kee(t), a2(t), super(t), t.startTime && (this.startTime = t.startTime), this.options = t;
  }
  /**
   * WAAPI doesn't natively have any interruption capabilities.
   *
   * Rather than read commited styles back out of the DOM, we can
   * create a renderless JS animation and sample it twice to calculate
   * its current value, "previous" value, and therefore allow
   * Motion to calculate velocity for any subsequent animation.
   */
  updateMotionValue(t) {
    const { motionValue: n, onUpdate: r, onComplete: i, element: s, ...l } = this.options;
    if (!n)
      return;
    if (t !== void 0) {
      n.set(t);
      return;
    }
    const u = new Zw({
      ...l,
      autoplay: !1
    }), d = /* @__PURE__ */ Ir(this.finishedTime ?? this.time);
    n.setWithVelocity(u.sample(d - MS).value, u.sample(d).value, MS), u.stop();
  }
}
const OS = (e, t) => t === "zIndex" ? !1 : !!(typeof e == "number" || Array.isArray(e) || typeof e == "string" && // It's animatable if we have a string
(wa.test(e) || e === "0") && // And it contains numbers and/or colors
!e.startsWith("url("));
function Tee(e) {
  const t = e[0];
  if (e.length === 1)
    return !0;
  for (let n = 0; n < e.length; n++)
    if (e[n] !== t)
      return !0;
}
function $ee(e, t, n, r) {
  const i = e[0];
  if (i === null)
    return !1;
  if (t === "display" || t === "visibility")
    return !0;
  const s = e[e.length - 1], l = OS(i, t), u = OS(s, t);
  return !l || !u ? !1 : Tee(e) || (n === "spring" || f2(n)) && r;
}
function Iv(e) {
  e.duration = 0, e.type;
}
const Vee = /* @__PURE__ */ new Set([
  "opacity",
  "clipPath",
  "filter",
  "transform"
  // TODO: Could be re-enabled now we have support for linear() easing
  // "background-color"
]), _ee = /* @__PURE__ */ Fw(() => Object.hasOwnProperty.call(Element.prototype, "animate"));
function Iee(e) {
  var t;
  const { motionValue: n, name: r, repeatDelay: i, repeatType: s, damping: l, type: u } = e;
  if (!(((t = n == null ? void 0 : n.owner) == null ? void 0 : t.current) instanceof HTMLElement))
    return !1;
  const { onUpdate: d, transformTemplate: h } = n.owner.getProps();
  return _ee() && r && Vee.has(r) && (r !== "transform" || !h) && /**
  * If we're outputting values to onUpdate then we can't use WAAPI as there's
  * no way to read the value from WAAPI every frame.
  */
  !d && !i && s !== "mirror" && l !== 0 && u !== "inertia";
}
const Lee = 40;
class Pee extends Xw {
  constructor({ autoplay: t = !0, delay: n = 0, type: r = "keyframes", repeat: i = 0, repeatDelay: s = 0, repeatType: l = "loop", keyframes: u, name: d, motionValue: h, element: f, ...m }) {
    var g;
    super(), this.stop = () => {
      var b, A;
      this._animation && (this._animation.stop(), (b = this.stopTimeline) == null || b.call(this)), (A = this.keyframeResolver) == null || A.cancel();
    }, this.createdAt = Rn.now();
    const w = {
      autoplay: t,
      delay: n,
      type: r,
      repeat: i,
      repeatDelay: s,
      repeatType: l,
      name: d,
      motionValue: h,
      element: f,
      ...m
    }, E = (f == null ? void 0 : f.KeyframeResolver) || Qw;
    this.keyframeResolver = new E(u, (b, A, x) => this.onKeyframesResolved(b, A, w, !x), d, h, f), (g = this.keyframeResolver) == null || g.scheduleResolve();
  }
  onKeyframesResolved(t, n, r, i) {
    this.keyframeResolver = void 0;
    const { name: s, type: l, velocity: u, delay: d, isHandoff: h, onUpdate: f } = r;
    this.resolvedAt = Rn.now(), $ee(t, s, l, u) || ((Fr.instantAnimations || !d) && (f == null || f(qw(t, r, n))), t[0] = t[t.length - 1], Iv(r), r.repeat = 0);
    const m = {
      startTime: i ? this.resolvedAt ? this.resolvedAt - this.createdAt > Lee ? this.resolvedAt : this.createdAt : this.createdAt : void 0,
      finalKeyframe: n,
      ...r,
      keyframes: t
    }, g = !h && Iee(m) ? new Ree({
      ...m,
      element: m.motionValue.owner.current
    }) : new Zw(m);
    g.finished.then(() => this.notifyFinished()).catch(va), this.pendingTimeline && (this.stopTimeline = g.attachTimeline(this.pendingTimeline), this.pendingTimeline = void 0), this._animation = g;
  }
  get finished() {
    return this._animation ? this.animation.finished : this._finished;
  }
  then(t, n) {
    return this.finished.finally(t).then(() => {
    });
  }
  get animation() {
    var t;
    return this._animation || ((t = this.keyframeResolver) == null || t.resume(), gee()), this._animation;
  }
  get duration() {
    return this.animation.duration;
  }
  get time() {
    return this.animation.time;
  }
  set time(t) {
    this.animation.time = t;
  }
  get speed() {
    return this.animation.speed;
  }
  get state() {
    return this.animation.state;
  }
  set speed(t) {
    this.animation.speed = t;
  }
  get startTime() {
    return this.animation.startTime;
  }
  attachTimeline(t) {
    return this._animation ? this.stopTimeline = this.animation.attachTimeline(t) : this.pendingTimeline = t, () => this.stop();
  }
  play() {
    this.animation.play();
  }
  pause() {
    this.animation.pause();
  }
  complete() {
    this.animation.complete();
  }
  cancel() {
    var t;
    this._animation && this.animation.cancel(), (t = this.keyframeResolver) == null || t.cancel();
  }
}
const Mee = (
  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words
  /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u
);
function Oee(e) {
  const t = Mee.exec(e);
  if (!t)
    return [,];
  const [, n, r, i] = t;
  return [`--${n ?? r}`, i];
}
function p2(e, t, n = 1) {
  const [r, i] = Oee(e);
  if (!r)
    return;
  const s = window.getComputedStyle(t).getPropertyValue(r);
  if (s) {
    const l = s.trim();
    return ML(l) ? parseFloat(l) : l;
  }
  return zw(i) ? p2(i, t, n + 1) : i;
}
function m2(e, t) {
  return (e == null ? void 0 : e[t]) ?? (e == null ? void 0 : e.default) ?? e;
}
const g2 = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  ...ba
]), Bee = {
  test: (e) => e === "auto",
  parse: (e) => e
}, v2 = (e) => (t) => t.test(e), y2 = [ya, Ve, As, gi, TJ, RJ, Bee], BS = (e) => y2.find(v2(e));
function Nee(e) {
  return typeof e == "number" ? e === 0 : e !== null ? e === "none" || e === "0" || OL(e) : !0;
}
const Dee = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
function jee(e) {
  const [t, n] = e.slice(0, -1).split("(");
  if (t === "drop-shadow")
    return e;
  const [r] = n.match(Hw) || [];
  if (!r)
    return e;
  const i = n.replace(r, "");
  let s = Dee.has(t) ? 1 : 0;
  return r !== n && (s *= 100), t + "(" + s + i + ")";
}
const Fee = /\b([a-z-]*)\(.*?\)/gu, Lv = {
  ...wa,
  getAnimatableNone: (e) => {
    const t = e.match(Fee);
    return t ? t.map(jee).join(" ") : e;
  }
}, NS = {
  ...ya,
  transform: Math.round
}, Uee = {
  rotate: gi,
  rotateX: gi,
  rotateY: gi,
  rotateZ: gi,
  scale: nd,
  scaleX: nd,
  scaleY: nd,
  scaleZ: nd,
  skew: gi,
  skewX: gi,
  skewY: gi,
  distance: Ve,
  translateX: Ve,
  translateY: Ve,
  translateZ: Ve,
  x: Ve,
  y: Ve,
  z: Ve,
  perspective: Ve,
  transformPerspective: Ve,
  opacity: eu,
  originX: SS,
  originY: SS,
  originZ: Ve
}, Jw = {
  // Border props
  borderWidth: Ve,
  borderTopWidth: Ve,
  borderRightWidth: Ve,
  borderBottomWidth: Ve,
  borderLeftWidth: Ve,
  borderRadius: Ve,
  radius: Ve,
  borderTopLeftRadius: Ve,
  borderTopRightRadius: Ve,
  borderBottomRightRadius: Ve,
  borderBottomLeftRadius: Ve,
  // Positioning props
  width: Ve,
  maxWidth: Ve,
  height: Ve,
  maxHeight: Ve,
  top: Ve,
  right: Ve,
  bottom: Ve,
  left: Ve,
  // Spacing props
  padding: Ve,
  paddingTop: Ve,
  paddingRight: Ve,
  paddingBottom: Ve,
  paddingLeft: Ve,
  margin: Ve,
  marginTop: Ve,
  marginRight: Ve,
  marginBottom: Ve,
  marginLeft: Ve,
  // Misc
  backgroundPositionX: Ve,
  backgroundPositionY: Ve,
  ...Uee,
  zIndex: NS,
  // SVG
  fillOpacity: eu,
  strokeOpacity: eu,
  numOctaves: NS
}, Wee = {
  ...Jw,
  // Color props
  color: pt,
  backgroundColor: pt,
  outlineColor: pt,
  fill: pt,
  stroke: pt,
  // Border props
  borderColor: pt,
  borderTopColor: pt,
  borderRightColor: pt,
  borderBottomColor: pt,
  borderLeftColor: pt,
  filter: Lv,
  WebkitFilter: Lv
}, w2 = (e) => Wee[e];
function b2(e, t) {
  let n = w2(e);
  return n !== Lv && (n = wa), n.getAnimatableNone ? n.getAnimatableNone(t) : void 0;
}
const zee = /* @__PURE__ */ new Set(["auto", "none", "0"]);
function Hee(e, t, n) {
  let r = 0, i;
  for (; r < e.length && !i; ) {
    const s = e[r];
    typeof s == "string" && !zee.has(s) && tu(s).values.length && (i = e[r]), r++;
  }
  if (i && n)
    for (const s of t)
      e[s] = b2(n, i);
}
class Kee extends Qw {
  constructor(t, n, r, i, s) {
    super(t, n, r, i, s, !0);
  }
  readKeyframes() {
    const { unresolvedKeyframes: t, element: n, name: r } = this;
    if (!n || !n.current)
      return;
    super.readKeyframes();
    for (let d = 0; d < t.length; d++) {
      let h = t[d];
      if (typeof h == "string" && (h = h.trim(), zw(h))) {
        const f = p2(h, n.current);
        f !== void 0 && (t[d] = f), d === t.length - 1 && (this.finalKeyframe = h);
      }
    }
    if (this.resolveNoneKeyframes(), !g2.has(r) || t.length !== 2)
      return;
    const [i, s] = t, l = BS(i), u = BS(s);
    if (l !== u)
      if (LS(l) && LS(u))
        for (let d = 0; d < t.length; d++) {
          const h = t[d];
          typeof h == "string" && (t[d] = parseFloat(h));
        }
      else ho[r] && (this.needsMeasurement = !0);
  }
  resolveNoneKeyframes() {
    const { unresolvedKeyframes: t, name: n } = this, r = [];
    for (let i = 0; i < t.length; i++)
      (t[i] === null || Nee(t[i])) && r.push(i);
    r.length && Hee(t, r, n);
  }
  measureInitialState() {
    const { element: t, unresolvedKeyframes: n, name: r } = this;
    if (!t || !t.current)
      return;
    r === "height" && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = ho[r](t.measureViewportBox(), window.getComputedStyle(t.current)), n[0] = this.measuredOrigin;
    const i = n[n.length - 1];
    i !== void 0 && t.getValue(r, i).jump(i, !1);
  }
  measureEndState() {
    var t;
    const { element: n, name: r, unresolvedKeyframes: i } = this;
    if (!n || !n.current)
      return;
    const s = n.getValue(r);
    s && s.jump(this.measuredOrigin, !1);
    const l = i.length - 1, u = i[l];
    i[l] = ho[r](n.measureViewportBox(), window.getComputedStyle(n.current)), u !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = u), (t = this.removedTransforms) != null && t.length && this.removedTransforms.forEach(([d, h]) => {
      n.getValue(d).set(h);
    }), this.resolveNoneKeyframes();
  }
}
function Gee(e, t, n) {
  if (e instanceof EventTarget)
    return [e];
  if (typeof e == "string") {
    const i = document.querySelectorAll(e);
    return i ? Array.from(i) : [];
  }
  return Array.from(e);
}
const C2 = (e, t) => t && typeof e == "number" ? t.transform(e) : e;
function Yee(e) {
  return aJ(e) && "offsetHeight" in e;
}
const DS = 30, qee = (e) => !isNaN(parseFloat(e));
class Xee {
  /**
   * @param init - The initiating value
   * @param config - Optional configuration options
   *
   * -  `transformer`: A function to transform incoming values with.
   */
  constructor(t, n = {}) {
    this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = (r) => {
      var i;
      const s = Rn.now();
      if (this.updatedAt !== s && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(r), this.current !== this.prev && ((i = this.events.change) == null || i.notify(this.current), this.dependents))
        for (const l of this.dependents)
          l.dirty();
    }, this.hasAnimated = !1, this.setCurrent(t), this.owner = n.owner;
  }
  setCurrent(t) {
    this.current = t, this.updatedAt = Rn.now(), this.canTrackVelocity === null && t !== void 0 && (this.canTrackVelocity = qee(this.current));
  }
  setPrevFrameValue(t = this.current) {
    this.prevFrameValue = t, this.prevUpdatedAt = this.updatedAt;
  }
  /**
   * Adds a function that will be notified when the `MotionValue` is updated.
   *
   * It returns a function that, when called, will cancel the subscription.
   *
   * When calling `onChange` inside a React component, it should be wrapped with the
   * `useEffect` hook. As it returns an unsubscribe function, this should be returned
   * from the `useEffect` function to ensure you don't add duplicate subscribers..
   *
   * ```jsx
   * export const MyComponent = () => {
   *   const x = useMotionValue(0)
   *   const y = useMotionValue(0)
   *   const opacity = useMotionValue(1)
   *
   *   useEffect(() => {
   *     function updateOpacity() {
   *       const maxXY = Math.max(x.get(), y.get())
   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
   *       opacity.set(newOpacity)
   *     }
   *
   *     const unsubscribeX = x.on("change", updateOpacity)
   *     const unsubscribeY = y.on("change", updateOpacity)
   *
   *     return () => {
   *       unsubscribeX()
   *       unsubscribeY()
   *     }
   *   }, [])
   *
   *   return <motion.div style={{ x }} />
   * }
   * ```
   *
   * @param subscriber - A function that receives the latest value.
   * @returns A function that, when called, will cancel this subscription.
   *
   * @deprecated
   */
  onChange(t) {
    return this.on("change", t);
  }
  on(t, n) {
    this.events[t] || (this.events[t] = new NL());
    const r = this.events[t].add(n);
    return t === "change" ? () => {
      r(), Gn.read(() => {
        this.events.change.getSize() || this.stop();
      });
    } : r;
  }
  clearListeners() {
    for (const t in this.events)
      this.events[t].clear();
  }
  /**
   * Attaches a passive effect to the `MotionValue`.
   */
  attach(t, n) {
    this.passiveEffect = t, this.stopPassiveEffect = n;
  }
  /**
   * Sets the state of the `MotionValue`.
   *
   * @remarks
   *
   * ```jsx
   * const x = useMotionValue(0)
   * x.set(10)
   * ```
   *
   * @param latest - Latest value to set.
   * @param render - Whether to notify render subscribers. Defaults to `true`
   *
   * @public
   */
  set(t) {
    this.passiveEffect ? this.passiveEffect(t, this.updateAndNotify) : this.updateAndNotify(t);
  }
  setWithVelocity(t, n, r) {
    this.set(n), this.prev = void 0, this.prevFrameValue = t, this.prevUpdatedAt = this.updatedAt - r;
  }
  /**
   * Set the state of the `MotionValue`, stopping any active animations,
   * effects, and resets velocity to `0`.
   */
  jump(t, n = !0) {
    this.updateAndNotify(t), this.prev = t, this.prevUpdatedAt = this.prevFrameValue = void 0, n && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
  dirty() {
    var t;
    (t = this.events.change) == null || t.notify(this.current);
  }
  addDependent(t) {
    this.dependents || (this.dependents = /* @__PURE__ */ new Set()), this.dependents.add(t);
  }
  removeDependent(t) {
    this.dependents && this.dependents.delete(t);
  }
  /**
   * Returns the latest state of `MotionValue`
   *
   * @returns - The latest state of `MotionValue`
   *
   * @public
   */
  get() {
    return this.current;
  }
  /**
   * @public
   */
  getPrevious() {
    return this.prev;
  }
  /**
   * Returns the latest velocity of `MotionValue`
   *
   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
   *
   * @public
   */
  getVelocity() {
    const t = Rn.now();
    if (!this.canTrackVelocity || this.prevFrameValue === void 0 || t - this.updatedAt > DS)
      return 0;
    const n = Math.min(this.updatedAt - this.prevUpdatedAt, DS);
    return DL(parseFloat(this.current) - parseFloat(this.prevFrameValue), n);
  }
  /**
   * Registers a new animation to control this `MotionValue`. Only one
   * animation can drive a `MotionValue` at one time.
   *
   * ```jsx
   * value.start()
   * ```
   *
   * @param animation - A function that starts the provided animation
   */
  start(t) {
    return this.stop(), new Promise((n) => {
      this.hasAnimated = !0, this.animation = t(n), this.events.animationStart && this.events.animationStart.notify();
    }).then(() => {
      this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation();
    });
  }
  /**
   * Stop the currently active animation.
   *
   * @public
   */
  stop() {
    this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation();
  }
  /**
   * Returns `true` if this value is currently animating.
   *
   * @public
   */
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  /**
   * Destroy and clean up subscribers to this `MotionValue`.
   *
   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
   * created a `MotionValue` via the `motionValue` function.
   *
   * @public
   */
  destroy() {
    var t, n;
    (t = this.dependents) == null || t.clear(), (n = this.events.destroy) == null || n.notify(), this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
}
function of(e, t) {
  return new Xee(e, t);
}
const { schedule: Zee } = /* @__PURE__ */ qL(queueMicrotask, !1), Qee = {
  y: !1
};
function Jee() {
  return Qee.y;
}
function E2(e, t) {
  const n = Gee(e), r = new AbortController(), i = {
    passive: !0,
    ...t,
    signal: r.signal
  };
  return [n, i, () => r.abort()];
}
function jS(e) {
  return !(e.pointerType === "touch" || Jee());
}
function ete(e, t, n = {}) {
  const [r, i, s] = E2(e, n), l = (u) => {
    if (!jS(u))
      return;
    const { target: d } = u, h = t(d, u);
    if (typeof h != "function" || !d)
      return;
    const f = (m) => {
      jS(m) && (h(m), d.removeEventListener("pointerleave", f));
    };
    d.addEventListener("pointerleave", f, i);
  };
  return r.forEach((u) => {
    u.addEventListener("pointerenter", l, i);
  }), s;
}
const A2 = (e, t) => t ? e === t ? !0 : A2(e, t.parentElement) : !1, tte = (e) => e.pointerType === "mouse" ? typeof e.button != "number" || e.button <= 0 : e.isPrimary !== !1, nte = /* @__PURE__ */ new Set([
  "BUTTON",
  "INPUT",
  "SELECT",
  "TEXTAREA",
  "A"
]);
function rte(e) {
  return nte.has(e.tagName) || e.tabIndex !== -1;
}
const xd = /* @__PURE__ */ new WeakSet();
function FS(e) {
  return (t) => {
    t.key === "Enter" && e(t);
  };
}
function Wm(e, t) {
  e.dispatchEvent(new PointerEvent("pointer" + t, { isPrimary: !0, bubbles: !0 }));
}
const ite = (e, t) => {
  const n = e.currentTarget;
  if (!n)
    return;
  const r = FS(() => {
    if (xd.has(n))
      return;
    Wm(n, "down");
    const i = FS(() => {
      Wm(n, "up");
    }), s = () => Wm(n, "cancel");
    n.addEventListener("keyup", i, t), n.addEventListener("blur", s, t);
  });
  n.addEventListener("keydown", r, t), n.addEventListener("blur", () => n.removeEventListener("keydown", r), t);
};
function US(e) {
  return tte(e) && !0;
}
function ote(e, t, n = {}) {
  const [r, i, s] = E2(e, n), l = (u) => {
    const d = u.currentTarget;
    if (!US(u))
      return;
    xd.add(d);
    const h = t(d, u), f = (w, E) => {
      window.removeEventListener("pointerup", m), window.removeEventListener("pointercancel", g), xd.has(d) && xd.delete(d), US(w) && typeof h == "function" && h(w, { success: E });
    }, m = (w) => {
      f(w, d === window || d === document || n.useGlobalTarget || A2(d, w.target));
    }, g = (w) => {
      f(w, !1);
    };
    window.addEventListener("pointerup", m, i), window.addEventListener("pointercancel", g, i);
  };
  return r.forEach((u) => {
    (n.useGlobalTarget ? window : u).addEventListener("pointerdown", l, i), Yee(u) && (u.addEventListener("focus", (d) => ite(d, i)), !rte(u) && !u.hasAttribute("tabindex") && (u.tabIndex = 0));
  }), s;
}
const Ft = (e) => !!(e && e.getVelocity), ste = [...y2, pt, wa], ate = (e) => ste.find(v2(e)), x2 = C.createContext({
  transformPagePoint: (e) => e,
  isStatic: !1,
  reducedMotion: "never"
}), eb = C.createContext({ strict: !1 }), WS = {
  animation: [
    "animate",
    "variants",
    "whileHover",
    "whileTap",
    "exit",
    "whileInView",
    "whileFocus",
    "whileDrag"
  ],
  exit: ["exit"],
  drag: ["drag", "dragControls"],
  focus: ["whileFocus"],
  hover: ["whileHover", "onHoverStart", "onHoverEnd"],
  tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
  pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
  inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
  layout: ["layout", "layoutId"]
}, zs = {};
for (const e in WS)
  zs[e] = {
    isEnabled: (t) => WS[e].some((n) => !!t[n])
  };
function zS(e) {
  for (const t in e)
    zs[t] = {
      ...zs[t],
      ...e[t]
    };
}
function lte({ children: e, features: t, strict: n = !1 }) {
  const [, r] = C.useState(!zm(t)), i = C.useRef(void 0);
  if (!zm(t)) {
    const { renderer: s, ...l } = t;
    i.current = s, zS(l);
  }
  return C.useEffect(() => {
    zm(t) && t().then(({ renderer: s, ...l }) => {
      zS(l), i.current = s, r(!0);
    });
  }, []), I.jsx(eb.Provider, { value: { renderer: i.current, strict: n }, children: e });
}
function zm(e) {
  return typeof e == "function";
}
const ute = /* @__PURE__ */ new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "custom",
  "inherit",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "globalTapTarget",
  "ignoreStrict",
  "viewport"
]);
function sf(e) {
  return e.startsWith("while") || e.startsWith("drag") && e !== "draggable" || e.startsWith("layout") || e.startsWith("onTap") || e.startsWith("onPan") || e.startsWith("onLayout") || ute.has(e);
}
let S2 = (e) => !sf(e);
function cte(e) {
  typeof e == "function" && (S2 = (t) => t.startsWith("on") ? !sf(t) : e(t));
}
try {
  cte(require("@emotion/is-prop-valid").default);
} catch {
}
function dte(e, t, n) {
  const r = {};
  for (const i in e)
    i === "values" && typeof e.values == "object" || (S2(i) || n === !0 && sf(i) || !t && !sf(i) || // If trying to use native HTML drag events, forward drag listeners
    e.draggable && i.startsWith("onDrag")) && (r[i] = e[i]);
  return r;
}
const Hf = /* @__PURE__ */ C.createContext({});
function Kf(e) {
  return e !== null && typeof e == "object" && typeof e.start == "function";
}
function nu(e) {
  return typeof e == "string" || Array.isArray(e);
}
const tb = [
  "animate",
  "whileInView",
  "whileFocus",
  "whileHover",
  "whileTap",
  "whileDrag",
  "exit"
], nb = ["initial", ...tb];
function Gf(e) {
  return Kf(e.animate) || nb.some((t) => nu(e[t]));
}
function k2(e) {
  return !!(Gf(e) || e.variants);
}
function fte(e, t) {
  if (Gf(e)) {
    const { initial: n, animate: r } = e;
    return {
      initial: n === !1 || nu(n) ? n : void 0,
      animate: nu(r) ? r : void 0
    };
  }
  return e.inherit !== !1 ? t : {};
}
function hte(e) {
  const { initial: t, animate: n } = fte(e, C.useContext(Hf));
  return C.useMemo(() => ({ initial: t, animate: n }), [HS(t), HS(n)]);
}
function HS(e) {
  return Array.isArray(e) ? e.join(" ") : e;
}
const pte = {};
function R2(e, { layout: t, layoutId: n }) {
  return Ca.has(e) || e.startsWith("origin") || (t || n !== void 0) && (!!pte[e] || e === "opacity");
}
const mte = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
}, gte = ba.length;
function vte(e, t, n) {
  let r = "", i = !0;
  for (let s = 0; s < gte; s++) {
    const l = ba[s], u = e[l];
    if (u === void 0)
      continue;
    let d = !0;
    if (typeof u == "number" ? d = u === (l.startsWith("scale") ? 1 : 0) : d = parseFloat(u) === 0, !d || n) {
      const h = C2(u, Jw[l]);
      if (!d) {
        i = !1;
        const f = mte[l] || l;
        r += `${f}(${h}) `;
      }
      n && (t[l] = h);
    }
  }
  return r = r.trim(), n ? r = n(t, i ? "" : r) : i && (r = "none"), r;
}
function rb(e, t, n) {
  const { style: r, vars: i, transformOrigin: s } = e;
  let l = !1, u = !1;
  for (const d in t) {
    const h = t[d];
    if (Ca.has(d)) {
      l = !0;
      continue;
    } else if (ZL(d)) {
      i[d] = h;
      continue;
    } else {
      const f = C2(h, Jw[d]);
      d.startsWith("origin") ? (u = !0, s[d] = f) : r[d] = f;
    }
  }
  if (t.transform || (l || n ? r.transform = vte(t, e.transform, n) : r.transform && (r.transform = "none")), u) {
    const { originX: d = "50%", originY: h = "50%", originZ: f = 0 } = s;
    r.transformOrigin = `${d} ${h} ${f}`;
  }
}
const ib = () => ({
  style: {},
  transform: {},
  transformOrigin: {},
  vars: {}
});
function T2(e, t, n) {
  for (const r in t)
    !Ft(t[r]) && !R2(r, n) && (e[r] = t[r]);
}
function yte({ transformTemplate: e }, t) {
  return C.useMemo(() => {
    const n = ib();
    return rb(n, t, e), Object.assign({}, n.vars, n.style);
  }, [t]);
}
function wte(e, t) {
  const n = e.style || {}, r = {};
  return T2(r, n, e), Object.assign(r, yte(e, t)), r;
}
function bte(e, t) {
  const n = {}, r = wte(e, t);
  return e.drag && e.dragListener !== !1 && (n.draggable = !1, r.userSelect = r.WebkitUserSelect = r.WebkitTouchCallout = "none", r.touchAction = e.drag === !0 ? "none" : `pan-${e.drag === "x" ? "y" : "x"}`), e.tabIndex === void 0 && (e.onTap || e.onTapStart || e.whileTap) && (n.tabIndex = 0), n.style = r, n;
}
const Cte = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
}, Ete = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function Ate(e, t, n = 1, r = 0, i = !0) {
  e.pathLength = 1;
  const s = i ? Cte : Ete;
  e[s.offset] = Ve.transform(-r);
  const l = Ve.transform(t), u = Ve.transform(n);
  e[s.array] = `${l} ${u}`;
}
function $2(e, {
  attrX: t,
  attrY: n,
  attrScale: r,
  pathLength: i,
  pathSpacing: s = 1,
  pathOffset: l = 0,
  // This is object creation, which we try to avoid per-frame.
  ...u
}, d, h, f) {
  if (rb(e, u, h), d) {
    e.style.viewBox && (e.attrs.viewBox = e.style.viewBox);
    return;
  }
  e.attrs = e.style, e.style = {};
  const { attrs: m, style: g } = e;
  m.transform && (g.transform = m.transform, delete m.transform), (g.transform || m.transformOrigin) && (g.transformOrigin = m.transformOrigin ?? "50% 50%", delete m.transformOrigin), g.transform && (g.transformBox = (f == null ? void 0 : f.transformBox) ?? "fill-box", delete m.transformBox), t !== void 0 && (m.x = t), n !== void 0 && (m.y = n), r !== void 0 && (m.scale = r), i !== void 0 && Ate(m, i, s, l, !1);
}
const V2 = () => ({
  ...ib(),
  attrs: {}
}), _2 = (e) => typeof e == "string" && e.toLowerCase() === "svg";
function xte(e, t, n, r) {
  const i = C.useMemo(() => {
    const s = V2();
    return $2(s, t, _2(r), e.transformTemplate, e.style), {
      ...s.attrs,
      style: { ...s.style }
    };
  }, [t]);
  if (e.style) {
    const s = {};
    T2(s, e.style, e), i.style = { ...s, ...i.style };
  }
  return i;
}
const Ste = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view"
];
function ob(e) {
  return (
    /**
     * If it's not a string, it's a custom React component. Currently we only support
     * HTML custom React components.
     */
    typeof e != "string" || /**
    * If it contains a dash, the element is a custom HTML webcomponent.
    */
    e.includes("-") ? !1 : (
      /**
       * If it's in our list of lowercase SVG tags, it's an SVG component
       */
      !!(Ste.indexOf(e) > -1 || /**
      * If it contains a capital letter, it's an SVG component
      */
      /[A-Z]/u.test(e))
    )
  );
}
function kte(e, t, n, { latestValues: r }, i, s = !1) {
  const l = (ob(e) ? xte : bte)(t, r, i, e), u = dte(t, typeof e == "string", s), d = e !== C.Fragment ? { ...u, ...l, ref: n } : {}, { children: h } = t, f = C.useMemo(() => Ft(h) ? h.get() : h, [h]);
  return C.createElement(e, {
    ...d,
    children: f
  });
}
function KS(e) {
  const t = [{}, {}];
  return e == null || e.values.forEach((n, r) => {
    t[0][r] = n.get(), t[1][r] = n.getVelocity();
  }), t;
}
function sb(e, t, n, r) {
  if (typeof t == "function") {
    const [i, s] = KS(r);
    t = t(n !== void 0 ? n : e.custom, i, s);
  }
  if (typeof t == "string" && (t = e.variants && e.variants[t]), typeof t == "function") {
    const [i, s] = KS(r);
    t = t(n !== void 0 ? n : e.custom, i, s);
  }
  return t;
}
function Rte(e) {
  return Ft(e) ? e.get() : e;
}
function Tte({ scrapeMotionValuesFromProps: e, createRenderState: t }, n, r, i) {
  return {
    latestValues: $te(n, r, i, e),
    renderState: t()
  };
}
function $te(e, t, n, r) {
  const i = {}, s = r(e, {});
  for (const g in s)
    i[g] = Rte(s[g]);
  let { initial: l, animate: u } = e;
  const d = Gf(e), h = k2(e);
  t && h && !d && e.inherit !== !1 && (l === void 0 && (l = t.initial), u === void 0 && (u = t.animate));
  let f = n ? n.initial === !1 : !1;
  f = f || l === !1;
  const m = f ? u : l;
  if (m && typeof m != "boolean" && !Kf(m)) {
    const g = Array.isArray(m) ? m : [m];
    for (let w = 0; w < g.length; w++) {
      const E = sb(e, g[w]);
      if (E) {
        const { transitionEnd: b, transition: A, ...x } = E;
        for (const R in x) {
          let _ = x[R];
          if (Array.isArray(_)) {
            const L = f ? _.length - 1 : 0;
            _ = _[L];
          }
          _ !== null && (i[R] = _);
        }
        for (const R in b)
          i[R] = b[R];
      }
    }
  }
  return i;
}
const I2 = (e) => (t, n) => {
  const r = C.useContext(Hf), i = C.useContext(PL), s = () => Tte(e, t, r, i);
  return n ? s() : rJ(s);
};
function ab(e, t, n) {
  var r;
  const { style: i } = e, s = {};
  for (const l in i)
    (Ft(i[l]) || t.style && Ft(t.style[l]) || R2(l, e) || ((r = n == null ? void 0 : n.getValue(l)) == null ? void 0 : r.liveStyle) !== void 0) && (s[l] = i[l]);
  return s;
}
const Vte = /* @__PURE__ */ I2({
  scrapeMotionValuesFromProps: ab,
  createRenderState: ib
});
function L2(e, t, n) {
  const r = ab(e, t, n);
  for (const i in e)
    if (Ft(e[i]) || Ft(t[i])) {
      const s = ba.indexOf(i) !== -1 ? "attr" + i.charAt(0).toUpperCase() + i.substring(1) : i;
      r[s] = e[i];
    }
  return r;
}
const _te = /* @__PURE__ */ I2({
  scrapeMotionValuesFromProps: L2,
  createRenderState: V2
}), Ite = Symbol.for("motionComponentSymbol");
function P2(e) {
  return e && typeof e == "object" && Object.prototype.hasOwnProperty.call(e, "current");
}
function Lte(e, t, n) {
  return C.useCallback(
    (r) => {
      r && e.onMount && e.onMount(r), t && (r ? t.mount(r) : t.unmount()), n && (typeof n == "function" ? n(r) : P2(n) && (n.current = r));
    },
    /**
     * Only pass a new ref callback to React if we've received a visual element
     * factory. Otherwise we'll be mounting/remounting every time externalRef
     * or other dependencies change.
     */
    [t]
  );
}
const lb = (e) => e.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(), Pte = "framerAppearId", M2 = "data-" + lb(Pte), Mte = C.createContext({});
function Ote(e, t, n, r, i) {
  var s, l;
  const { visualElement: u } = C.useContext(Hf), d = C.useContext(eb), h = C.useContext(PL), f = C.useContext(x2).reducedMotion, m = C.useRef(null);
  r = r || d.renderer, !m.current && r && (m.current = r(e, {
    visualState: t,
    parent: u,
    props: n,
    presenceContext: h,
    blockInitialAnimation: h ? h.initial === !1 : !1,
    reducedMotionConfig: f
  }));
  const g = m.current, w = C.useContext(Mte);
  g && !g.projection && i && (g.type === "html" || g.type === "svg") && Bte(m.current, n, i, w);
  const E = C.useRef(!1);
  C.useInsertionEffect(() => {
    g && E.current && g.update(n, h);
  });
  const b = n[M2], A = C.useRef(!!b && !((s = window.MotionHandoffIsComplete) != null && s.call(window, b)) && ((l = window.MotionHasOptimisedAnimation) == null ? void 0 : l.call(window, b)));
  return iJ(() => {
    g && (E.current = !0, window.MotionIsMounted = !0, g.updateFeatures(), g.scheduleRenderMicrotask(), A.current && g.animationState && g.animationState.animateChanges());
  }), C.useEffect(() => {
    g && (!A.current && g.animationState && g.animationState.animateChanges(), A.current && (queueMicrotask(() => {
      var x;
      (x = window.MotionHandoffMarkAsComplete) == null || x.call(window, b);
    }), A.current = !1), g.enteringChildren = void 0);
  }), g;
}
function Bte(e, t, n, r) {
  const { layoutId: i, layout: s, drag: l, dragConstraints: u, layoutScroll: d, layoutRoot: h, layoutCrossfade: f } = t;
  e.projection = new n(e.latestValues, t["data-framer-portal-id"] ? void 0 : O2(e.parent)), e.projection.setOptions({
    layoutId: i,
    layout: s,
    alwaysMeasureLayout: !!l || u && P2(u),
    visualElement: e,
    /**
     * TODO: Update options in an effect. This could be tricky as it'll be too late
     * to update by the time layout animations run.
     * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
     * ensuring it gets called if there's no potential layout animations.
     *
     */
    animationType: typeof s == "string" ? s : "both",
    initialPromotionConfig: r,
    crossfade: f,
    layoutScroll: d,
    layoutRoot: h
  });
}
function O2(e) {
  if (e)
    return e.options.allowProjection !== !1 ? e.projection : O2(e.parent);
}
function Nte(e, { forwardMotionProps: t = !1 } = {}, n, r) {
  const i = ob(e) ? _te : Vte;
  function s(u, d) {
    let h;
    const f = {
      ...C.useContext(x2),
      ...u,
      layoutId: Dte(u)
    }, { isStatic: m } = f, g = hte(u), w = i(u, m);
    if (!m && Dw) {
      jte();
      const E = Fte(f);
      h = E.MeasureLayout, g.visualElement = Ote(e, w, f, r, E.ProjectionNode);
    }
    return I.jsxs(Hf.Provider, { value: g, children: [h && g.visualElement ? I.jsx(h, { visualElement: g.visualElement, ...f }) : null, kte(e, u, Lte(w, g.visualElement, d), w, m, t)] });
  }
  s.displayName = `motion.${typeof e == "string" ? e : `create(${e.displayName ?? e.name ?? ""})`}`;
  const l = C.forwardRef(s);
  return l[Ite] = e, l;
}
function Dte({ layoutId: e }) {
  const t = C.useContext(nJ).id;
  return t && e !== void 0 ? t + "-" + e : e;
}
function jte(e, t) {
  C.useContext(eb).strict;
}
function Fte(e) {
  const { drag: t, layout: n } = zs;
  if (!t && !n)
    return {};
  const r = { ...t, ...n };
  return {
    MeasureLayout: t != null && t.isEnabled(e) || n != null && n.isEnabled(e) ? r.MeasureLayout : void 0,
    ProjectionNode: r.ProjectionNode
  };
}
function Ute({ top: e, left: t, right: n, bottom: r }) {
  return {
    x: { min: t, max: n },
    y: { min: e, max: r }
  };
}
function Wte(e, t) {
  if (!t)
    return e;
  const n = t({ x: e.left, y: e.top }), r = t({ x: e.right, y: e.bottom });
  return {
    top: n.y,
    left: n.x,
    bottom: r.y,
    right: r.x
  };
}
function zte(e, t) {
  return Ute(Wte(e.getBoundingClientRect(), t));
}
const GS = () => ({ min: 0, max: 0 }), B2 = () => ({
  x: GS(),
  y: GS()
}), Pv = { current: null }, N2 = { current: !1 };
function Hte() {
  if (N2.current = !0, !!Dw)
    if (window.matchMedia) {
      const e = window.matchMedia("(prefers-reduced-motion)"), t = () => Pv.current = e.matches;
      e.addEventListener("change", t), t();
    } else
      Pv.current = !1;
}
const Kte = /* @__PURE__ */ new WeakMap();
function Gte(e, t, n) {
  for (const r in t) {
    const i = t[r], s = n[r];
    if (Ft(i))
      e.addValue(r, i);
    else if (Ft(s))
      e.addValue(r, of(i, { owner: e }));
    else if (s !== i)
      if (e.hasValue(r)) {
        const l = e.getValue(r);
        l.liveStyle === !0 ? l.jump(i) : l.hasAnimated || l.set(i);
      } else {
        const l = e.getStaticValue(r);
        e.addValue(r, of(l !== void 0 ? l : i, { owner: e }));
      }
  }
  for (const r in n)
    t[r] === void 0 && e.removeValue(r);
  return t;
}
const YS = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete"
];
class Yte {
  /**
   * This method takes React props and returns found MotionValues. For example, HTML
   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
   *
   * This isn't an abstract method as it needs calling in the constructor, but it is
   * intended to be one.
   */
  scrapeMotionValuesFromProps(t, n, r) {
    return {};
  }
  constructor({ parent: t, props: n, presenceContext: r, reducedMotionConfig: i, blockInitialAnimation: s, visualState: l }, u = {}) {
    this.current = null, this.children = /* @__PURE__ */ new Set(), this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = /* @__PURE__ */ new Map(), this.KeyframeResolver = Qw, this.features = {}, this.valueSubscriptions = /* @__PURE__ */ new Map(), this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => {
      this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection));
    }, this.renderScheduledAt = 0, this.scheduleRender = () => {
      const g = Rn.now();
      this.renderScheduledAt < g && (this.renderScheduledAt = g, Gn.render(this.render, !1, !0));
    };
    const { latestValues: d, renderState: h } = l;
    this.latestValues = d, this.baseTarget = { ...d }, this.initialValues = n.initial ? { ...d } : {}, this.renderState = h, this.parent = t, this.props = n, this.presenceContext = r, this.depth = t ? t.depth + 1 : 0, this.reducedMotionConfig = i, this.options = u, this.blockInitialAnimation = !!s, this.isControllingVariants = Gf(n), this.isVariantNode = k2(n), this.isVariantNode && (this.variantChildren = /* @__PURE__ */ new Set()), this.manuallyAnimateOnMount = !!(t && t.current);
    const { willChange: f, ...m } = this.scrapeMotionValuesFromProps(n, {}, this);
    for (const g in m) {
      const w = m[g];
      d[g] !== void 0 && Ft(w) && w.set(d[g]);
    }
  }
  mount(t) {
    var n;
    this.current = t, Kte.set(t, this), this.projection && !this.projection.instance && this.projection.mount(t), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((r, i) => this.bindToMotionValue(i, r)), N2.current || Hte(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : Pv.current, (n = this.parent) == null || n.addChild(this), this.update(this.props, this.presenceContext);
  }
  unmount() {
    var t;
    this.projection && this.projection.unmount(), bv(this.notifyUpdate), bv(this.render), this.valueSubscriptions.forEach((n) => n()), this.valueSubscriptions.clear(), this.removeFromVariantTree && this.removeFromVariantTree(), (t = this.parent) == null || t.removeChild(this);
    for (const n in this.events)
      this.events[n].clear();
    for (const n in this.features) {
      const r = this.features[n];
      r && (r.unmount(), r.isMounted = !1);
    }
    this.current = null;
  }
  addChild(t) {
    this.children.add(t), this.enteringChildren ?? (this.enteringChildren = /* @__PURE__ */ new Set()), this.enteringChildren.add(t);
  }
  removeChild(t) {
    this.children.delete(t), this.enteringChildren && this.enteringChildren.delete(t);
  }
  bindToMotionValue(t, n) {
    this.valueSubscriptions.has(t) && this.valueSubscriptions.get(t)();
    const r = Ca.has(t);
    r && this.onBindTransform && this.onBindTransform();
    const i = n.on("change", (l) => {
      this.latestValues[t] = l, this.props.onUpdate && Gn.preRender(this.notifyUpdate), r && this.projection && (this.projection.isTransformDirty = !0), this.scheduleRender();
    });
    let s;
    window.MotionCheckAppearSync && (s = window.MotionCheckAppearSync(this, t, n)), this.valueSubscriptions.set(t, () => {
      i(), s && s(), n.owner && n.stop();
    });
  }
  sortNodePosition(t) {
    return !this.current || !this.sortInstanceNodePosition || this.type !== t.type ? 0 : this.sortInstanceNodePosition(this.current, t.current);
  }
  updateFeatures() {
    let t = "animation";
    for (t in zs) {
      const n = zs[t];
      if (!n)
        continue;
      const { isEnabled: r, Feature: i } = n;
      if (!this.features[t] && i && r(this.props) && (this.features[t] = new i(this)), this.features[t]) {
        const s = this.features[t];
        s.isMounted ? s.update() : (s.mount(), s.isMounted = !0);
      }
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.props);
  }
  /**
   * Measure the current viewport box with or without transforms.
   * Only measures axis-aligned boxes, rotate and skew must be manually
   * removed with a re-render to work.
   */
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : B2();
  }
  getStaticValue(t) {
    return this.latestValues[t];
  }
  setStaticValue(t, n) {
    this.latestValues[t] = n;
  }
  /**
   * Update the provided props. Ensure any newly-added motion values are
   * added to our map, old ones removed, and listeners updated.
   */
  update(t, n) {
    (t.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = t, this.prevPresenceContext = this.presenceContext, this.presenceContext = n;
    for (let r = 0; r < YS.length; r++) {
      const i = YS[r];
      this.propEventSubscriptions[i] && (this.propEventSubscriptions[i](), delete this.propEventSubscriptions[i]);
      const s = "on" + i, l = t[s];
      l && (this.propEventSubscriptions[i] = this.on(i, l));
    }
    this.prevMotionValues = Gte(this, this.scrapeMotionValuesFromProps(t, this.prevProps, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue();
  }
  getProps() {
    return this.props;
  }
  /**
   * Returns the variant definition with a given name.
   */
  getVariant(t) {
    return this.props.variants ? this.props.variants[t] : void 0;
  }
  /**
   * Returns the defined default transition on this component.
   */
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
  }
  /**
   * Add a child visual element to our set of children.
   */
  addVariantChild(t) {
    const n = this.getClosestVariantNode();
    if (n)
      return n.variantChildren && n.variantChildren.add(t), () => n.variantChildren.delete(t);
  }
  /**
   * Add a motion value and bind it to this visual element.
   */
  addValue(t, n) {
    const r = this.values.get(t);
    n !== r && (r && this.removeValue(t), this.bindToMotionValue(t, n), this.values.set(t, n), this.latestValues[t] = n.get());
  }
  /**
   * Remove a motion value and unbind any active subscriptions.
   */
  removeValue(t) {
    this.values.delete(t);
    const n = this.valueSubscriptions.get(t);
    n && (n(), this.valueSubscriptions.delete(t)), delete this.latestValues[t], this.removeValueFromRenderState(t, this.renderState);
  }
  /**
   * Check whether we have a motion value for this key
   */
  hasValue(t) {
    return this.values.has(t);
  }
  getValue(t, n) {
    if (this.props.values && this.props.values[t])
      return this.props.values[t];
    let r = this.values.get(t);
    return r === void 0 && n !== void 0 && (r = of(n === null ? void 0 : n, { owner: this }), this.addValue(t, r)), r;
  }
  /**
   * If we're trying to animate to a previously unencountered value,
   * we need to check for it in our state and as a last resort read it
   * directly from the instance (which might have performance implications).
   */
  readValue(t, n) {
    let r = this.latestValues[t] !== void 0 || !this.current ? this.latestValues[t] : this.getBaseTargetFromProps(this.props, t) ?? this.readValueFromInstance(this.current, t, this.options);
    return r != null && (typeof r == "string" && (ML(r) || OL(r)) ? r = parseFloat(r) : !ate(r) && wa.test(n) && (r = b2(t, n)), this.setBaseTarget(t, Ft(r) ? r.get() : r)), Ft(r) ? r.get() : r;
  }
  /**
   * Set the base target to later animate back to. This is currently
   * only hydrated on creation and when we first read a value.
   */
  setBaseTarget(t, n) {
    this.baseTarget[t] = n;
  }
  /**
   * Find the base target for a value thats been removed from all animation
   * props.
   */
  getBaseTarget(t) {
    var n;
    const { initial: r } = this.props;
    let i;
    if (typeof r == "string" || typeof r == "object") {
      const l = sb(this.props, r, (n = this.presenceContext) == null ? void 0 : n.custom);
      l && (i = l[t]);
    }
    if (r && i !== void 0)
      return i;
    const s = this.getBaseTargetFromProps(this.props, t);
    return s !== void 0 && !Ft(s) ? s : this.initialValues[t] !== void 0 && i === void 0 ? void 0 : this.baseTarget[t];
  }
  on(t, n) {
    return this.events[t] || (this.events[t] = new NL()), this.events[t].add(n);
  }
  notify(t, ...n) {
    this.events[t] && this.events[t].notify(...n);
  }
  scheduleRenderMicrotask() {
    Zee.render(this.render);
  }
}
class D2 extends Yte {
  constructor() {
    super(...arguments), this.KeyframeResolver = Kee;
  }
  sortInstanceNodePosition(t, n) {
    return t.compareDocumentPosition(n) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(t, n) {
    return t.style ? t.style[n] : void 0;
  }
  removeValueFromRenderState(t, { vars: n, style: r }) {
    delete n[t], delete r[t];
  }
  handleChildMotionValue() {
    this.childSubscription && (this.childSubscription(), delete this.childSubscription);
    const { children: t } = this.props;
    Ft(t) && (this.childSubscription = t.on("change", (n) => {
      this.current && (this.current.textContent = `${n}`);
    }));
  }
}
function j2(e, { style: t, vars: n }, r, i) {
  const s = e.style;
  let l;
  for (l in t)
    s[l] = t[l];
  i == null || i.applyProjectionStyles(s, r);
  for (l in n)
    s.setProperty(l, n[l]);
}
function qte(e) {
  return window.getComputedStyle(e);
}
class Xte extends D2 {
  constructor() {
    super(...arguments), this.type = "html", this.renderInstance = j2;
  }
  readValueFromInstance(t, n) {
    var r;
    if (Ca.has(n))
      return (r = this.projection) != null && r.isProjecting ? Rv(n) : dee(t, n);
    {
      const i = qte(t), s = (ZL(n) ? i.getPropertyValue(n) : i[n]) || 0;
      return typeof s == "string" ? s.trim() : s;
    }
  }
  measureInstanceViewportBox(t, { transformPagePoint: n }) {
    return zte(t, n);
  }
  build(t, n, r) {
    rb(t, n, r.transformTemplate);
  }
  scrapeMotionValuesFromProps(t, n, r) {
    return ab(t, n, r);
  }
}
const F2 = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust"
]);
function Zte(e, t, n, r) {
  j2(e, t, void 0, r);
  for (const i in t.attrs)
    e.setAttribute(F2.has(i) ? i : lb(i), t.attrs[i]);
}
class Qte extends D2 {
  constructor() {
    super(...arguments), this.type = "svg", this.isSVGTag = !1, this.measureInstanceViewportBox = B2;
  }
  getBaseTargetFromProps(t, n) {
    return t[n];
  }
  readValueFromInstance(t, n) {
    if (Ca.has(n)) {
      const r = w2(n);
      return r && r.default || 0;
    }
    return n = F2.has(n) ? n : lb(n), t.getAttribute(n);
  }
  scrapeMotionValuesFromProps(t, n, r) {
    return L2(t, n, r);
  }
  build(t, n, r) {
    $2(t, n, this.isSVGTag, r.transformTemplate, r.style);
  }
  renderInstance(t, n, r, i) {
    Zte(t, n, r, i);
  }
  mount(t) {
    this.isSVGTag = _2(t.tagName), super.mount(t);
  }
}
const Jte = (e, t) => ob(e) ? new Qte(t) : new Xte(t, {
  allowProjection: e !== C.Fragment
});
function xs(e, t, n) {
  const r = e.getProps();
  return sb(r, t, n !== void 0 ? n : r.custom, e);
}
const Mv = (e) => Array.isArray(e);
function ene(e, t, n) {
  e.hasValue(t) ? e.getValue(t).set(n) : e.addValue(t, of(n));
}
function tne(e) {
  return Mv(e) ? e[e.length - 1] || 0 : e;
}
function nne(e, t) {
  const n = xs(e, t);
  let { transitionEnd: r = {}, transition: i = {}, ...s } = n || {};
  s = { ...s, ...r };
  for (const l in s) {
    const u = tne(s[l]);
    ene(e, l, u);
  }
}
function rne(e) {
  return !!(Ft(e) && e.add);
}
function ine(e, t) {
  const n = e.getValue("willChange");
  if (rne(n))
    return n.add(t);
  if (!n && Fr.WillChange) {
    const r = new Fr.WillChange("auto");
    e.addValue("willChange", r), r.add(t);
  }
}
function one(e) {
  return e.props[M2];
}
const sne = (e) => e !== null;
function ane(e, { repeat: t, repeatType: n = "loop" }, r) {
  const i = e.filter(sne), s = t && n !== "loop" && t % 2 === 1 ? 0 : i.length - 1;
  return i[s];
}
const lne = {
  type: "spring",
  stiffness: 500,
  damping: 25,
  restSpeed: 10
}, une = (e) => ({
  type: "spring",
  stiffness: 550,
  damping: e === 0 ? 2 * Math.sqrt(550) : 30,
  restSpeed: 10
}), cne = {
  type: "keyframes",
  duration: 0.8
}, dne = {
  type: "keyframes",
  ease: [0.25, 0.1, 0.35, 1],
  duration: 0.3
}, fne = (e, { keyframes: t }) => t.length > 2 ? cne : Ca.has(e) ? e.startsWith("scale") ? une(t[1]) : lne : dne;
function hne({ when: e, delay: t, delayChildren: n, staggerChildren: r, staggerDirection: i, repeat: s, repeatType: l, repeatDelay: u, from: d, elapsed: h, ...f }) {
  return !!Object.keys(f).length;
}
const pne = (e, t, n, r = {}, i, s) => (l) => {
  const u = m2(r, e) || {}, d = u.delay || r.delay || 0;
  let { elapsed: h = 0 } = r;
  h = h - /* @__PURE__ */ Ir(d);
  const f = {
    keyframes: Array.isArray(n) ? n : [null, n],
    ease: "easeOut",
    velocity: t.getVelocity(),
    ...u,
    delay: -h,
    onUpdate: (g) => {
      t.set(g), u.onUpdate && u.onUpdate(g);
    },
    onComplete: () => {
      l(), u.onComplete && u.onComplete();
    },
    name: e,
    motionValue: t,
    element: s ? void 0 : i
  };
  hne(u) || Object.assign(f, fne(e, f)), f.duration && (f.duration = /* @__PURE__ */ Ir(f.duration)), f.repeatDelay && (f.repeatDelay = /* @__PURE__ */ Ir(f.repeatDelay)), f.from !== void 0 && (f.keyframes[0] = f.from);
  let m = !1;
  if ((f.type === !1 || f.duration === 0 && !f.repeatDelay) && (Iv(f), f.delay === 0 && (m = !0)), (Fr.instantAnimations || Fr.skipAnimations) && (m = !0, Iv(f), f.delay = 0), f.allowFlatten = !u.type && !u.ease, m && !s && t.get() !== void 0) {
    const g = ane(f.keyframes, u);
    if (g !== void 0) {
      Gn.update(() => {
        f.onUpdate(g), f.onComplete();
      });
      return;
    }
  }
  return u.isSync ? new Zw(f) : new Pee(f);
};
function mne({ protectedKeys: e, needsAnimating: t }, n) {
  const r = e.hasOwnProperty(n) && t[n] !== !0;
  return t[n] = !1, r;
}
function U2(e, t, { delay: n = 0, transitionOverride: r, type: i } = {}) {
  let { transition: s = e.getDefaultTransition(), transitionEnd: l, ...u } = t;
  r && (s = r);
  const d = [], h = i && e.animationState && e.animationState.getState()[i];
  for (const f in u) {
    const m = e.getValue(f, e.latestValues[f] ?? null), g = u[f];
    if (g === void 0 || h && mne(h, f))
      continue;
    const w = {
      delay: n,
      ...m2(s || {}, f)
    }, E = m.get();
    if (E !== void 0 && !m.isAnimating && !Array.isArray(g) && g === E && !w.velocity)
      continue;
    let b = !1;
    if (window.MotionHandoffAnimation) {
      const x = one(e);
      if (x) {
        const R = window.MotionHandoffAnimation(x, f, Gn);
        R !== null && (w.startTime = R, b = !0);
      }
    }
    ine(e, f), m.start(pne(f, m, g, e.shouldReduceMotion && g2.has(f) ? { type: !1 } : w, e, b));
    const A = m.animation;
    A && d.push(A);
  }
  return l && Promise.all(d).then(() => {
    Gn.update(() => {
      l && nne(e, l);
    });
  }), d;
}
function W2(e, t, n, r = 0, i = 1) {
  const s = Array.from(e).sort((d, h) => d.sortNodePosition(h)).indexOf(t), l = e.size, u = (l - 1) * r;
  return typeof n == "function" ? n(s, l) : i === 1 ? s * r : u - s * r;
}
function Ov(e, t, n = {}) {
  var r;
  const i = xs(e, t, n.type === "exit" ? (r = e.presenceContext) == null ? void 0 : r.custom : void 0);
  let { transition: s = e.getDefaultTransition() || {} } = i || {};
  n.transitionOverride && (s = n.transitionOverride);
  const l = i ? () => Promise.all(U2(e, i, n)) : () => Promise.resolve(), u = e.variantChildren && e.variantChildren.size ? (h = 0) => {
    const { delayChildren: f = 0, staggerChildren: m, staggerDirection: g } = s;
    return gne(e, t, h, f, m, g, n);
  } : () => Promise.resolve(), { when: d } = s;
  if (d) {
    const [h, f] = d === "beforeChildren" ? [l, u] : [u, l];
    return h().then(() => f());
  } else
    return Promise.all([l(), u(n.delay)]);
}
function gne(e, t, n = 0, r = 0, i = 0, s = 1, l) {
  const u = [];
  for (const d of e.variantChildren)
    d.notify("AnimationStart", t), u.push(Ov(d, t, {
      ...l,
      delay: n + (typeof r == "function" ? 0 : r) + W2(e.variantChildren, d, r, i, s)
    }).then(() => d.notify("AnimationComplete", t)));
  return Promise.all(u);
}
function vne(e, t, n = {}) {
  e.notify("AnimationStart", t);
  let r;
  if (Array.isArray(t)) {
    const i = t.map((s) => Ov(e, s, n));
    r = Promise.all(i);
  } else if (typeof t == "string")
    r = Ov(e, t, n);
  else {
    const i = typeof t == "function" ? xs(e, t, n.custom) : t;
    r = Promise.all(U2(e, i, n));
  }
  return r.then(() => {
    e.notify("AnimationComplete", t);
  });
}
function z2(e, t) {
  if (!Array.isArray(t))
    return !1;
  const n = t.length;
  if (n !== e.length)
    return !1;
  for (let r = 0; r < n; r++)
    if (t[r] !== e[r])
      return !1;
  return !0;
}
const yne = nb.length;
function H2(e) {
  if (!e)
    return;
  if (!e.isControllingVariants) {
    const n = e.parent ? H2(e.parent) || {} : {};
    return e.props.initial !== void 0 && (n.initial = e.props.initial), n;
  }
  const t = {};
  for (let n = 0; n < yne; n++) {
    const r = nb[n], i = e.props[r];
    (nu(i) || i === !1) && (t[r] = i);
  }
  return t;
}
const wne = [...tb].reverse(), bne = tb.length;
function Cne(e) {
  return (t) => Promise.all(t.map(({ animation: n, options: r }) => vne(e, n, r)));
}
function Ene(e) {
  let t = Cne(e), n = qS(), r = !0;
  const i = (d) => (h, f) => {
    var m;
    const g = xs(e, f, d === "exit" ? (m = e.presenceContext) == null ? void 0 : m.custom : void 0);
    if (g) {
      const { transition: w, transitionEnd: E, ...b } = g;
      h = { ...h, ...b, ...E };
    }
    return h;
  };
  function s(d) {
    t = d(e);
  }
  function l(d) {
    const { props: h } = e, f = H2(e.parent) || {}, m = [], g = /* @__PURE__ */ new Set();
    let w = {}, E = 1 / 0;
    for (let A = 0; A < bne; A++) {
      const x = wne[A], R = n[x], _ = h[x] !== void 0 ? h[x] : f[x], L = nu(_), V = x === d ? R.isActive : null;
      V === !1 && (E = A);
      let O = _ === f[x] && _ !== h[x] && L;
      if (O && r && e.manuallyAnimateOnMount && (O = !1), R.protectedKeys = { ...w }, // If it isn't active and hasn't *just* been set as inactive
      !R.isActive && V === null || // If we didn't and don't have any defined prop for this animation type
      !_ && !R.prevProp || // Or if the prop doesn't define an animation
      Kf(_) || typeof _ == "boolean")
        continue;
      const D = Ane(R.prevProp, _);
      let B = D || // If we're making this variant active, we want to always make it active
      x === d && R.isActive && !O && L || // If we removed a higher-priority variant (i is in reverse order)
      A > E && L, H = !1;
      const J = Array.isArray(_) ? _ : [_];
      let ce = J.reduce(i(x), {});
      V === !1 && (ce = {});
      const { prevResolvedValues: fe = {} } = R, de = {
        ...fe,
        ...ce
      }, he = (Y) => {
        B = !0, g.has(Y) && (H = !0, g.delete(Y)), R.needsAnimating[Y] = !0;
        const te = e.getValue(Y);
        te && (te.liveStyle = !1);
      };
      for (const Y in de) {
        const te = ce[Y], S = fe[Y];
        if (w.hasOwnProperty(Y))
          continue;
        let T = !1;
        Mv(te) && Mv(S) ? T = !z2(te, S) : T = te !== S, T ? te != null ? he(Y) : g.add(Y) : te !== void 0 && g.has(Y) ? he(Y) : R.protectedKeys[Y] = !0;
      }
      R.prevProp = _, R.prevResolvedValues = ce, R.isActive && (w = { ...w, ...ce }), r && e.blockInitialAnimation && (B = !1);
      const le = O && D;
      B && (!le || H) && m.push(...J.map((Y) => {
        const te = { type: x };
        if (typeof Y == "string" && r && !le && e.manuallyAnimateOnMount && e.parent) {
          const { parent: S } = e, T = xs(S, Y);
          if (S.enteringChildren && T) {
            const { delayChildren: P } = T.transition || {};
            te.delay = W2(S.enteringChildren, e, P);
          }
        }
        return {
          animation: Y,
          options: te
        };
      }));
    }
    if (g.size) {
      const A = {};
      if (typeof h.initial != "boolean") {
        const x = xs(e, Array.isArray(h.initial) ? h.initial[0] : h.initial);
        x && x.transition && (A.transition = x.transition);
      }
      g.forEach((x) => {
        const R = e.getBaseTarget(x), _ = e.getValue(x);
        _ && (_.liveStyle = !0), A[x] = R ?? null;
      }), m.push({ animation: A });
    }
    let b = !!m.length;
    return r && (h.initial === !1 || h.initial === h.animate) && !e.manuallyAnimateOnMount && (b = !1), r = !1, b ? t(m) : Promise.resolve();
  }
  function u(d, h) {
    var f;
    if (n[d].isActive === h)
      return Promise.resolve();
    (f = e.variantChildren) == null || f.forEach((g) => {
      var w;
      return (w = g.animationState) == null ? void 0 : w.setActive(d, h);
    }), n[d].isActive = h;
    const m = l(d);
    for (const g in n)
      n[g].protectedKeys = {};
    return m;
  }
  return {
    animateChanges: l,
    setActive: u,
    setAnimateFunction: s,
    getState: () => n,
    reset: () => {
      n = qS(), r = !0;
    }
  };
}
function Ane(e, t) {
  return typeof t == "string" ? t !== e : Array.isArray(t) ? !z2(t, e) : !1;
}
function Ui(e = !1) {
  return {
    isActive: e,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function qS() {
  return {
    animate: Ui(!0),
    whileInView: Ui(),
    whileHover: Ui(),
    whileTap: Ui(),
    whileDrag: Ui(),
    whileFocus: Ui(),
    exit: Ui()
  };
}
class Ea {
  constructor(t) {
    this.isMounted = !1, this.node = t;
  }
  update() {
  }
}
class xne extends Ea {
  /**
   * We dynamically generate the AnimationState manager as it contains a reference
   * to the underlying animation library. We only want to load that if we load this,
   * so people can optionally code split it out using the `m` component.
   */
  constructor(t) {
    super(t), t.animationState || (t.animationState = Ene(t));
  }
  updateAnimationControlsSubscription() {
    const { animate: t } = this.node.getProps();
    Kf(t) && (this.unmountControls = t.subscribe(this.node));
  }
  /**
   * Subscribe any provided AnimationControls to the component's VisualElement
   */
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate: t } = this.node.getProps(), { animate: n } = this.node.prevProps || {};
    t !== n && this.updateAnimationControlsSubscription();
  }
  unmount() {
    var t;
    this.node.animationState.reset(), (t = this.unmountControls) == null || t.call(this);
  }
}
let Sne = 0;
class kne extends Ea {
  constructor() {
    super(...arguments), this.id = Sne++;
  }
  update() {
    if (!this.node.presenceContext)
      return;
    const { isPresent: t, onExitComplete: n } = this.node.presenceContext, { isPresent: r } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || t === r)
      return;
    const i = this.node.animationState.setActive("exit", !t);
    n && !t && i.then(() => {
      n(this.id);
    });
  }
  mount() {
    const { register: t, onExitComplete: n } = this.node.presenceContext || {};
    n && n(this.id), t && (this.unmount = t(this.id));
  }
  unmount() {
  }
}
const Rne = {
  animation: {
    Feature: xne
  },
  exit: {
    Feature: kne
  }
};
function XS(e, t, n, r = { passive: !0 }) {
  return e.addEventListener(t, n, r), () => e.removeEventListener(t, n);
}
function K2(e) {
  return {
    point: {
      x: e.pageX,
      y: e.pageY
    }
  };
}
function ZS(e, t, n) {
  const { props: r } = e;
  e.animationState && r.whileHover && e.animationState.setActive("whileHover", n === "Start");
  const i = "onHover" + n, s = r[i];
  s && Gn.postRender(() => s(t, K2(t)));
}
class Tne extends Ea {
  mount() {
    const { current: t } = this.node;
    t && (this.unmount = ete(t, (n, r) => (ZS(this.node, r, "Start"), (i) => ZS(this.node, i, "End"))));
  }
  unmount() {
  }
}
class $ne extends Ea {
  constructor() {
    super(...arguments), this.isActive = !1;
  }
  onFocus() {
    let t = !1;
    try {
      t = this.node.current.matches(":focus-visible");
    } catch {
      t = !0;
    }
    !t || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0);
  }
  onBlur() {
    !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1);
  }
  mount() {
    this.unmount = Wf(XS(this.node.current, "focus", () => this.onFocus()), XS(this.node.current, "blur", () => this.onBlur()));
  }
  unmount() {
  }
}
function QS(e, t, n) {
  const { props: r } = e;
  if (e.current instanceof HTMLButtonElement && e.current.disabled)
    return;
  e.animationState && r.whileTap && e.animationState.setActive("whileTap", n === "Start");
  const i = "onTap" + (n === "End" ? "" : n), s = r[i];
  s && Gn.postRender(() => s(t, K2(t)));
}
class Vne extends Ea {
  mount() {
    const { current: t } = this.node;
    t && (this.unmount = ote(t, (n, r) => (QS(this.node, r, "Start"), (i, { success: s }) => QS(this.node, i, s ? "End" : "Cancel")), { useGlobalTarget: this.node.props.globalTapTarget }));
  }
  unmount() {
  }
}
const Bv = /* @__PURE__ */ new WeakMap(), Hm = /* @__PURE__ */ new WeakMap(), _ne = (e) => {
  const t = Bv.get(e.target);
  t && t(e);
}, Ine = (e) => {
  e.forEach(_ne);
};
function Lne({ root: e, ...t }) {
  const n = e || document;
  Hm.has(n) || Hm.set(n, {});
  const r = Hm.get(n), i = JSON.stringify(t);
  return r[i] || (r[i] = new IntersectionObserver(Ine, { root: e, ...t })), r[i];
}
function Pne(e, t, n) {
  const r = Lne(t);
  return Bv.set(e, n), r.observe(e), () => {
    Bv.delete(e), r.unobserve(e);
  };
}
const Mne = {
  some: 0,
  all: 1
};
class One extends Ea {
  constructor() {
    super(...arguments), this.hasEnteredView = !1, this.isInView = !1;
  }
  startObserver() {
    this.unmount();
    const { viewport: t = {} } = this.node.getProps(), { root: n, margin: r, amount: i = "some", once: s } = t, l = {
      root: n ? n.current : void 0,
      rootMargin: r,
      threshold: typeof i == "number" ? i : Mne[i]
    }, u = (d) => {
      const { isIntersecting: h } = d;
      if (this.isInView === h || (this.isInView = h, s && !h && this.hasEnteredView))
        return;
      h && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", h);
      const { onViewportEnter: f, onViewportLeave: m } = this.node.getProps(), g = h ? f : m;
      g && g(d);
    };
    return Pne(this.node.current, l, u);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver > "u")
      return;
    const { props: t, prevProps: n } = this.node;
    ["amount", "margin", "root"].some(Bne(t, n)) && this.startObserver();
  }
  unmount() {
  }
}
function Bne({ viewport: e = {} }, { viewport: t = {} } = {}) {
  return (n) => e[n] !== t[n];
}
const Nne = {
  inView: {
    Feature: One
  },
  tap: {
    Feature: Vne
  },
  focus: {
    Feature: $ne
  },
  hover: {
    Feature: Tne
  }
}, Dne = {
  renderer: Jte,
  ...Rne,
  ...Nne
};
function G2(e, t) {
  return Nte(e, t);
}
const jne = /* @__PURE__ */ G2("div"), ub = /* @__PURE__ */ G2("span"), Fne = ({
  icon: e = RG,
  "aria-hidden": t = !0,
  ...n
}) => {
  const r = j.useContext(Pt);
  return /* @__PURE__ */ I.jsx(
    Ut.Icon,
    {
      as: ub,
      animate: { rotate: r.open ? 180 : 0 },
      transition: { duration: 0.15, type: "spring", bounce: 0 },
      icon: e,
      "aria-hidden": t,
      ...n
    }
  );
}, Une = ({
  tooltipProps: e,
  ...t
}) => {
  const n = j.useContext(Pt), r = () => {
    var i, s;
    if (_r(n.value)) {
      const l = n.onValueChange;
      l == null || l([]);
    }
    if (Eo(n.value)) {
      const l = n.onValueChange;
      l == null || l(void 0);
    }
    (s = (i = n.triggerRef) == null ? void 0 : i.current) == null || s.focus();
  };
  return j.useMemo(() => {
    var i;
    if (Eo(n.value))
      return n.clearable && n.value;
    if (_r(n.value))
      return n.clearable && ((i = n.value) == null ? void 0 : i.length) > 0;
  }, [n.clearable, n.value]) ? /* @__PURE__ */ I.jsx(y0, { label: "Clear field", ...e, children: /* @__PURE__ */ I.jsx(
    Ut,
    {
      type: "button",
      icon: { icon: aw, alt: "Clear field" },
      size: "0",
      variant: "ghost",
      onClick: (i) => {
        n.value && (i.stopPropagation(), r());
      },
      onKeyDown: (i) => {
        (i.key === "Enter" || i.key === " ") && (i.stopPropagation(), r());
      },
      "data-tgph-combobox-clear": !0,
      style: {
        // Remove margin to make the clear button flush
        // with the trigger button
        marginTop: "calc(-1 * var(--tgph-spacing-1)",
        marginBottom: "calc(-1 * var(--tgph-spacing-1)"
      },
      ...t
    }
  ) }) : null;
}, Y2 = ({
  children: e,
  ...t
}) => {
  const n = j.useContext(Pt), r = j.useMemo(() => {
    var i;
    if (!Eo(n.value)) return;
    const s = wv(
      n.value,
      n.options,
      n.legacyBehavior
    ), l = (s == null ? void 0 : s.label) || (s == null ? void 0 : s.value) || n.placeholder;
    return n.legacyBehavior && ((i = n == null ? void 0 : n.value) == null ? void 0 : i.label) || l;
  }, [
    n.value,
    n.options,
    n.legacyBehavior,
    n.placeholder
  ]);
  return /* @__PURE__ */ I.jsx(IL, { children: /* @__PURE__ */ I.jsx(
    Ut.Text,
    {
      color: n.value ? "default" : "gray",
      textOverflow: "ellipsis",
      overflow: "hidden",
      ...t,
      children: e || r
    }
  ) });
}, Nv = ({
  children: e,
  ...t
}) => {
  const n = j.useContext(Pt);
  return /* @__PURE__ */ I.jsx(IL, { children: /* @__PURE__ */ I.jsx(
    Ut.Text,
    {
      color: "gray",
      textOverflow: "ellipsis",
      overflow: "hidden",
      ...t,
      children: e || n.placeholder
    }
  ) });
}, q2 = ({ children: e }) => {
  const t = j.useContext(Pt);
  if (!_r(t.value)) return null;
  const n = t.layout || "truncate", r = (t.value.length - 2).toString().split("");
  return /* @__PURE__ */ I.jsxs(
    Us,
    {
      gap: "0_5",
      w: "full",
      wrap: n === "wrap" ? "wrap" : "nowrap",
      align: "center",
      style: {
        position: "relative",
        flexGrow: 1
      },
      children: [
        e,
        n === "truncate" && t.value.length > 2 && /* @__PURE__ */ I.jsx(
          Us,
          {
            as: jne,
            initial: { opacity: 0 },
            animate: { opacity: 1 },
            exit: { opacity: 0 },
            transition: { duration: 0.1, type: "spring", bounce: 0 },
            h: "full",
            pr: "1",
            pl: "8",
            align: "center",
            "aria-label": `${t.value.length - 2} more selected`,
            position: "absolute",
            right: "0",
            style: {
              backgroundImage: "linear-gradient(to left, var(--tgph-surface-1) 0 60%, transparent 90% 100%)"
            },
            children: /* @__PURE__ */ I.jsxs(qn, { as: "span", size: "1", style: { whiteSpace: "nowrap" }, children: [
              "+",
              r.map((i) => /* @__PURE__ */ I.jsx(
                lw,
                {
                  as: ub,
                  initial: { opacity: 0 },
                  animate: { opacity: 1 },
                  exit: { opacity: 0 },
                  transition: { duration: 0.1, type: "spring", bounce: 0 },
                  w: "2",
                  display: "inline-block",
                  children: i
                },
                i
              )),
              " ",
              "more"
            ] })
          }
        )
      ]
    }
  );
}, cb = j.createContext({
  value: ""
}), Wne = ({
  value: e,
  children: t,
  ...n
}) => /* @__PURE__ */ I.jsx(cb.Provider, { value: { value: e }, children: /* @__PURE__ */ I.jsx(
  z0.Root,
  {
    as: ub,
    initial: { opacity: 0, scale: 0.5 },
    animate: { opacity: 1, scale: 1 },
    exit: { opacity: 0, scale: 0.5 },
    transition: { duration: 0.1, type: "spring", bounce: 0 },
    size: "1",
    maxH: "5",
    rounded: "1",
    layout: "position",
    ...n,
    children: t
  }
) }), zne = ({
  children: e,
  ...t
}) => {
  const n = j.useContext(Pt), r = j.useContext(cb), i = j.useMemo(() => {
    const s = n.options.find(
      (u) => u.value === r.value
    );
    if (s) return s.label || s.value;
    if (!n.value) return;
    const l = n.value.find(
      (u) => yi(u, n.legacyBehavior) === r.value
    );
    if (l)
      return l;
  }, [
    n.options,
    n.value,
    r.value,
    n.legacyBehavior
  ]);
  return /* @__PURE__ */ I.jsx(z0.Text, { ...t, children: e || i });
}, Hne = ({
  children: e,
  ...t
}) => {
  const n = j.useContext(Pt), r = j.useContext(cb);
  return /* @__PURE__ */ I.jsx(
    z0.Button,
    {
      icon: { icon: aw, alt: `Remove ${r.value}` },
      height: "full",
      onClick: (i) => {
        if (!n.onValueChange) return;
        const s = n.onValueChange, l = n.value.filter((u) => yi(u, n.legacyBehavior) !== r.value);
        s == null || s(l), i.stopPropagation(), i.preventDefault();
      },
      ...t,
      children: e
    }
  );
}, Kne = ({
  value: e,
  children: t,
  ...n
}) => /* @__PURE__ */ I.jsxs(Ol.Root, { value: e, ...n, children: [
  /* @__PURE__ */ I.jsx(Ol.Text, { children: t }),
  /* @__PURE__ */ I.jsx(Ol.Button, {})
] }), Gne = (e) => /* @__PURE__ */ I.jsx(Us, { align: "center", gap: "1", ...e }), Yne = () => {
  const e = j.useContext(Pt);
  if (e.value && _r(e.value)) {
    const t = e.layout || "truncate";
    return e.value.length === 0 ? /* @__PURE__ */ I.jsx(Nv, {}) : /* @__PURE__ */ I.jsx(lte, { features: Dne, children: /* @__PURE__ */ I.jsx(q2, { children: e.value.map((n, r) => {
      const i = yi(n, e.legacyBehavior);
      if (i && (t === "truncate" && r <= 1 || t === "wrap"))
        return /* @__PURE__ */ I.jsx(Gs, { children: /* @__PURE__ */ I.jsx(Ol.Default, { value: i }) }, i);
    }) }) });
  }
  if (e && Eo(e.value))
    return e.value ? /* @__PURE__ */ I.jsx(Y2, {}) : /* @__PURE__ */ I.jsx(Nv, {});
}, Ol = {
  Root: Wne,
  Text: zne,
  Button: Hne,
  Default: Kne
}, Al = {
  TriggerIndicator: Fne,
  TriggerClear: Une,
  TriggerText: Y2,
  TriggerPlaceholder: Nv,
  TriggerTagsContainer: q2,
  TriggerActionsContainer: Gne,
  TriggerTag: Ol,
  TriggerValue: Yne
}, qne = ["ArrowDown", "PageUp", "Home"], Xne = ["ArrowUp", "PageDown", "End"], X2 = ["Enter", " "], Pt = j.createContext({
  value: void 0,
  onValueChange: () => {
  },
  contentId: "",
  triggerId: "",
  open: !1,
  setOpen: () => {
  },
  onOpenToggle: () => {
  },
  clearable: !1,
  disabled: !1,
  options: [],
  legacyBehavior: !1
}), Zne = ({
  modal: e = !0,
  closeOnSelect: t = !0,
  clearable: n = !1,
  disabled: r = !1,
  legacyBehavior: i = !1,
  open: s,
  onOpenChange: l,
  defaultOpen: u,
  value: d,
  onValueChange: h,
  errored: f,
  placeholder: m,
  layout: g,
  children: w,
  ...E
}) => {
  const b = j.useId(), A = j.useId(), x = j.useRef(null), R = j.useRef(null), _ = j.useRef(null), L = j.useMemo(() => eJ(w), [w]), [V, O] = j.useState(""), [D = !1, B] = Zs({
    prop: s,
    defaultProp: u ?? !1,
    onChange: l
  }), H = j.useCallback(() => {
    B((J) => !J);
  }, [B]);
  return j.useEffect(() => {
    D || O("");
  }, [D]), /* @__PURE__ */ I.jsx(
    Pt.Provider,
    {
      value: {
        contentId: b,
        triggerId: A,
        value: d,
        // Need to cast this to avoid type errors
        // because the type of onValueChange is not
        // consistent with the value type
        onValueChange: h,
        placeholder: m,
        open: D,
        setOpen: B,
        onOpenToggle: H,
        closeOnSelect: t,
        clearable: n,
        disabled: r,
        searchQuery: V,
        setSearchQuery: O,
        triggerRef: x,
        searchRef: R,
        contentRef: _,
        errored: f,
        layout: g,
        options: L,
        legacyBehavior: i
      },
      children: /* @__PURE__ */ I.jsx(
        ku.Root,
        {
          open: D,
          onOpenChange: B,
          modal: e,
          ...E,
          children: w
        }
      )
    }
  );
}, Qne = ({
  size: e = "1",
  children: t,
  ...n
}) => {
  const r = j.useContext(Pt), i = _r(r.value) && r.value.length > 0, s = j.useMemo(() => {
    if (r.value) {
      if (Eo(r.value))
        return wv(
          r.value,
          r.options,
          r.legacyBehavior
        );
      if (_r(r.value))
        return r.value.map(
          (u) => wv(u, r.options, r.legacyBehavior)
        );
    }
  }, [r.value, r.options, r.legacyBehavior]), l = j.useCallback(() => s ? Eo(s) ? (s == null ? void 0 : s.label) || (s == null ? void 0 : s.value) || r.placeholder : _r(s) && s.map((u) => (u == null ? void 0 : u.label) || (u == null ? void 0 : u.value)).join(", ") || r.placeholder : r.placeholder, [s, r.placeholder]);
  return /* @__PURE__ */ I.jsx(
    ku.Trigger,
    {
      ...n,
      asChild: !0,
      onClick: (u) => {
        var d, h;
        u.preventDefault(), r.onOpenToggle(), (h = (d = r.triggerRef) == null ? void 0 : d.current) == null || h.focus();
      },
      onKeyDown: (u) => {
        if (u.key === "Tab") {
          u.stopPropagation();
          return;
        }
        if (X2.includes(u.key)) {
          u.preventDefault();
          return;
        }
        if (u.key === "ArrowDown") {
          u.stopPropagation(), u.preventDefault(), r.onOpenToggle();
          return;
        }
      },
      tgphRef: r.triggerRef,
      children: /* @__PURE__ */ I.jsx(
        Ut.Root,
        {
          id: r.triggerId,
          type: "button",
          bg: "surface-1",
          variant: "outline",
          align: "center",
          minH: JQ[e],
          h: "full",
          w: "full",
          py: "0_5",
          pr: "1_5",
          pl: i ? "0_5" : "1_5",
          size: e,
          color: r.errored ? "red" : "gray",
          justify: "space-between",
          role: "combobox",
          "aria-label": l(),
          "aria-controls": r.contentId,
          "aria-expanded": r.open,
          "aria-haspopup": "listbox",
          "data-tgph-combobox-trigger": !0,
          "data-tgph-combobox-trigger-open": r.open,
          disabled: r.disabled,
          ...n,
          children: t ? typeof t == "function" ? t({ value: s }) : t : /* @__PURE__ */ I.jsxs(I.Fragment, { children: [
            /* @__PURE__ */ I.jsx(Al.TriggerValue, {}),
            /* @__PURE__ */ I.jsxs(Al.TriggerActionsContainer, { children: [
              /* @__PURE__ */ I.jsx(Al.TriggerClear, {}),
              /* @__PURE__ */ I.jsx(Al.TriggerIndicator, {})
            ] })
          ] })
        }
      )
    }
  );
}, Jne = ({
  style: e,
  children: t,
  tgphRef: n,
  ...r
}) => {
  const i = j.useContext(Pt), s = j.useRef(!1), l = sw(n, i.contentRef), u = j.useRef(null), [d, h] = j.useState(0), [f, m] = j.useState(!1), g = j.useCallback(
    (w) => {
      const E = w == null ? void 0 : w.getBoundingClientRect();
      E && h(E.height), f || m(!0);
    },
    [f]
  );
  return j.useEffect(() => {
    const w = new ResizeObserver((E) => {
      for (const b of E) {
        const A = b.target;
        g(A);
      }
    });
    return u.current && f && w.observe(u.current), () => w.disconnect();
  }, [f, g]), j.useEffect(() => {
    f === !0 && i.open === !1 && m(!1);
  }, [i.open, f]), j.useEffect(() => {
    let w;
    return i.open && (w = setTimeout(() => {
      g(u.current);
    }, 10)), () => w && clearTimeout(w);
  }, [i.open, g]), /* @__PURE__ */ I.jsx(M5, { asChild: !0, children: /* @__PURE__ */ I.jsx(
    fu,
    {
      onEscapeKeyDown: (w) => {
        i.open && (w.stopPropagation(), w.preventDefault(), i.setOpen(!1));
      },
      children: /* @__PURE__ */ I.jsx(
        ku.Content,
        {
          className: "tgph",
          mt: "1",
          onCloseAutoFocus: (w) => {
            var E, b;
            s.current || (b = (E = i.triggerRef) == null ? void 0 : E.current) == null || b.focus(), s.current = !1, w.preventDefault();
          },
          bg: "surface-1",
          style: {
            width: "var(--tgph-combobox-trigger-width)",
            transition: "min-height 200ms ease-in-out",
            minHeight: d ? `${d}px` : "0",
            ...e,
            "--tgph-combobox-content-transform-origin": "var(--radix-popper-transform-origin)",
            "--tgph-combobox-content-available-width": "var(--radix-popper-available-width)",
            "--tgph-combobox-content-available-height": "calc(var(--radix-popper-available-height) - var(--tgph-spacing-8))",
            "--tgph-combobox-trigger-width": "var(--radix-popper-anchor-width)",
            "--tgph-combobox-trigger-height": "var(--radix-popper-anchor-height)"
          },
          ...r,
          tgphRef: l,
          "data-tgph-combobox-content": !0,
          "data-tgph-combobox-content-open": i.open,
          role: void 0,
          "aria-orientation": void 0,
          onKeyDown: (w) => {
            var E, b, A, x;
            w.stopPropagation();
            const R = (b = (E = i.contentRef) == null ? void 0 : E.current) == null ? void 0 : b.querySelectorAll(
              "[data-tgph-combobox-option]"
            );
            document.activeElement === (R == null ? void 0 : R[0]) && Xne.includes(w.key) && ((x = (A = i.searchRef) == null ? void 0 : A.current) == null || x.focus());
          },
          children: /* @__PURE__ */ I.jsx(Us, { direction: "column", gap: "1", tgphRef: u, children: t })
        }
      )
    }
  ) });
}, ere = ({ ...e }) => {
  const t = j.useContext(Pt);
  return /* @__PURE__ */ I.jsx(
    Us,
    {
      id: t.contentId,
      direction: "column",
      gap: "1",
      style: {
        overflowY: "auto",
        // maxHeight defaults to available height - padding from edge of screen
        "--max-height": e.maxHeight ? void 0 : "calc(var(--tgph-combobox-content-available-height) - var(--tgph-spacing-12))"
      },
      role: "listbox",
      ...e
    }
  );
}, Z2 = ({
  value: e,
  label: t,
  selected: n,
  onSelect: r,
  children: i,
  ...s
}) => {
  const l = j.useContext(Pt), [u, d] = j.useState(!1), h = l.value, f = !l.searchQuery || tJ({
    children: t || i,
    value: e,
    searchQuery: l.searchQuery
  }), m = _r(h) ? h.some(
    (w) => yi(w, l.legacyBehavior) === e
  ) : yi(h, l.legacyBehavior) === e, g = (w) => {
    var E, b;
    w.stopPropagation();
    const A = w;
    if (!(A.key && !X2.includes(A.key))) {
      if (w.preventDefault(), l.closeOnSelect === !0 && l.setOpen(!1), r)
        return r(w);
      if (Eo(h)) {
        const x = l.onValueChange;
        l.legacyBehavior === !0 ? x == null || x({ value: e, label: t }) : x == null || x(e);
      } else if (_r(h)) {
        const x = l.onValueChange, R = l.value, _ = m ? R.filter(
          (L) => yi(L, l.legacyBehavior) !== e
        ) : [
          ...R,
          // TODO: Remove this once { value, label } option is deprecated
          l.legacyBehavior === !0 ? { value: e, label: t } : e
        ];
        x == null || x(_);
      }
      (b = (E = l.triggerRef) == null ? void 0 : E.current) == null || b.focus();
    }
  };
  if (f)
    return /* @__PURE__ */ I.jsx(
      ku.Button,
      {
        type: "button",
        onSelect: g,
        onKeyDown: g,
        selected: n === null ? null : n ?? m,
        onFocus: () => d(!0),
        onBlur: () => d(!1),
        role: "option",
        "aria-selected": m ? "true" : "false",
        "data-tgph-combobox-option": !0,
        "data-tgph-combobox-option-focused": u,
        "data-tgph-combobox-option-value": e,
        "data-tgph-combobox-option-label": t,
        ...s,
        children: t || i || e
      }
    );
}, tre = ({
  label: e = "Search",
  placeholder: t = "Search",
  tgphRef: n,
  value: r,
  onValueChange: i,
  ...s
}) => {
  var l;
  const u = j.useId(), d = j.useContext(Pt), h = sw(n, d.searchRef), f = r ?? d.searchQuery, m = i ?? d.setSearchQuery;
  return j.useEffect(() => {
    var g;
    const w = (b) => {
      var A, x;
      qne.includes(b.key) && ((x = (A = d.contentRef) == null ? void 0 : A.current) == null || x.focus({ preventScroll: !0 })), b.key === "Escape" && d.setOpen(!1), b.stopPropagation();
    }, E = (g = d.searchRef) == null ? void 0 : g.current;
    if (E)
      return E.addEventListener("keydown", w), () => {
        E.removeEventListener("keydown", w);
      };
  }, [d]), /* @__PURE__ */ I.jsxs(lw, { borderBottom: "px", px: "1", pb: "1", children: [
    /* @__PURE__ */ I.jsx(yG, { children: /* @__PURE__ */ I.jsx(qn, { as: "label", htmlFor: u, children: e }) }),
    /* @__PURE__ */ I.jsx(
      DG,
      {
        id: u,
        variant: "ghost",
        placeholder: t,
        value: f,
        onChange: (g) => {
          m(g.target.value);
        },
        LeadingComponent: /* @__PURE__ */ I.jsx(W_, { icon: U_, alt: "Search Icon" }),
        TrailingComponent: d != null && d.searchQuery && ((l = d == null ? void 0 : d.searchQuery) == null ? void 0 : l.length) > 0 ? /* @__PURE__ */ I.jsx(
          Ut,
          {
            variant: "ghost",
            color: "gray",
            icon: { icon: aw, alt: "Clear Search Query" },
            onClick: () => {
              var g;
              return (g = d.setSearchQuery) == null ? void 0 : g.call(d, "");
            }
          }
        ) : null,
        autoFocus: !0,
        "data-tgph-combobox-search": !0,
        "aria-controls": d.contentId,
        ...s,
        tgphRef: h
      }
    )
  ] });
}, nre = ({
  icon: e = { icon: U_, alt: "Search Icon" },
  message: t = "No results found",
  children: n,
  ...r
}) => {
  const i = j.useContext(Pt), [s, l] = j.useState(!1);
  if (j.useEffect(() => {
    var u, d;
    const h = (d = (u = i.contentRef) == null ? void 0 : u.current) == null ? void 0 : d.querySelectorAll(
      "[data-tgph-combobox-option]"
    );
    (h == null ? void 0 : h.length) === 0 ? l(!0) : l(!1);
  }, [i.searchQuery, i.contentRef, n]), s)
    return /* @__PURE__ */ I.jsxs(
      Us,
      {
        gap: "1",
        align: "center",
        justify: "center",
        w: "full",
        my: "8",
        "data-tgph-combobox-empty": !0,
        ...r,
        children: [
          e === null ? /* @__PURE__ */ I.jsx(I.Fragment, {}) : /* @__PURE__ */ I.jsx(W_, { ...e }),
          t === null ? /* @__PURE__ */ I.jsx(I.Fragment, {}) : /* @__PURE__ */ I.jsx(qn, { as: "span", children: t })
        ]
      }
    );
}, rre = ({
  leadingText: e = "Create",
  values: t,
  onCreate: n,
  selected: r = null,
  legacyBehavior: i = !1,
  ...s
}) => {
  const l = j.useContext(Pt), u = j.useCallback(
    (d) => !t || (t == null ? void 0 : t.length) === 0 ? !1 : t.some(
      (h) => yi(h, i) === d
    ),
    [t, i]
  );
  if (l.searchQuery && !u(l.searchQuery))
    return /* @__PURE__ */ I.jsx(
      Z2,
      {
        leadingIcon: { icon: $G, "aria-hidden": !0 },
        mx: "1",
        value: l.searchQuery,
        label: `${e} "${l.searchQuery}"`,
        selected: r,
        onSelect: () => {
          var d;
          if (n && l.searchQuery) {
            const h = i === !0 ? { value: l.searchQuery } : l.searchQuery;
            n(h), (d = l.setSearchQuery) == null || d.call(l, "");
          }
        },
        ...s
      }
    );
}, ire = {};
Object.assign(ire, {
  Root: Zne,
  Trigger: Qne,
  Content: Jne,
  Options: ere,
  Option: Z2,
  Search: tre,
  Empty: nre,
  Create: rre,
  Primitives: Al
});
const ore = "_banner_mvmcb_1", sre = "_bannerInfo_mvmcb_25", are = "_bannerContent_mvmcb_35", lre = "_messageContainer_mvmcb_51", ure = "_message_mvmcb_51", cre = "_viewButton_mvmcb_83", dre = "_closeButton_mvmcb_115", ci = {
  banner: ore,
  bannerInfo: sre,
  bannerContent: are,
  messageContainer: lre,
  message: ure,
  viewButton: cre,
  closeButton: dre
}, fre = () => {
  var u, d, h;
  const { guide: e, step: t } = RD({ type: "notification-banner" }), n = (f) => {
    f != null && f.markAsArchived && f.markAsArchived();
  }, r = C.useRef(null), i = C.useMemo(
    () => {
      var f;
      return ((f = window.theme) == null ? void 0 : f.main) || getComputedStyle(document.body).getPropertyValue("--WLPrimary") || getComputedStyle(document.body).getPropertyValue("--fmgPrimary") || "#2d69ff";
    },
    []
  ), s = C.useMemo(() => Q2(i, 0.2), [i]), l = C.useCallback(() => {
    const f = r.current, m = (f == null ? void 0 : f.offsetHeight) || 0, g = document.querySelector(".c-navbar--fixed"), w = document.querySelector("#waspBody"), E = document.querySelector(".impersonating"), b = document.querySelector(".collaborating");
    w == null || w.style.setProperty("transition", "margin-top 0.5s"), w == null || w.style.setProperty("margin-top", `${m}px`), g == null || g.style.setProperty("top", `${m}px`), E == null || E.style.setProperty("top", `${m}px`), b == null || b.style.setProperty("top", `${m}px`);
  }, []);
  return C.useEffect(() => {
    const f = r.current, m = new ResizeObserver(l);
    return f ? m.observe(f) : l(), () => {
      f && m.unobserve(f);
    };
  }, [t, e, l]), /* @__PURE__ */ I.jsx(I.Fragment, { children: e && t && /* @__PURE__ */ I.jsx("div", { ref: r, className: Se([ci.banner, ci.bannerInfo]), children: /* @__PURE__ */ I.jsxs("div", { className: ci.bannerContent, children: [
    /* @__PURE__ */ I.jsxs("div", { className: ci.messageContainer, children: [
      /* @__PURE__ */ I.jsx("div", { className: ci.message, dangerouslySetInnerHTML: { __html: ((u = t == null ? void 0 : t.content) == null ? void 0 : u.message) || "" } }),
      /* @__PURE__ */ I.jsx("div", { className: ci.actions, children: ((d = t == null ? void 0 : t.content) == null ? void 0 : d.url) && ((h = t == null ? void 0 : t.content) == null ? void 0 : h.button_label) && /* @__PURE__ */ I.jsx(
        "a",
        {
          href: t.content.url,
          target: "_blank",
          rel: "noopener noreferrer",
          className: ci.viewButton,
          style: {
            backgroundColor: i,
            "--hover-color": s
          },
          children: t.content.button_label
        }
      ) })
    ] }),
    /* @__PURE__ */ I.jsx("button", { onClick: () => n(t), "aria-label": "Dismiss", className: ci.closeButton, children: "×" })
  ] }) }, e == null ? void 0 : e.id) });
}, hre = ({
  apiKey: e,
  platform: t,
  userToken: n,
  userGuidId: r,
  userName: i,
  userEmail: s,
  userId: l,
  partyId: u,
  reseller: d,
  program: h,
  guideChannelId: f
}) => /* @__PURE__ */ I.jsx(hD, { apiKey: e, user: { id: r, name: i, email: s, Platform: t, UserId: l, PartyId: u, Reseller: d, Program: h }, userToken: n, children: /* @__PURE__ */ I.jsx(SD, { channelId: f, readyToTarget: !0, children: /* @__PURE__ */ I.jsx(fre, {}) }) });
function Q2(e, t) {
  const n = e.replace("#", "");
  if (!/^[0-9A-Fa-f]{6}$/.test(n))
    return console.warn(`Invalid hex color: ${e}`), Q2("#2d69ff", t);
  const r = parseInt(n.substring(0, 2), 16), i = parseInt(n.substring(2, 4), 16), s = parseInt(n.substring(4, 6), 16), l = Math.max(0, Math.min(1, t)), u = Math.round(r * (1 - l)), d = Math.round(i * (1 - l)), h = Math.round(s * (1 - l)), f = (m) => m.toString(16).padStart(2, "0");
  return `#${f(u)}${f(d)}${f(h)}`;
}
var rd = {}, JS;
function pre() {
  if (JS) return rd;
  JS = 1;
  var e = KR();
  return rd.createRoot = e.createRoot, rd.hydrateRoot = e.hydrateRoot, rd;
}
var mre = pre();
function gre(e) {
  const t = document.createElement("div");
  t.id = "inappmessage-banner-container", document.body.prepend(t), mre.createRoot(t).render(/* @__PURE__ */ I.jsx(hre, { ...e }));
}
typeof window < "u" && (window.FMGInAppMessage = {
  init: gre
});
export {
  hre as NotificationBanner,
  gre as init
};
//# sourceMappingURL=inappmessage.js.map
